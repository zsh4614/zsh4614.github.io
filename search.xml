<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++11之default</title>
    <url>/2021/04/10/C-11%E4%B9%8Bdefault/</url>
    <content><![CDATA[<p>引言：对于default函数，编译器会自动生成函数体定义，从而获得更高的代码执行效率。同时说明了为什么基类的析构函数一定要显式定义成虚析构函数。</p>
<span id="more"></span>
<h3 id="1-背景">1.背景</h3>
<p>C++有4类特殊成员函数，分别是：默认构造函数，默认析构函数，拷贝构造函数以及拷贝赋值运算符，这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X x;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，程序员并没有定义类 X 的默认构造函数，但是在创建类 X 的对象 x 的时候，又需要用到类 X 的默认构造函数，此时，编译器会隐式的为类 X 生成一个默认构造函数。该自动生成的默认构造函数没有参数，包含一个空的函数体，即<code>X::X() &#123;&#125;</code>。虽然自动生成的默认构造函数仅有一个空函数体，但是它仍可用来成功创建类 X 的对象 x，上述程序可以编译通过。</p>
<p>但是，如果程序员为类 X 显式的自定义了非默认构造函数，却没有定义默认构造函数的时候，将会出现编译错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		a = i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;	<span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<p>编译出错的原因在于类 X 已经有了用户自定义的构造函数，所以编译器将不再会为它隐式的生成默认构造函数。如果需要用到默认构造函数来创建类的对象时，程序员必须自己显式的定义默认构造函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>() &#123;&#125;; <span class="comment">// 手动定义默认构造函数</span></span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		a = i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上述程序可以看出，原本期望编译器自动生成的默认构造函数需要程序员手动编写了，即程序员的工作量加大了。此外，手动编写的默认构造函数的代码执行效率比编译器自动生成的默认构造函数低。类的其它几类特殊成员函数也和默认构造函数一样，当存在用户自定义的特殊成员函数时，编译器将不会隐式的自动生成默认特殊成员函数，而需要程序员手动编写，加大了程序员的工作量。类似的，手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低。</p>
<h3 id="2-default的提出">2.default的提出</h3>
<p>为了解决上述两个问题：1. 减轻程序员的编程工作量；2. 获得编译器自动生成的默认特殊成员函数的高代码执行效率，C++11 标准引入了一个新特性：default函数。程序员只需在函数声明后加上<code>=default</code>，就可将该函数声明为 default函数，编译器将为显式声明的 default函数自动生成函数体。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>()= <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		a = i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，编译器会自动生成默认构造函数 <code>X::X() &#123;&#125;</code>，该函数可以比用户自己定义的默认构造函数获得更高的代码效率。</p>
<h3 id="3-default的用法及示例">3.default的用法及示例</h3>
<p>default仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="keyword">default</span>; 			<span class="comment">// 错误, 函数f()非类X的特殊成员函数</span></span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">int</span>) = <span class="keyword">default</span>; 			<span class="comment">// 错误, 构造函数X(int) 非X的特殊成员函数</span></span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">int</span> = <span class="number">1</span>) = <span class="keyword">default</span>; 		<span class="comment">// 错误, 默认构造函数X(int=1)含有默认参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>default函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>() = <span class="keyword">default</span>; 				<span class="comment">//inline default默认构造函数</span></span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;);</span><br><span class="line">	X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;);</span><br><span class="line">	~<span class="built_in">X</span>() = <span class="keyword">default</span>; 			<span class="comment">//inline default析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>; 				<span class="comment">//out-of-line default拷贝构造函数</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//out-of-line default拷贝赋值操作符</span></span><br></pre></td></tr></table></figure>
<p>在 C++ 代码编译过程中，如果程序员没有为类 X 定义析构函数，但是在销毁类 X 对象的时候又需要调用类 X 的析构函数时，编译器会自动隐式的为该类生成一个析构函数。该自动生成的析构函数没有参数，包含一个空的函数体，即<code>X::~X() &#123;&#125;</code>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X* x = <span class="keyword">new</span> Y;</span><br><span class="line">	<span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，程序员没有为基类 X 和派生类 Y 定义析构函数，当在主函数内 delete 基类指针 x 的时候，需要调用基类的析构函数。于是，编译器会隐式自动的为类 X 生成一个析构函数，从而可以成功的销毁 x 指向的派生类对象中的基类子对象（即 int 型成员变量 x）。</p>
<p>但是，这段代码存在<strong>内存泄露</strong>的问题，当利用 delete 语句删除指向派生类对象的指针 x时，<strong>系统调用的是基类的析构函数，而非派生类 Y 类的析构函数</strong>，因此，编译器无法析构派生类的 int 型成员变量 y。</p>
<p>因此，一般情况下我们需要将基类的析构函数定义为虚函数，当利用 delete 语句删除指向派生类对象的基类指针时，系统会调用相应的派生类的析构函数（实现多态性），从而避免内存泄露。但是编译器隐式自动生成的析构函数都是非虚函数，这就需要由程序员手动的为基类 X 定义虚析构函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123;&#125;; 		<span class="comment">// 手动定义虚析构函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	X* x = <span class="keyword">new</span> Y;</span><br><span class="line">	<span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，由于程序员手动为基类 X 定义了虚析构函数，当利用 delete 语句删除指向派生类对象的基类指针 x 时，系统会调用相应的派生类 Y 的析构函数（由编译器隐式自动生成）以及基类 X 的析构函数，从而将派生类对象完整的销毁，可以避免内存泄露。</p>
<p>但是，在清单 8 中，程序员需要手动的编写基类的虚构函数的定义（哪怕函数体是空的），增加了程序员的编程工作量。更值得一提的是，<strong>手动定义的析构函数的代码执行效率要低于编译器自动生成的析构函数</strong>。</p>
<p>为了解决上述问题，我们可以将基类的虚析构函数声明为default函数，这样就可以显式的指定编译器为该函数自动生成函数体。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">X</span>() = <span class="keyword">default</span>; 		<span class="comment">// 编译器自动生成default函数定义体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X* x = <span class="keyword">new</span> Y;</span><br><span class="line">	<span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，编译器会自动生成虚析构函数<code>virtual X::~X() &#123;&#125;</code>，该函数比用户自己定义的虚析构函数具有更高的代码执行效率。</p>
<h3 id="4-总结">4.总结</h3>
<p>1.default只能用于类的特殊成员函数；<br>
2.default解决了两个问题：一是减轻程序员编写函数定义的编程工作量，二是default定义的函数代码执行效率要高于手动编写；<br>
3.default可以在类体内定义，也可在类体外定义；<br>
4.基类的析构函数一定要显式地定义成虚析构函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>default关键字</tag>
        <tag>虚析构函数</tag>
        <tag>代码执行效率</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11之delete</title>
    <url>/2021/04/12/C-11%E4%B9%8Bdeleate/</url>
    <content><![CDATA[<p>引言：delete关键字可以禁用某些函数，或者不期望转换和操作符。</p>
<span id="more"></span>
<h3 id="1-背景">1.背景</h3>
<p>对于 C++ 的类，如果程序员没有为其定义特殊成员函数，那么在需要用到某个特殊成员函数的时候，编译器会隐式的自动生成一个默认的特殊成员函数，比如拷贝构造函数，或者拷贝赋值操作符。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x1;</span><br><span class="line">	X x2 = x1; 	<span class="comment">// 正确，调用编译器隐式生成的默认拷贝构造函数</span></span><br><span class="line">	X x3;</span><br><span class="line">	x3 = x1; 		<span class="comment">// 正确，调用编译器隐式生成的默认拷贝赋值操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，程序员不需要自己手动编写拷贝构造函数以及拷贝赋值操作符，依靠编译器自动生成的默认拷贝构造函数以及拷贝赋值操作符就可以实现类对象的拷贝和赋值。这在某些情况下是非常方便省事的，但是在某些情况下，假设我们<strong>不允许发生类对象之间的拷贝和赋值</strong>，可是又无法阻止编译器隐式自动生成默认的拷贝构造函数以及拷贝赋值操作符，那这就成为一个问题了。</p>
<h3 id="2-delete的提出">2.delete的提出</h3>
<p>为了能够让程序员显式的禁用某个函数，C++11标准引入了一个新特性：delete函数。程序员只需在函数声明后加上<code>=delete</code>，就可将该函数禁用。例如，我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 delete函数，就可以禁止类 X 对象之间的拷贝和赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>();</span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; 					<span class="comment">// 声明拷贝构造函数为delete函数</span></span><br><span class="line">	X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; 		<span class="comment">// 声明拷贝赋值操作符为delete函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x1;</span><br><span class="line">	X x2=x1; 	<span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">	X x3;</span><br><span class="line">	x3=x1; 		<span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，虽然只显式的禁用了一个拷贝构造函数和一个拷贝赋值操作符，但是由于编译器检测到类 X 存在用户自定义的拷贝构造函数和拷贝赋值操作符的声明，所以不会再隐式的生成其它参数类型的拷贝构造函数或拷贝赋值操作符，也就相当于类 X 没有任何拷贝构造函数和拷贝赋值操作符，所以对象间的拷贝和赋值被完全禁止了。</p>
<h3 id="3-delete的用法及示例">3.delete的用法及示例</h3>
<p>delete函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换。在下面程序中，假设类 X 只支持参数为双精度浮点数double类型的转换构造函数，而不支持参数为整数int类型的转换构造函数，则可以将参数为int类型的转换构造函数声明为delete函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">double</span>);</span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">int</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">X <span class="title">x1</span><span class="params">(<span class="number">1.2</span>)</span></span>;</span><br><span class="line">	<span class="function">X <span class="title">x2</span><span class="params">(<span class="number">2</span>)</span></span>; 		<span class="comment">// 错误，参数为整数int类型的转换构造函数被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete函数特性还可以用来禁用某些用户自定义的类的new操作符，从而避免在自由存储区创建类的对象。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X *pa = <span class="keyword">new</span> X; 			<span class="comment">// 错误，new操作符被禁用</span></span><br><span class="line">	X *pb = <span class="keyword">new</span> X[<span class="number">10</span>]; 		<span class="comment">// 错误，new[]操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须在函数第一次声明的时候将其声明为delete函数，否则编译器会报错。即对于类的成员函数而言，delete函数必须在类体里（inline）定义，而不能在类体外（out-of-line）定义。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; 	<span class="comment">// 错误，delete函数必须在函数第一次声明处声明</span></span><br></pre></td></tr></table></figure>
<p>虽然 default函数特性规定了只有类的特殊成员函数才能被声明为default函数，但是delete函数特性并没有此限制。非类的成员函数，即普通函数也可以被声明为 delete函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">add</span>(a, b); 			<span class="comment">// 错误，函数add(int, int)被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在上述程序中，虽然 add(int, int)函数被禁用了，但是禁用的仅是函数的定义，即该函数不能被调用。但是函数标示符add仍是有效的，在名字查找和函数重载解析时仍会查找到该函数标示符。如果编译器在解析重载函数时，解析结果为已经delete的函数，则会出现编译错误。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl; 			<span class="comment">// 错误，调用delete函数add(int, int)</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.2</span>, <span class="number">1.3</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结">4.总结</h3>
<p>1.delete函数用于禁用某个函数；<br>
2.delete必须在函数第一次声明的时候使用，对于类的成员函数，即只能在类体内使用，这点和default不同；<br>
3.delete既可以用于类的特殊成员函数，也可用于普通函数；<br>
4.delete可以用来禁用某些用户自定义的类的new操作符，从而避免在自由存储区创建类的对象;<br>
5.delete可以通过参数禁用某种参数类型的函数，并不会禁用函数的标识符，所以不会影响函数重载；</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>delete关键字</tag>
      </tags>
  </entry>
</search>
