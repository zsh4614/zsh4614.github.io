<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++11之delete</title>
    <url>/C-11%E4%B9%8Bdeleate/</url>
    <content><![CDATA[<p>引言：delete关键字可以禁用某些函数，或者不期望转换和操作符。</p>
<span id="more"></span>
<h3 id="1-背景">1.背景</h3>
<p>对于 C++ 的类，如果程序员没有为其定义特殊成员函数，那么在需要用到某个特殊成员函数的时候，编译器会隐式的自动生成一个默认的特殊成员函数，比如拷贝构造函数，或者拷贝赋值操作符。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x1;</span><br><span class="line">    X x2 = x1; 	<span class="comment">// 正确，调用编译器隐式生成的默认拷贝构造函数</span></span><br><span class="line">    X x3;</span><br><span class="line">    x3 = x1; 		<span class="comment">// 正确，调用编译器隐式生成的默认拷贝赋值操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，程序员不需要自己手动编写拷贝构造函数以及拷贝赋值操作符，依靠编译器自动生成的默认拷贝构造函数以及拷贝赋值操作符就可以实现类对象的拷贝和赋值。这在某些情况下是非常方便省事的，但是在某些情况下，假设我们<strong>不允许发生类对象之间的拷贝和赋值</strong>，可是又无法阻止编译器隐式自动生成默认的拷贝构造函数以及拷贝赋值操作符，那这就成为一个问题了。</p>
<h3 id="2-delete的提出">2.delete的提出</h3>
<p>为了能够让程序员显式的禁用某个函数，C++11标准引入了一个新特性：delete函数。程序员只需在函数声明后加上<code>=delete</code>，就可将该函数禁用。例如，我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 delete函数，就可以禁止类 X 对象之间的拷贝和赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>();</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; 					<span class="comment">// 声明拷贝构造函数为delete函数</span></span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; 		<span class="comment">// 声明拷贝赋值操作符为delete函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x1;</span><br><span class="line">    X x2=x1; 	<span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">    X x3;</span><br><span class="line">    x3=x1; 		<span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，虽然只显式的禁用了一个拷贝构造函数和一个拷贝赋值操作符，但是由于编译器检测到类 X 存在用户自定义的拷贝构造函数和拷贝赋值操作符的声明，所以不会再隐式的生成其它参数类型的拷贝构造函数或拷贝赋值操作符，也就相当于类 X 没有任何拷贝构造函数和拷贝赋值操作符，所以对象间的拷贝和赋值被完全禁止了。</p>
<h3 id="3-delete的用法及示例">3.delete的用法及示例</h3>
<p>delete函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换。在下面程序中，假设类 X 只支持参数为双精度浮点数double类型的转换构造函数，而不支持参数为整数int类型的转换构造函数，则可以将参数为int类型的转换构造函数声明为delete函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">double</span>);</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">x1</span><span class="params">(<span class="number">1.2</span>)</span></span>;</span><br><span class="line">    <span class="function">X <span class="title">x2</span><span class="params">(<span class="number">2</span>)</span></span>; 		<span class="comment">// 错误，参数为整数int类型的转换构造函数被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete函数特性还可以用来禁用某些用户自定义的类的new操作符，从而避免在自由存储区创建类的对象。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X *pa = <span class="keyword">new</span> X; 			<span class="comment">// 错误，new操作符被禁用</span></span><br><span class="line">    X *pb = <span class="keyword">new</span> X[<span class="number">10</span>]; 		<span class="comment">// 错误，new[]操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须在函数第一次声明的时候将其声明为delete函数，否则编译器会报错。即对于类的成员函数而言，delete函数必须在类体里（inline）定义，而不能在类体外（out-of-line）定义。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; 	<span class="comment">// 错误，delete函数必须在函数第一次声明处声明</span></span><br></pre></td></tr></table></figure>
<p>虽然 default函数特性规定了只有类的特殊成员函数才能被声明为default函数，但是delete函数特性并没有此限制。非类的成员函数，即普通函数也可以被声明为 delete函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">add</span>(a, b); 			<span class="comment">// 错误，函数add(int, int)被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在上述程序中，虽然 add(int, int)函数被禁用了，但是禁用的仅是函数的定义，即该函数不能被调用。但是函数标示符add仍是有效的，在名字查找和函数重载解析时仍会查找到该函数标示符。如果编译器在解析重载函数时，解析结果为已经delete的函数，则会出现编译错误。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl; 			<span class="comment">// 错误，调用delete函数add(int, int)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.2</span>, <span class="number">1.3</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结">4.总结</h3>
<p>1.delete函数用于禁用某个函数；<br>
2.delete必须在函数第一次声明的时候使用，对于类的成员函数，即只能在类体内使用，这点和default不同；<br>
3.delete既可以用于类的特殊成员函数，也可用于普通函数；<br>
4.delete可以用来禁用某些用户自定义的类的new操作符，从而避免在自由存储区创建类的对象;<br>
5.delete可以通过参数禁用某种参数类型的函数，并不会禁用函数的标识符，所以不会影响函数重载；</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>delete关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11之shared_ptr</title>
    <url>/C-11%E4%B9%8Bshared-ptr/</url>
    <content><![CDATA[<p>引言：本节介绍C++11新特性之 shared_ptr 智能指针。</p>
<span id="more"></span>
<h3 id="背景">背景</h3>
<p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。如今，垃圾回收机制已经大行其道，得到了诸多编程语言的支持，例如 Java、Python、C#、PHP 等。而 C++ 虽然从来没有公开得支持过垃圾回收机制，但 C++98/03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 **unique_ptr、shared_ptr 以及 weak_ptr **这 3 个智能指针来实现堆内存的自动回收。所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，<strong>使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现</strong>。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p>
<p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p>
<h3 id="说明">说明</h3>
<p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr&lt;T&gt;（其中 T 表示指针指向的具体数据类型）的定义位于<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std；	<span class="comment">//也可以不添加，则后续在使用 shared_ptr 智能指针时，就需要明确指明std::。</span></span><br></pre></td></tr></table></figure>
<p>值得一提的是，和 unique_ptr、weak_ptr 不同之处在于，<strong>多个 shared_ptr 智能指针可以共同使用同一块堆内存</strong>。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h3 id="shared-ptr智能指针的创建">shared_ptr智能指针的创建</h3>
<p>shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数，这里列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</p>
<ol>
<li>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p1;			<span class="comment">// 不传入任何参数			</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;	<span class="comment">// 传入空指针nullptr</span></span><br></pre></td></tr></table></figure>
<p>注意，<strong>空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。</strong></p>
<ol start="2">
<li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>由此，我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p>
<p>同时，C++11 标准中还提供了 std::make_shared&lt;T&gt; 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>以上 2 种方式创建的 p3 是完全相同。</p>
<p><strong>注意，不能将一个原始指针直接赋值给一个智能指针：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);		<span class="comment">// 错误 </span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>除此之外，shared_ptr&lt;T&gt; 模板还提供有相应的拷贝构造函数和移动构造函数，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;	<span class="comment">//或者</span></span><br><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p4 = p3;</span><br><span class="line"><span class="comment">// 调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;	<span class="comment">// 或者</span></span><br><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p5 = std::<span class="built_in">move</span>(p4);</span><br></pre></td></tr></table></figure>
<p>如上所示，p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。</p>
<p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。</p>
<p><strong>注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;	<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li>
</ol>
<p>在某些场景中，自定义释放规则是很有必要的。比如，<strong>对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</strong></p>
<p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete&lt;T&gt; 模板类，我们也可以自定义释放规则：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="keyword">int</span> []&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义释放规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteInt</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C++11线程池</title>
    <url>/C-11%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>引言：本文主要介绍线程池，并基于C++11实现。</p>
<span id="more"></span>
<h3 id="背景">背景</h3>
<p>传统多线程方案是：接受一个任务之后，创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么将处于不停的创建线程，销毁线程的状态。我们将传统方案中的线程执行过程分为三个过程：线程创建时间+线程执行时间+线程销毁时间，如果线程执行时间很短的话，线程本身开销占的比重将会很大，这个开销将不可忽略。另外每个 Thread 都需要有一个内核线程的支持，也就意味着每个Thread都需要消耗一定的内核资源（如内核线程的栈空间），因为能创建的 Thread 是有限的，默认一个线程的线程栈大小是1M，如果每来一个任务就创建一个线程的话，1024个任务就会创建1024个线程，就会占用1个G的内存，很容易就系统崩溃了。</p>
<p>因此，线程池的出现正是着眼于线程本身的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p>
<h3 id="实现">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Ptr = std::shared_ptr&lt;ThreadPool&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">int</span> idl_thr_num) : <span class="built_in">run_</span>(<span class="literal">true</span>), <span class="built_in">idl_thr_num_</span>(idl_thr_num) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idl_thr_num_; ++i) &#123;</span><br><span class="line">            pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]&#123;  <span class="comment">// 工作线程函数</span></span><br><span class="line">                <span class="keyword">while</span> (run_) &#123;</span><br><span class="line">                    Task task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; lock&#123; mutex_ &#125;;</span><br><span class="line">                        cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> !run_ || !task_.<span class="built_in">empty</span>(); &#125;);  <span class="comment">// 等待直到任务队列有任务或者线程池停止工作</span></span><br><span class="line">                        <span class="keyword">if</span> (!run_ &amp;&amp; task_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(task_.<span class="built_in">front</span>());  <span class="comment">// 从任务队列首取出一个任务</span></span><br><span class="line">                        task_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    idl_thr_num_--;</span><br><span class="line">                    <span class="built_in">task</span>();  <span class="comment">// 执行任务</span></span><br><span class="line">                    idl_thr_num_++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        run_ = <span class="literal">false</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; thread : pool_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">                thread.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idlCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idl_thr_num_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">    auto commit(F&amp;&amp; f, Args&amp;&amp;... args)-&gt;std::future&lt;decltype(f(args...))&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!run_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;commit on ThreadPool is stopped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 函数f的返回值类型</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        std::future&lt;RetType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; lock&#123;mutex_ &#125;;</span><br><span class="line">            task_.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);  <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_one</span>();  <span class="comment">// 唤醒一个线程</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">    std::vector&lt;std::thread&gt; pool_;             <span class="comment">// 线程池</span></span><br><span class="line">    std::queue&lt;Task&gt; task_;                     <span class="comment">// 任务队列</span></span><br><span class="line">    std::mutex mutex_;                          <span class="comment">// 线程锁</span></span><br><span class="line">    std::condition_variable cv_;                <span class="comment">// 条件阻塞</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">bool</span>&gt; run_;                     <span class="comment">// 线程池是否执行标志</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">int</span>&gt; idl_thr_num_;              <span class="comment">// 空闲线程数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="简单使用">简单使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在执行第 %d 个任务， 线程id为 %d\n&quot;</span>, i, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行完成第 %d 个任务， 线程id为 %d\n&quot;</span>, i, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    ThreadPool::Ptr thread_pool_ptr = std::make_shared&lt;ThreadPool&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        thread_pool_ptr-&gt;<span class="built_in">commit</span>([i]()&#123;<span class="built_in">task</span>(i);&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码链接：<a href="https://github.com/zsh4614/thread_pool">https://github.com/zsh4614/thread_pool</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11之匿名函数</title>
    <url>/C-11%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>引言：本文主要介绍C++11新特性的lambda函数用法。</p>
<span id="more"></span>
<h3 id="语法格式及含义">语法格式及含义</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>[外部变量访问方式说明符]</li>
</ul>
<p>[]是lambda表达式标识符，不可省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量。所谓外部变量，指的是和当前 lambda 表达式<strong>位于同一作用域内的所有局部变量</strong>。注意区分外部变量和全局变量。外部变量格式有如下几种书写方式：</p>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中<strong>不导入</strong>任何外部变量。</td>
</tr>
<tr>
<td>[=]</td>
<td>只有一个 = 等号，表示以值传递的方式<strong>导入所有</strong>外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式<strong>导入所有</strong>外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[=,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[&amp;,val1,…]</td>
<td>表示除 val1 以值传递的方式导入外，其它外部变量都以引用传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<ul>
<li>(参数)</li>
</ul>
<p>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，<strong>如果不需要传递参数，可以连同 () 小括号一起省略</strong>；</p>
<ul>
<li>mutable</li>
</ul>
<p>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。（修改的是拷贝的那一份，并不会修改真正的外部变量）</p>
<ul>
<li>noexcept/throw()</li>
</ul>
<p>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败。</p>
<ul>
<li>-&gt; 返回值类型</li>
</ul>
<p>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略。</p>
<ul>
<li>函数体</li>
</ul>
<p>除了可以使用传入参数外，还可以使用指定的外部变量和全局变量。（外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值）</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>lambda函数</tag>
        <tag>匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的栈对象和堆对象</title>
    <url>/C-%E4%B8%AD%E7%9A%84%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A0%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>引言：本文主要介绍两种建立类对象的方式，在栈上和堆上建立，以及对它们的理解。</p>
<span id="more"></span>
<h3 id="背景">背景</h3>
<p>在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。</p>
<ul>
<li>
<p><strong>静态建立类对象：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。</strong></p>
</li>
<li>
<p><strong>动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。</strong></p>
</li>
</ul>
<h3 id="区别">区别</h3>
<p>初始化两种方法：</p>
<p>第一种初始化方法：ClassName object(初始化参数)；</p>
<p>第二种初始化方法：ClassName* object=new ClassName(初始化参数);</p>
<p>两种初始化方法的区别：</p>
<p>第一种初始化方法：在stack栈里面分配空间，自动释放。</p>
<p>第二种初始化方法：在heap堆里面分配空间，要手动释放。</p>
<h3 id="选择">选择</h3>
<p>栈对象的优势是在适当的时候自动生成，又在适当的时候<strong>自动销毁</strong>，不需要程序员操心；而且<strong>栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用 operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了</strong>。但是要注意的是，通常<strong>栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配</strong>。特别要注意<strong>递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误</strong>。</p>
<p>堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，<strong>相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。</strong></p>
<h3 id="限制">限制</h3>
<p>如何限制类对象只能在堆或者栈上建立呢？下面分别进行讨论。</p>
<p><strong>1、只能在堆上分配类对象，就是不能静态建立类对象，即不能直接调用类的构造函数。</strong></p>
<p>容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operatornew()函数只用于分配内存，无法提供构造功能。因此，<strong>这种方法不可以。</strong></p>
<p>当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，<strong>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了</strong>。代码如下：（这种方法不好）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>试着使用<code>A a</code>;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。<strong>类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。</strong></p>
<p>上述方法的缺点：</p>
<ul>
<li>
<p><strong>无法解决继承问题</strong>。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。<strong>将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。</strong></p>
</li>
<li>
<p><strong>类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。</strong>（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。</p>
</li>
</ul>
<p>为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于<strong>单例模式</strong>：（这种方法比较可取）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> A* <span class="title">create</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>这样，调用create()函数在堆上创建类A对象，调用destory()函数释放内存。</p>
<p><strong>2、只能在栈上分配类对象</strong></p>
<p>只有使用new运算符，对象才会建立在堆上，因此，**只要禁用new运算符就可以实现类对象只能建立在栈上。**虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，<strong>将operator new()设为私有即可禁止对象被new在堆上</strong>。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>转载自：<a href="http://blog.csdn.net/sdnu111111111/article/details/38707923">http://blog.csdn.net/sdnu111111111/article/details/38707923</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>new</tag>
        <tag>delete</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11之default</title>
    <url>/C-11%E4%B9%8Bdefault/</url>
    <content><![CDATA[<p>引言：对于default函数，编译器会自动生成函数体定义，从而获得更高的代码执行效率。同时说明了为什么基类的析构函数一定要显式定义成虚析构函数。</p>
<span id="more"></span>
<h3 id="1-背景">1.背景</h3>
<p>C++有4类特殊成员函数，分别是：默认构造函数，默认析构函数，拷贝构造函数以及拷贝赋值运算符，这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X x;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，程序员并没有定义类 X 的默认构造函数，但是在创建类 X 的对象 x 的时候，又需要用到类 X 的默认构造函数，此时，编译器会隐式的为类 X 生成一个默认构造函数。该自动生成的默认构造函数没有参数，包含一个空的函数体，即<code>X::X() &#123;&#125;</code>。虽然自动生成的默认构造函数仅有一个空函数体，但是它仍可用来成功创建类 X 的对象 x，上述程序可以编译通过。</p>
<p>但是，如果程序员为类 X 显式的自定义了非默认构造函数，却没有定义默认构造函数的时候，将会出现编译错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;	<span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<p>编译出错的原因在于类 X 已经有了用户自定义的构造函数，所以编译器将不再会为它隐式的生成默认构造函数。如果需要用到默认构造函数来创建类的对象时，程序员必须自己显式的定义默认构造函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123;&#125;; <span class="comment">// 手动定义默认构造函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上述程序可以看出，原本期望编译器自动生成的默认构造函数需要程序员手动编写了，即程序员的工作量加大了。此外，手动编写的默认构造函数的代码执行效率比编译器自动生成的默认构造函数低。类的其它几类特殊成员函数也和默认构造函数一样，当存在用户自定义的特殊成员函数时，编译器将不会隐式的自动生成默认特殊成员函数，而需要程序员手动编写，加大了程序员的工作量。类似的，手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低。</p>
<h3 id="2-default的提出">2.default的提出</h3>
<p>为了解决上述两个问题：1. 减轻程序员的编程工作量；2. 获得编译器自动生成的默认特殊成员函数的高代码执行效率，C++11 标准引入了一个新特性：default函数。程序员只需在函数声明后加上<code>=default</code>，就可将该函数声明为 default函数，编译器将为显式声明的 default函数自动生成函数体。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>()= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，编译器会自动生成默认构造函数 <code>X::X() &#123;&#125;</code>，该函数可以比用户自己定义的默认构造函数获得更高的代码效率。</p>
<h3 id="3-default的用法及示例">3.default的用法及示例</h3>
<p>default仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="keyword">default</span>; 			<span class="comment">// 错误, 函数f()非类X的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span>) = <span class="keyword">default</span>; 			<span class="comment">// 错误, 构造函数X(int) 非X的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> = <span class="number">1</span>) = <span class="keyword">default</span>; 		<span class="comment">// 错误, 默认构造函数X(int=1)含有默认参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>default函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() = <span class="keyword">default</span>; 				<span class="comment">//inline default默认构造函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp;);</span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;);</span><br><span class="line">    ~<span class="built_in">X</span>() = <span class="keyword">default</span>; 			<span class="comment">//inline default析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>; 				<span class="comment">//out-of-line default拷贝构造函数</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//out-of-line default拷贝赋值操作符</span></span><br></pre></td></tr></table></figure>
<p>在 C++ 代码编译过程中，如果程序员没有为类 X 定义析构函数，但是在销毁类 X 对象的时候又需要调用类 X 的析构函数时，编译器会自动隐式的为该类生成一个析构函数。该自动生成的析构函数没有参数，包含一个空的函数体，即<code>X::~X() &#123;&#125;</code>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X* x = <span class="keyword">new</span> Y;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，程序员没有为基类 X 和派生类 Y 定义析构函数，当在主函数内 delete 基类指针 x 的时候，需要调用基类的析构函数。于是，编译器会隐式自动的为类 X 生成一个析构函数，从而可以成功的销毁 x 指向的派生类对象中的基类子对象（即 int 型成员变量 x）。</p>
<p>但是，这段代码存在<strong>内存泄露</strong>的问题，当利用 delete 语句删除指向派生类对象的指针 x时，<strong>系统调用的是基类的析构函数，而非派生类 Y 类的析构函数</strong>，因此，编译器无法析构派生类的 int 型成员变量 y。</p>
<p>因此，一般情况下我们需要将基类的析构函数定义为虚函数，当利用 delete 语句删除指向派生类对象的基类指针时，系统会调用相应的派生类的析构函数（实现多态性），从而避免内存泄露。但是编译器隐式自动生成的析构函数都是非虚函数，这就需要由程序员手动的为基类 X 定义虚析构函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123;&#125;; 		<span class="comment">// 手动定义虚析构函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X* x = <span class="keyword">new</span> Y;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，由于程序员手动为基类 X 定义了虚析构函数，当利用 delete 语句删除指向派生类对象的基类指针 x 时，系统会调用相应的派生类 Y 的析构函数（由编译器隐式自动生成）以及基类 X 的析构函数，从而将派生类对象完整的销毁，可以避免内存泄露。</p>
<p>但是，在清单 8 中，程序员需要手动的编写基类的虚构函数的定义（哪怕函数体是空的），增加了程序员的编程工作量。更值得一提的是，<strong>手动定义的析构函数的代码执行效率要低于编译器自动生成的析构函数</strong>。</p>
<p>为了解决上述问题，我们可以将基类的虚析构函数声明为default函数，这样就可以显式的指定编译器为该函数自动生成函数体。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() = <span class="keyword">default</span>; 		<span class="comment">// 编译器自动生成default函数定义体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X* x = <span class="keyword">new</span> Y;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述程序中，编译器会自动生成虚析构函数<code>virtual X::~X() &#123;&#125;</code>，该函数比用户自己定义的虚析构函数具有更高的代码执行效率。</p>
<h3 id="4-总结">4.总结</h3>
<p>1.default只能用于类的特殊成员函数；<br>
2.default解决了两个问题：一是减轻程序员编写函数定义的编程工作量，二是default定义的函数代码执行效率要高于手动编写；<br>
3.default可以在类体内定义，也可在类体外定义；<br>
4.基类的析构函数一定要显式地定义成虚析构函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>default关键字</tag>
        <tag>虚析构函数</tag>
        <tag>代码执行效率</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的static关键字总结</title>
    <url>/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>引言：C++的static有两种用法，面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。</p>
<span id="more"></span>
<h3 id="1-面向过程设计中的static">1.面向过程设计中的static</h3>
<h4 id="1-1静态全局变量">1.1静态全局变量</h4>
<p>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量，我们先举一个静态全局变量的例子，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态全局变量有以下特点：</p>
<ul>
<li>该变量在全局数据区分配内存；</li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li>
<li>静态全局变量在声明它的整个文件都是可见的，而<strong>在文件之外是不可见</strong>的；</li>
</ul>
<p>静态变量都在<strong>全局数据区</strong>分配内存，包括后面将要提到的静态局部变量。</p>
<p>一般程序的由new产生的动态数据存放在<strong>堆区</strong>，函数内部的自动变量存放在<strong>栈区</strong>。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在<strong>全局数据区</strong>。全局数据区的数据并不会因为函数的退出而释放空间。细心的读者可能会发现，上面的代码中将<code>static int n;</code>改为<code>int n; </code>。程序照样正常运行。的确，定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：</p>
<ul>
<li>静态全局变量不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的变量，不会发生冲突；</li>
</ul>
<p>将上述示例代码改为如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　n=<span class="number">20</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 n++;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行，会发现上述代码可以分别通过编译，但运行时出现错误。将<code>static int n;</code>改为<code>int n;</code>，再次编译运行程序，就会明白全局变量和静态全局变量的区别。</p>
<h4 id="1-2静态局部变量">1.2静态局部变量</h4>
<p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 我们先举一个静态局部变量的例子，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="keyword">static</span> n=<span class="number">10</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">　　 n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，在函数体内定义了一个变量，每当程序运行到该语句时，都会给该局部变量分配栈区内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<p>静态局部变量有以下特点：</p>
<ul>
<li>该变量在全局数据区分配内存；</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li>
<li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li>
</ul>
<h4 id="1-3静态函数">1.3静态函数</h4>
<p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;		<span class="comment">//声明静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;			<span class="comment">//定义静态函数</span></span><br><span class="line"> 　　<span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义静态函数的好处：</p>
<ul>
<li>静态函数不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突。</li>
</ul>
<h3 id="2-面向对象的static关键字">2.面向对象的static关键字</h3>
<h4 id="2-1静态数据成员">2.1静态数据成员</h4>
<p>在类内的数据成员的声明前加上关键字static，该数据成员就是类内的静态成员函数，先举一个静态数据成员的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 　　<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line"> 　　<span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 　　<span class="keyword">int</span> a,b,c;</span><br><span class="line"> 　　<span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) &#123;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> 　　Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line">　　 <span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> 　　N.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态数据成员有以下特点：</p>
<ul>
<li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也<strong>只有一份拷贝</strong>，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</li>
<li><strong>静态数据成员存储在全局数据区</strong>。静态数据成员<strong>定义时要分配空间，所以不能在类声明中定义</strong>。在上述程序中，语句<code>int Myclass::Sum=0;</code>是定义静态数据成员；</li>
<li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li>
<li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li>
<li>静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：<code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code></li>
<li>类的静态数据成员有两种访问形式：<code>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞</code></li>
<li>静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以<strong>节省存储空间</strong>。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；</li>
<li>同全局变量相比，使用静态数据成员有两个优势：
<ul>
<li>静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；</li>
<li>可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</li>
</ul>
</li>
</ul>
<h4 id="2-2静态成员函数">2.2静态成员函数</h4>
<p>与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。<strong>普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身</strong>，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它<strong>不具有this指针</strong>。从这个意义上讲，它<strong>无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数</strong>。下面举个静态成员函数的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 　　<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line"> 　　<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;/声明静态成员函数</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 　　<span class="keyword">int</span> a,b,c;</span><br><span class="line">　　 <span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> 　　Sum+=a+b+c; <span class="comment">//非静态成员函数可以访问静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> <span class="comment">//静态成员函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="comment">// cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员</span></span><br><span class="line"> 　　cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> 　　N.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　Myclass::<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于静态成员函数，可以总结为以下几点：</p>
<ul>
<li>出现在类体外的函数<strong>定义不能指定关键字static</strong>；</li>
<li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li>
<li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li>
<li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li>
<li>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式调用类的静态成员函数：<code>＜类名＞::＜静态成员函数名＞（＜参数表＞）</code>。</li>
</ul>
<h3 id="3-总结">3.总结</h3>
<p><strong>从作用域看</strong>，全局变量具有全局作用域，全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用<code>extern</code> 关键字再次声明这个全局变量。局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p>
<p><strong>从分配内存空间来看</strong>，<strong>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</strong></p>
<p><strong>综上，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期，并没有改变它的作用域，即作用域还是在函数内部。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>static关键字</tag>
        <tag>全局变量</tag>
        <tag>局部变量</tag>
        <tag>静态全局变量</tag>
        <tag>静态局部变量</tag>
        <tag>静态成员函数</tag>
        <tag>静态数据成员</tag>
        <tag>作用域</tag>
        <tag>生存期</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之STL关联式容器set</title>
    <url>/C-STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set/</url>
    <content><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器set，包括其接口，用法和注意事项。</p>
<span id="more"></span>
<h3 id="综述">综述</h3>
<p>set本质上也是一种关联式容器，只是在存储键值对时，要求键值必须相等。举个例子，如下有 2 组键值对数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&lt;&#39;a&#39;, 1&gt;, &lt;&#39;b&#39;, 2&gt;, &lt;&#39;c&#39;, 3&gt;&#125;</span><br><span class="line">&#123;&lt;&#39;a&#39;, &#39;a&#39;&gt;, &lt;&#39;b&#39;, &#39;b&#39;&gt;, &lt;&#39;c&#39;, &#39;c&#39;&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而<strong>无法存储第一组键值对</strong>。</p>
<p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,‘b’,‘c’} ，该容器即可成功将它们存储起来。</p>
<p>set容器会自行根据键的大小对存储的键值对进行排序。另外，使用 set 容器存储的<strong>各个元素的值必须各不相同</strong>。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。<strong>切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</strong></p>
<p>set 容器的类模板定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;T&gt;,        <span class="comment">// 指定 set 容器内部的排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;T&gt;      <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure>
<p>注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。</p>
<h3 id="创建">创建</h3>
<p>常见的创建 set 容器的方法，大致有以下 5 种。</p>
<ol>
<li>调用默认构造函数，创建空的 set 容器。比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure>
<p>由此就创建好了一个 set 容器，该容器采用默认的std::less<T>规则，会对存储的 string 类型元素做升序排序。注意，<strong>由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</strong></p>
<ol start="2">
<li>除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123;<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure>
<p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p>
<p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> myset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure>
<p>注意，<strong>由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数</strong></p>
<ol start="4">
<li>在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(++myset.begin(), myset.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>以上几种方式创建的 set 容器，都采用了默认的std::less<T>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset&#123;</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>通过选用 std::greater<string> 降序规则，myset 容器中元素的存储顺序为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="成员方法">成员方法</h3>
<p>下表列出了 set 容器提供的常用成员方法以及各自的功能。</p>
<p><img src="https://s2.loli.net/2022/01/10/ldfXza6AqFe25Np.png" alt="image.png"></p>
<h3 id="迭代器">迭代器</h3>
<p>和其他容器不同，set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，<strong>要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</strong></p>
<p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。</p>
<p>注意，set成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，set成员方法返回的迭代器，<strong>无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值</strong>。</p>
<p>下面程序以 begin()/end() 为例，演示了如何使用图 2 中相关迭代器遍历 set 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p>
<p><strong>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</strong></p>
<p>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</p>
<h3 id="insert-方法">insert()方法</h3>
<p>为满足不同场景的需要，C++ 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">//右值引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);</span><br></pre></td></tr></table></figure>
<p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式。</p>
<p><strong>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</strong></p>
<ul>
<li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li>
<li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;set&lt;string&gt;::iterator, <span class="keyword">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iter-&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F; bool &#x3D; 1</span><br><span class="line">iter-&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F; bool &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>通过观察输出结果不难看出，程序中两次借助 insert() 方法向 set 容器中添加元素，都成功了。</p>
<ol start="2">
<li>insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p>
<ul>
<li>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</li>
<li>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">end</span>(),<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myset size &#x3D;1</span><br><span class="line">myset size &#x3D;2</span><br></pre></td></tr></table></figure>
<p>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，<strong>insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</strong></p>
<ol start="3">
<li>insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。</li>
</ol>
<p>insert() 方法的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">  void insert (InputIterator first, InputIterator last);</span><br></pre></td></tr></table></figure>
<p>其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//创建一个同类型的空 set 容器</span></span><br><span class="line">    std::set&lt;std::string&gt; otherset;</span><br><span class="line">    <span class="comment">//利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.<span class="built_in">insert</span>(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;</span><br></pre></td></tr></table></figure>
<p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p>
<ol start="4">
<li>采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void insert ( &#123;E1, E2,...,En&#125; );</span><br></pre></td></tr></table></figure>
<p>其中，Ei 表示新添加的元素。</p>
<p>值的一提的是，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为<strong>implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高</strong>。</p>
<h3 id="emplace-和emplace-hint-方法">emplace()和emplace_hint()方法</h3>
<p>emplace() 和 emplace_hint() 是 C++ 11 标准加入到 set 类模板中的，相比具有同样功能的 insert() 方法，完成同样的任务，emplace() 和 emplace_hint() 的效率会更高。</p>
<p>emplace() 方法的语法格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>
<p>其中，参数 (Args&amp;&amp;… args) 指的是，只需要传入构建新元素所需的数据即可，该方法可以自行利用这些数据构建出要添加的元素。**比如，若 set 容器中存储的元素类型为自定义的结构体或者类，则在使用 emplace() 方法向容器中添加新元素时，构造新结构体变量（或者类对象）需要多少个数据，就需要为该方法传入相应个数的数据。<br>
**</p>
<p>另外，该方法的返回值类型为 pair 类型，其包含 2 个元素，一个迭代器和一个 bool 值：</p>
<ul>
<li>当该方法将目标元素成功添加到 set 容器中时，其返回的迭代器指向新插入的元素，同时 bool 值为 true；</li>
<li>当添加失败时，则表明原 set 容器中已存在相同值的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时 bool 值为 false。</li>
</ul>
<p>下面程序演示 emplace() 方法的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;set&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret = myset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&quot;</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myset size &#x3D; 1</span><br><span class="line">ret.iter &#x3D; &lt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;, 1&gt;</span><br></pre></td></tr></table></figure>
<p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p>
<p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>和 emplace() 方法相比，有以下 2 点不同：</p>
<ul>
<li>该方法需要额外传入一个迭代器，用来指明新元素添加到 set 容器的具体位置（<strong>新元素会添加到该迭代器指向元素的前面</strong>）；</li>
<li>返回值是一个迭代器，而不再是 pair 对象。当成功添加元素时，返回的迭代器指向新添加的元素；反之，如果添加失败，则迭代器就指向 set 容器和要添加元素的值相同的元素。</li>
</ul>
<p>下面程序演示 emplace_hint() 方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//在 set 容器的指定位置添加键值对</span></span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">emplace_hint</span>(myset.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myset size &#x3D; 1</span><br><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;</span><br></pre></td></tr></table></figure>
<p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法中指定了添加新元素的位置，但 set 容器为了保持数据的有序状态，可能会移动其位置。</p>
<p>以上内容讲解了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的。</p>
<h3 id="erase-和clear-方法">erase()和clear()方法</h3>
<p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p>
<p>set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，<strong>表示成功删除的元素个数</strong>；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中<strong>删除元素之后的第一个元素</strong>。</p>
<p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p>
<p>如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然，该方法不需要传入任何参数，也没有任何返回值。</p>
<p>疑问：<br>
1.既然const的迭代器和非const的迭代器都不能修改值，那有什么区别？<br>
2.右值引用<br>
3.为什么emplace没有返回值也能调用成功，是所有函数都这样吗？<br>
4.emplace效率高的原因？</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>set</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的非常量引用不能指向临时对象</title>
    <url>/C-%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E6%8C%87%E5%90%91%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>引言：本文主要介绍为什么C++标准规定非常量引用不能指向临时对象，以及什么情况下会产生临时对象。</p>
<span id="more"></span>
<h3 id="举例">举例</h3>
<p>非常量引用指向临时对象 —— 即：将临时对象传递给非常量引用类型。比如以下情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Rational类中定义如下</span></span><br><span class="line"><span class="comment">//重载2个操作符函数：“+”号和“&lt;&lt;” 输出符号</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt; (ostream&amp; outs,Rational &amp;rational);</span><br><span class="line">Rational <span class="keyword">operator</span>+(Rational &amp;secondRational);</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a+b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>a+b 函数返回一个Rational类的临时对象；而 &lt;&lt; 操作函数的参数却是 Rational &amp; rational 。这种情况函数会报错如下：</p>
<p><code>no match for 'operator&lt;&lt;' in 'std::cout &lt;&lt; a.Rational::operator+(((Rational&amp;)(&amp; b)))'</code></p>
<p>虽然定义了 operator&lt;&lt; 。但是编译器对 a+b 返回的临时对象不买单，直接报了个“没有匹配的函数” 的错误。</p>
<h3 id="分析">分析</h3>
<p>以C++的语义来说，如果一个程序员只想传递参数给函数，而不希望函数修改传入的参数时，那么，或者使用值传递，或者采用常量型引用。考虑到大对象复制时产生的开销，一般使用常量型引用const &amp;。如果函数的参数是某个类型的一个非常量的引用，那就相当于告诉编译器，程序员希望得到函数对参数的修改结果。<br>
临时变量是由编译器生成的，C++语言规范没规定编译器生成临时变量的规则，程序员无法得知由编译器生成的临时变量的名字，程序员无法访问那个临时变量。这意味着，以引用的方式传递一个临时变量做为函数参数，如果函数内部对此临时变量做了修改，那么函数返回后，程序员无法获得函数对临时变量的修改。函数对临时变量所做出的所有更改，都将丢失。</p>
<p>一方面，在函数申明中，使用非常量型的引用告诉编译器你需要得到函数对某个对象的修改结果，可是你自己又不给变量起名字，直接丢弃了函数的修改结果，编译器只能说：“大哥，你这是干啥呢，告诉我把结果给你，等我把结果给你了，你又直接给扔了，你这不是在玩我吗？”</p>
<p>同时，C++的标准 为了防止给常量或临时变量（只有瞬间的生命周期）赋值(易产生bug)，只许使用const引用之。</p>
<h3 id="解决">解决</h3>
<p>有两种解决办法，一是将非常量引用改为值传递，二是改为常量引用。</p>
<h3 id="临时对象">临时对象</h3>
<p>c++中的临时对象是看不见的，它不出现在源码中。建立一个未命名的非堆对象会产生一个临时对象，临时对象会在以下几种情况下出现。</p>
<h4 id="以值传递的方式给函数传参">以值传递的方式给函数传参</h4>
<p>按值传递时，首先将需要传给函数的参数，调用拷贝构造函数创建一个副本，这个副本就是临时变量，所有在函数里的操作都是针对这个副本，也正是因为这个原因，在函数体里对该副本进行任何操作都不会影响原参数。（关于临时对象的生命周期，并不是用过之后立马析构，其生命周期根据实际情况确定，比如这种情况，其生命周期可能存在于正割函数体内，又比如一个常量引用指向的临时对象，其声明周期由该常量引用的声明周期决定）</p>
<p>这也是<a href="http://zsh4614.cn/2021/04/13/%E8%AF%A6%E8%A7%A3C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/">拷贝构造函数不能为值传递</a>的原因，因为值传递会创建临时对象，而临时对象的创建仍然要调用拷贝构造函数，这样就会递归调用下去，造成栈溢出。</p>
<h4 id="隐式类型转换">隐式类型转换</h4>
<p>这种情况比较容易理解。</p>
<h4 id="函数返回对象">函数返回对象</h4>
<p>当函数需要返回一个对象，由于这个对象的生命周期只存在于函数体内部，所以它会在栈中创建一个临时对象（调用拷贝构造函数），存储函数的返回值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Assign operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">do</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p</span><br><span class="line">    p = <span class="built_in"><span class="keyword">do</span></span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况就会调用一次拷贝构造函数在栈上创建一个临时对象，然后调用赋值运算符将该临时对象复制给p。</p>
<h4 id="手动调用构造函数">手动调用构造函数</h4>
<p>**这里的手动调用指的是代码上显式调用而非编译器自己调用，**如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cls</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cls</span>() &#123;</span><br><span class="line">        <span class="built_in">cls</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cls c;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会打印出预期之外的结果，因为在调用cls(0)时，其实产生了一个cls类的临时对象，这个临时对象，而我们希望的是初始化对象c的成员a，但这里初始化的是临时对象的a。可以改成<code>*this = cls(0);</code>，这其实是和如下代码一个原理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line">cls a = <span class="built_in">cls</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>看起来调用了两次拷贝构造函数，临时对象一次，构造a一次，但实际上编译器做了如下优化，只调用了一次：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cls a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>临时对象</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++构造函数不能声明为虚函数</title>
    <url>/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>引言：构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时是必须声明为虚函数。</p>
<span id="more"></span>
<h3 id="1-背景">1.背景</h3>
<p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数，且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为<strong>动态联编</strong>。而函数的重载可以认为是多态，只不过是静态的。如果使用了<code>virtual</code>关键字，程序将根据引用或指针指向的对象类型来选择方法，否则使用引用类型或指针类型来选择方法。我们知道，在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。所以，基类的析构函数一定要定义成虚函数，那么构造函数为什么不能定义成虚函数呢？</p>
<h3 id="2-虚函数的底层实现机制">2.虚函数的底层实现机制</h3>
<p>要想搞清楚这个问题，首先要弄明白虚函数的底层是如何实现的。</p>
<p>编译器处理虚函数的方法是：首先为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。称为<strong>虚表指针（vptr）</strong>，这种数组称为<strong>虚函数表</strong>，即每个类使用一个虚函数表，每个类对象有一个虚表指针。</p>
<p>举个例子：基类对象包含一个虚表指针，指向基类所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表，看下面两种情况：</p>
<ul>
<li>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数地址，而不是基类的虚函数地址。</li>
<li>如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中的虚函数表将保存基类中未被重写的虚函数地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</li>
</ul>
<p>下面的图片体现了上述底层实现机制：</p>
<p><img src="https://i.loli.net/2021/04/18/luwBIOtfY3r1EWy.png" alt="虚函数的底层实现.jpg"></p>
<h3 id="3-原因">3.原因</h3>
<p>搞明白虚函数的底层实现机制之后，这个问题就迎刃而解了。虚函数的执行依赖于虚表指针查找虚函数表的操作，而对象的虚表指针在构造函数中进行初始化，让它指向正确的虚函数地址，而在构造对象期间，虚表指针还没有被初始化，所以将无法执行查表操作。</p>
<p>虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>虚函数</tag>
        <tag>底层实现</tag>
        <tag>虚函数表</tag>
        <tag>虚表指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之memset和fill函数</title>
    <url>/C-%E4%B9%8Bmemset%E5%92%8Cfill%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>引言：memset和fill都能进行赋值操作，但是二者有所区别，使用场景和方法也不同。</p>
<span id="more"></span>
<h3 id="1-问题引出">1.问题引出</h3>
<p>当我们运行下面一段代码试图将数组中的所有数字全部设置为1的时候，会发生预期之外的结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main &#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现输出以下的结果：</p>
<p><code>16843009 16843009 16843009 16843009 16843009</code></p>
<h3 id="2-原因">2.原因</h3>
<p>为什么和我们的预期不符？这是因为<code>memset()</code>函数是<strong>以字节为单位进行赋值</strong>的，一个int型数据有4个字节，在上面的例子中我们赋的值是十六进制<code>0x01010101</code>，即二进制数<code>00000001 00000001 00000001 00000001</code>，换算成十进制就是16843009，所以会得出上面的结果。</p>
<p>所以如果想将int型数组置为想要的十进制数，<strong>只能用<code>memset()</code>置为0或者-1</strong>，因为0的二进制表示全为0， -1的二进制表示全为1，按字节为单位完成赋值的结果保持不变。</p>
<p>一般情况下，<code>memset()</code>只用来给char型数组赋值，或者对int型数组进行全0或者全1操作。</p>
<h3 id="3-解决方法">3.解决方法</h3>
<p><code>fill()</code>函数<strong>按照单元进行赋值</strong>，将一个区间的元素都赋予同一个值。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    fill(a, a+5, 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以实现对数值中每个元素都赋值为1的目的，也可以对容器进行赋值，注意第一个参数和第二个参数是容器的迭代器。</p>
<h3 id="4-总结">4.总结</h3>
<p>1.<code>memset()</code>和<code>fill()</code>都可以实现赋值操作；<br>
2.<code>memset()</code>是以字节为单位进行，对int型数组赋值只能赋值为0或者-1，<code>fill()</code>以元素为单位进行。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>memset</tag>
        <tag>fill</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之STL无序关联式容器unordered_map</title>
    <url>/C-%E4%B9%8BSTL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8unordered-map/</url>
    <content><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。</p>
<span id="more"></span>
<h3 id="引言">引言</h3>
<p>关联式容器，常被称为“无序容器”、“哈希容器”或者“无序关联容器”。注意，无序容器是 C++ 11 标准才正式引入到 STL 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p>
<p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：</p>
<ul>
<li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li>
<li>无序容器的底层实现采用的是哈希表的存储结构。</li>
</ul>
<p>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p>
<ul>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li>
</ul>
<p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p>
<p><img src="https://s2.loli.net/2022/01/15/NcwjdSUL5kMvG1o.png" alt="image.png"></p>
<h3 id="创建">创建</h3>
<p>unordered_map 容器模板的定义如下所示：</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>STL</tag>
        <tag>哈希</tag>
        <tag>unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第一一五题：不同子序列</title>
    <url>/LeetCode%E7%AC%AC%E4%B8%80%E4%B8%80%E4%BA%94%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>引言：本文主要分析LeetCode第一一五题，利用C++实现；并进行了空间优化，另外还可以利用dfs进行时间优化。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<h3 id="示例">示例</h3>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<h3 id="分析">分析</h3>
<p>1.可以用动态规划的方法求解，<code>dp[i][j]</code>表示<code>s[0]</code>到<code>s[i]</code>之中有多少个<code>t[0]</code>到<code>t[j]</code>序列。</p>
<p>从最后一个字符看，假设s和t的长度分别是n和m，如果<code>s[n-1]</code>和<code>t[m-1]</code>不相等，那么显然只能在<code>s[0]</code>到<code>s[n-2]</code>中去找t；如果<code>s[n-1]</code>和<code>t[m-1]</code>相等，那么又分为两种情况，一是用<code>s[n-1]</code>，那么需要在<code>s[0]</code>到<code>s[n-2]</code>中去找<code>t[0]</code>到<code>t[m-2]</code>，另一种是不用<code>s[n-1]</code>，那么这就变成了和<code>s[n-1]</code>和<code>t[m-1]</code>不相等相同的情况，那么<code>s[n-1]</code>和<code>t[m-1]</code>相等时的方案数就是这两种情况之和。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if s[n-1] !&#x3D; t[m-1]:</span><br><span class="line">    dp[n-1][m-1] &#x3D; dp[n-2][m-1]</span><br><span class="line">else:</span><br><span class="line">    dp[n-1][m-1] &#x3D; dp[n-2][m-1] + dp[n-2][m-2]</span><br></pre></td></tr></table></figure>
<p>2.按照上述分析，是一个二维的动态规划，当s比较长时，那么所需要开辟的空间就会非常大，所以还需要进行空间上的优化。可以发现<code>dp[n-1][m-1]</code>只和<code>dp[n-2][m-1]</code>与<code>dp[n-2][m-2]</code>有关，即这个二维数组只和它左上方和上方的元素有关，这样就可以不开辟二维数组，只开辟一维数组，然后不断更新，需要注意的是，要进行倒序更新。</p>
<h3 id="实现">实现</h3>
<h4 id="c">c++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">size_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">size_t</span>&gt;(t.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = (s[<span class="number">0</span>] == t[<span class="number">0</span>]) ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = (s[i] == t[<span class="number">0</span>]) ? (dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>) : dp[i<span class="number">-1</span>][<span class="number">0</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>() - <span class="number">1</span>][t.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空间优化">空间优化</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = (s[<span class="number">0</span>] == t[<span class="number">0</span>]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = t.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">            dp[j] = (s[i] == t[j]) ? (dp[j] + dp[j<span class="number">-1</span>]) : dp[j];</span><br><span class="line">        &#125; </span><br><span class="line">        dp[<span class="number">0</span>] = (s[i] == t[<span class="number">0</span>]) ? (dp[<span class="number">0</span>] + <span class="number">1</span>) : dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[t.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展">拓展</h3>
<p>这道题属于困难，优化的方法比较多，还有时间优化的余地，之后可以用dfs进行时间优化。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>算法优化</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>C++动态多态</title>
    <url>/C-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>引言：本文主要介绍c++动态多态（polymorphism），其核心机制为虚函数。</p>
<span id="more"></span>
<h4 id="初步印象">初步印象</h4>
<p>多态（polymorphism）是面向对象编程语言的一大特点，而虚函数是实现多态的机制。其核心理念就是通过基类访问派生类定义的函数。多态性使得程序调用的函数是在<strong>运行时动态确定</strong>的，而不是在编译时静态确定的。使用一个基类类型的指针或者引用，来指向子类对象，进而调用由子类复写的个性化的虚函数，这是C++实现多态性的一个最经典的场景。</p>
<ul>
<li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func()</li>
<li>纯虚函数，在虚函数后加“=0”，如 virtual void func()=0</li>
<li>对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。</li>
<li>对于纯虚函数，子类必须提供纯虚函数的个性化实现。</li>
</ul>
<p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了“多态”特性。但区别是：</p>
<ul>
<li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；</li>
<li>**子类如果不提供纯虚函数的实现，编译将会失败。**尽管在基类中可以给出纯虚函数的实现，但无法通过指向子类对象的基类类型指针来调用该纯虚函数，也即不能作为子类相应纯虚函数的备选方案。（纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路。）</li>
</ul>
<h4 id="虚函数">虚函数</h4>
<p>placehoder[此处插入代码]</p>
<p>在上述例子中，我们首先定义了一个基类base，基类有一个名为vir_func的虚函数，和一个名为func的普通成员函数。类A，B都是由类base派生的子类。然后我们定义三个base*类型的指针Base、a、b分别指向类base、A、B。可以看到，当使用这三个指针调用func函数时，调用的都是基类base的函数。而使用这三个指针调用虚函数vir_func时，调用的是指针指向的实际类型的函数。最后，我们将指针b做强制类型转换，转换为A*类型，然后分别调用func和vir_func函数，发现普通函数调用的是类A的函数，而虚函数调用的是类B的函数。以上，我们可以得出结论**“当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定”**。</p>
<p>对于一个只包含非静态成员变量和普通成员函数的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  void fun_a();</span><br><span class="line">  void fun_b();</span><br><span class="line">  int var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中成员函数放在代码区，为该类的所有对象公有，即不管新建多少个该类的对象，所对应的都是同一个函数存储区的函数。而成员变量则为各个对象所私有，即每新建一个对象都会新建一块内存区用来存储var值。在调用成员函数时，程序会根据类的类型，找到对应代码区所对应的函数并进行调用。</p>
<p>在上面例子中，Base、a、b都是base类型的指针。调用普通函数时，程序根据指针的类型到类base所对应的代码区找到所对应的函数，所以都调用了类base的func函数，即指针的类型决定了普通函数的调用。</p>
<p>那么包含虚函数的类又是怎样的呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class D&#123;</span><br><span class="line">  void func_a();</span><br><span class="line">  virtual void func_b();</span><br><span class="line">  int var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时如果sizeof一个类D的对象，会发现比类C的对象大4个字节。多出来的这4个字节就是实现虚函数的关键----<strong>虚函数表指针vptr</strong>。这个指针指向一张名为“虚函数表”（vtbl）的表，而表中的数据则为函数指针，存储了虚函数fun_b()具体实现所对应的位置。注意，**普通函数、虚函数、虚函数表都是同一个类的所有对象公有的，只有成员变量和虚函数表指针是每个对象私有的，sizeof的值也只包括vptr和var所占内存的大小，并且vptr通常会在对象内存的最起始位置。另外，当类有多个虚函数时，仍然只有一个虚函数表指针vptr（指向一个虚函数表），而此时的虚函数表vtbl中会有多个函数指针，分别指向对应的虚函数实现区域。**因此，<strong>虚函数实现的过程是：通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。所以虚函数的调用时由指针所指向内存块的具体类型决定的。</strong></p>
<h4 id="纯虚函数">纯虚函数</h4>
<p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。</p>
<p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p>
<p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<p>含有纯虚函数的类称之为抽象类，**它不能生成对象（创建实例），只能创建它的派生类的实例。**抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</p>
<p><strong>抽象类只能作为基类来使用</strong>，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<h4 id="选用时机">选用时机</h4>
<p>当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。<br>
当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数</p>
<h4 id="构造函数和析构函数">构造函数和析构函数</h4>
<p>构造函数和析构函数可以是虚函数吗？</p>
<p>答案是：<strong>构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</strong></p>
<p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p>
<p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p>
<blockquote>
<p>转载于：<a href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>虚函数</tag>
        <tag>动态多态</tag>
        <tag>纯虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo在多台电脑上维护github个人主页</title>
    <url>/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%BB%B4%E6%8A%A4github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</url>
    <content><![CDATA[<p>引言：本文主要介绍如何在两台（多台）电脑上维护自己的github pages博客。</p>
<span id="more"></span>
<h3 id="介绍">介绍</h3>
<p>总体方法是利用git分支实现。hexo生成的静态博客文件默认放在master分支上，可以新建一个分支用来存放源文件，在其他电脑上只需要git clone这个分支即可进行更新和发布等操作。</p>
<h3 id="环境">环境</h3>
<p>在操作之前，先在新电脑上安装好hexo需要的环境：</p>
<p><strong>安装npm和node.js:</strong></p>
<p>到<a href="https://nodejs.org/dist/latest/">官网</a>下载最新的压缩包，解压后在bin目录下有npm和node的可执行文件，但是安装路径没有在系统环境变量中，所以添加到系统环境中，有多种方法，这里我进行了软链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure>
<p><strong>安装hexo：</strong></p>
<p>直接使用npm安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>同样需要加到系统环境中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure>
<h3 id="步骤">步骤</h3>
<p>1.给github博客仓库新建一个hexo分支，设置为默认分支。</p>
<p>2.将当前电脑的ssh key添加到github上。</p>
<p>3.执行git clone命令将hexo克隆到本地，将除了.git的文件全部删除，然后add-commit-push更新到远程。</p>
<p>4.将原来博客根目录下（即包含themes、source等文件夹的那个目录）所有文件拷贝到本地hexo分支文件夹。</p>
<p>5.删除themes文件夹每个主题的.git文件夹和.gitignore文件。</p>
<p>6.执行add-commit-push更新到远程。</p>
<p>7.之后在任何配置好博客环境的电脑上都采用如下操作维护博客：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pull-add-commit-push</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>个人主页</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之STL关联式容器map</title>
    <url>/C-%E4%B9%8BSTL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8map/</url>
    <content><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。</p>
<span id="more"></span>
<h3 id="pair">pair</h3>
<p>关联式容器存储的是“键值对”形式的数据，考虑到“键值对”并不是普通类型数据，C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素&lt;first, second&gt;。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</p>
<p>注意，pair 类模板定义在<utility>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>) 默认构造函数，即创建空的 pair 对象</span><br><span class="line"><span class="built_in">pair</span>();</span><br><span class="line">#<span class="number">2</span>) 直接使用 <span class="number">2</span> 个元素初始化成 pair 对象</span><br><span class="line"><span class="built_in">pair</span> (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line">#<span class="number">3</span>) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span><br><span class="line">template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</span><br></pre></td></tr></table></figure>
<p>在 C++ 11 标准中，在引入右值引用的基础上，pair 类模板中又增添了如下 2 个构造函数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#<span class="number">4</span>) 移动构造函数</span><br><span class="line">template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</span><br><span class="line">#<span class="number">5</span>) 使用右值引用参数，创建 pair 对象</span><br><span class="line">template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</span><br></pre></td></tr></table></figure>
<p>下面程序演示了以上几种创建 pair 对象的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;string, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair2</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair3</span>(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair4</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair5</span>(<span class="built_in">string</span>(<span class="string">&quot;Python教程&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序在创建 pair4 对象时，调用了 make_pair() 函数，它也是 <utility> 头文件提供的，其功能是生成一个 pair 对象。因此，当我们将 make_pair() 函数的返回值（<strong>是一个临时对象</strong>）作为参数传递给 pair() 构造函数时，<strong>其调用的是移动构造函数，而不是拷贝构造函数。</strong></p>
<p>在上面程序的基础上，C++ 11 还允许我们手动为 pair1 对象赋值，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pair1.first &#x3D; &quot;Java教程&quot;;</span><br><span class="line">pair1.second &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;;</span><br><span class="line">cout &lt;&lt; &quot;new pair1: &quot; &lt;&lt; pair1.first &lt;&lt; &quot; &quot; &lt;&lt; pair1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>同时，上面程序中 pair4 对象的创建过程，还可以写入如下形式，它们是完全等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pair &lt;string, string&gt; pair4 &#x3D; make_pair(&quot;C++教程&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;);</span><br><span class="line">cout &lt;&lt; &quot;pair4: &quot; &lt;&lt; pair4.first &lt;&lt; &quot; &quot; &lt;&lt; pair4.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><utility>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;=、&gt;、&gt;=、==、!= 这 6 的运算符，其运算规则是：<strong>对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。</strong></p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair1</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair2</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair3</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pair != pair2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pair2 != pair3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pair !&#x3D; pair2</span><br><span class="line">pair2 !&#x3D; pair3</span><br></pre></td></tr></table></figure>
<p>最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，<strong>其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair1</span>(<span class="string">&quot;pair&quot;</span>, <span class="number">10</span>);                   </span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair2</span>(<span class="string">&quot;pair2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.<span class="built_in">swap</span>(pair2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建map容器">创建map容器</h3>
<p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、使用结构体或类自定义的类型。</p>
<p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用std::less<T>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如std::greater<T>），也可以自定义排序规则。</p>
<p>另外需要注意的是，使用 map 容器存储的各个键值对，**键的值既不能重复也不能被修改。<strong>换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着</strong>只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。**前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 <strong>pair&lt;const K, T&gt;</strong> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p>
<p>map 容器的模板定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">T</span>,                                       // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,                     <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;pair&lt;<span class="keyword">const</span> Key,T&gt; &gt;    <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p>
<p>map 容器的模板类中包含多种构造函数，因此创建 map 容器的方式也有多种，下面就几种常用的创建 map 容器的方法，做一一讲解。</p>
<ol>
<li>通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此<strong>创建空 map 容器是比较常用的。</strong></p>
<ol start="2">
<li>当然在创建 map 容器的同时，也可以进行初始化，比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>由此，myMap 容器在初始状态下，就包含有 2 个键值对。</p>
<p>再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>),std::<span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>)&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>除此之外，在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(myMap);</span><br></pre></td></tr></table></figure>
<p>由此，通过调用 map 容器的<strong>拷贝（复制）构造函数</strong>，即可成功创建一个和 myMap 完全一样的 newMap 容器。</p>
<p>C++ 11 标准中，还为 map 容器增添了移动构造函数。<strong>当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数</strong>。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#创建一个会返回临时 map 对象的函数</span><br><span class="line">std::map&lt;std::string,int&gt; disMap() &#123;</span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt;tempMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(<span class="built_in">disMap</span>());</span><br></pre></td></tr></table></figure>
<p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
<ol start="4">
<li><strong>map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。例如：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(++myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>这里，通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {“STL教程”,20} 键值对的容器。</p>
<ol start="5">
<li>当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。<strong>默认情况下，map 容器调用 std::less<T> 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。</strong></li>
</ol>
<p>因此，如下 2 行创建 map 容器的方式，其实是等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>, std::less&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>, std::greater&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员方法">成员方法</h3>
<p>下表列出了 map 容器提供的常用成员方法以及各自的功能。<br>
<img src="https://s2.loli.net/2022/01/11/TzhsVNtg2ewymAX.png" alt="image.png"></p>
<p>C++ STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较。</p>
<p>下面程序以 begin()/end() 组合为例，演示了如何遍历 map 容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;      &#x2F;&#x2F; pair</span><br><span class="line">#include &lt;string&gt;       &#x2F;&#x2F; string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建并初始化 map 容器</span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;&#125;,&#123;&quot;C语言教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;&#125; &#125;;</span><br><span class="line">    &#x2F;&#x2F;调用 begin()&#x2F;end() 组合，遍历 map 容器</span><br><span class="line">    for (auto iter &#x3D; myMap.begin(); iter !&#x3D; myMap.end(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向<strong>迭代器</strong>；反之，其功能和 end() 方法相同。<strong>因为返回的是迭代器，因此最常用的是判断容器中有没有这个键值对：if (iter != map.end()){}</strong></p>
<p>同时，map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p>
<ul>
<li>lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；</li>
<li>upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；</li>
</ul>
<p>下面程序演示了它们的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//找到第一个键的值不小于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</p>
<p>equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p>
<p>显然，equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>  <span class="comment">//pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;std::map&lt;string, string&gt;::iterator, std::map&lt;string, string&gt;::iterator&gt; myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    <span class="comment">//通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，<strong>其返回的范围内最多也只有 1 个键值对。</strong></p>
<h3 id="获取键对应值">获取键对应值</h3>
<p>我们知道，map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p>
<p>注意，<strong>使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</strong></p>
<p>庆幸的是，map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。</p>
<ol>
<li>map 类模板中对[ ]运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    string cValue = myMap[<span class="string">&quot;C语言教程&quot;</span>];</span><br><span class="line">    cout &lt;&lt; cValue &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在第 11 行代码中，通过指定键的值为 “C语言教程”，借助重载的 [ ] 运算符，就可以在 myMap 容器中直接找到该键对应的值。</p>
<p><strong>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。</strong></p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap;</span><br><span class="line">    <span class="keyword">int</span> cValue = myMap[<span class="string">&quot;C语言教程&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，对于空的 myMap 容器来说，其内部没有以 “C语言教程” 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个&lt;“C语言教程”,0&gt;键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）</p>
<p>实际上，[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap;</span><br><span class="line">    myMap[<span class="string">&quot;STL教程&quot;</span>]=<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Python教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;STL教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，程序中第 9 行代码已经为 map 容器添加了一个以 “STL教程” 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。</strong></p>
<ol start="2">
<li>除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不<strong>同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。</strong></li>
</ol>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;      &#x2F;&#x2F; map</span><br><span class="line">#include &lt;string&gt;   &#x2F;&#x2F; string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建并初始化 map 容器</span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;&#125;,</span><br><span class="line">                                             &#123;&quot;C语言教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;&#125;,</span><br><span class="line">                                             &#123;&quot;Java教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;&#125; &#125;;</span><br><span class="line">    cout &lt;&lt; myMap.at(&quot;C语言教程&quot;) &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;下面一行代码会引发 out_of_range 异常</span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; myMap.at(&quot;Python教程&quot;) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序第 12 行代码处，通过 myMap 容器调用  at() 成员方法，可以成功找到键为 “C语言教程” 的键值对，并返回该键对应的值；而第 14 行代码，由于当前 myMap 容器中没有以 “Python教程” 为键的键值对，会导致 at() 成员方法查找失败，并抛出 out_of_range 异常。</p>
<p>除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    map&lt; std::string, std::string &gt;::iterator myIter = myMap.<span class="built_in">find</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; myIter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; myIter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，此程序中如果 find() 查找失败，会导致第 13 行代码运行出错。因为当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。</p>
<p>如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。</p>
<p>本节所介绍的几种方法中，仅从“在 map 容器存储的键值对中，获取指定键对应的值”的角度出发，<strong>更推荐使用 at() 成员方法，因为该方法既简单又安全。</strong></p>
<h3 id="insert-方法">insert()方法</h3>
<p>map 类模板中提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p>
<p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，<strong>如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</strong></p>
<p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p>
<ol>
<li>无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、引用传递一个键值对</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">//2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line">    pair&lt;iterator,bool&gt; insert (P&amp;&amp; val);</span><br></pre></td></tr></table></figure>
<p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li>
<li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li>
</ul>
<p>以上 2 种语法格式的区别在于传递参数的方式不同，即无论是局部定义的键值对变量还是全局定义的键值对变量，都采用普通引用传递的方式；而对于临时的键值对变量，则以右值引用的方式传参。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    std::pair&lt;std::map&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(STL);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret.iter &#x3D; &lt;&#123;STL教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&#125;, 1&gt;</span><br><span class="line">ret.iter &#x3D; &lt;&#123;C语言教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&#125;, 1&gt;</span><br><span class="line">ret.iter &#x3D; &lt;&#123;STL教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&#125;, 0&gt;</span><br></pre></td></tr></table></figure>
<p>从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：</p>
<ul>
<li>对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量</li>
<li>对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 “STL教程” 的键值对和值为 0 的 bool 变量。</li>
</ul>
<p>另外，在程序中的第 21 行代码，<strong>还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用 pair 类模板的构造函数</span></span><br><span class="line">ret = mymap.<span class="built_in">insert</span>(pair&lt;string,string&gt;&#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;);</span><br><span class="line"><span class="comment">//调用 make_pair() 函数</span></span><br><span class="line">ret = mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p>
<ul>
<li>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</li>
<li>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.<span class="built_in">insert</span>(it, STL);</span><br><span class="line">    cout &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.<span class="built_in">insert</span>(it, std::pair&lt;string, string&gt;(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.<span class="built_in">insert</span>(it, std::pair&lt;string, string&gt;(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</strong></p>
<ol start="3">
<li>insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 first 和 last 都是迭代器，它们的组合&lt;first,last&gt;可以表示某 map 容器中的指定区域。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    std::map&lt;string, string&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.<span class="built_in">insert</span>(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，vali 都表示的是键值对变量。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加 3 个键值对</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                   &#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;,</span><br><span class="line">                   &#123; <span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，除了 insert() 方法，<strong>map 类模板还提供 emplace() 和 emplace_hint() 方法，它们也可以完成向 map 容器中插入键值对的操作，且效率还会比insert() 方法高</strong>。关于这 2 个方法，会在下一节做详细介绍。</p>
<h3 id="operator-和insert-效率对比">operator[]和insert()效率对比</h3>
<p>map 容器模板类中提供有 operator[ ] 和 insert() 这 2 个成员方法，而值得一提的是，这 2 个方法具有相同的功能，它们既可以实现向 map 容器中添加新的键值对元素，也可以实现更新（修改）map 容器已存储键值对的值。</p>
<p>显然，map 模板类中 operator[ ] 和 insert() 的功能发生了重叠，这就产生了一个问题，谁的执行效率更高呢？</p>
<p><strong>结论：当实现“向 map 容器中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。</strong></p>
<p>首先解释一下，为什么实现向 map 容器中添加新键值对元素，insert() 方法的执行效率比 operator[ ] 更高？回顾程序一中，如下语句完成了向空 mymap 容器添加新的键值对元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mymap[<span class="string">&quot;STL教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>此行代码中，mymap[“STL教程”] 实际上是 mymap.operator<a href="%E2%80%9CSTL%E6%95%99%E7%A8%8B%E2%80%9D"> </a> 的缩写（底层调用的 operator[ ] 方法），该方法会返回一个指向 “STL教程” 对应的 value 值的引用。</p>
<p>但需要注意的是，由于此时 mymap 容器是空的，并没有 “STL教程” 对应的 value 值。这种情况下，operator[ ] 方法会默认构造一个 string 对象，并将其作为 “STL教程” 对应的 value 值，然后返回一个指向此 string 对象的引用。在此基础上，代码还会将 “<a href="http://c.biancheng.net.java/">http://c.biancheng.net.java/</a>” 赋值给这个 string 对象。</p>
<p>也就是说，上面这行代码的执行流程，可以等效为如下程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;string, string&gt; mstr;</span><br><span class="line"><span class="comment">//创建要添加的默认键值对元素</span></span><br><span class="line">pair&lt;mstr::iterator, <span class="keyword">bool</span>&gt;res = mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="built_in">string</span>()));</span><br><span class="line"><span class="comment">//将新键值对的值赋值为指定的值</span></span><br><span class="line">res.first-&gt;second = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用 operator[ ] 添加新键值对元素的流程是，先构造一个有默认值的键值对，然后再为其 value 赋值。</p>
<p>那么，为什么不直接构造一个要添加的键值对元素呢，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>此行代码和上面程序的执行效果完全相同，但它省略了创建临时 string 对象的过程以及析构该对象的过程，同时还省略了调用 string 类重载的赋值运算符。由于可见，同样是完成向 map 容器添加新键值对，insert() 方法比 operator[ ] 的执行效率更高</p>
<p>仍以程序一中的代码为例，如下分别是 operator[ ] 和 insert() 实现更新 mymap 容器中指定键对应的值的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;operator[]</span><br><span class="line">mymap[&quot;STL教程&quot;] &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;;</span><br><span class="line">&#x2F;&#x2F;insert()</span><br><span class="line">std::pair&lt;string, string&gt; STL &#x3D; &#123; &quot;Java教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot; &#125;;</span><br><span class="line">mymap.insert(STL).first-&gt;second &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;;</span><br></pre></td></tr></table></figure>
<p>仅仅从语法形式本身来考虑，或许已经促使很多读者选择 operator[ ] 了。接下来，我们再从执行效率的角度对比以上 2 种实现方式。</p>
<p>从上面代码可以看到，insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构）。</p>
<p>而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。</p>
<h3 id="emplace-和emplace-hint-方法">emplace()和emplace_hint()方法</h3>
<p>和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>
<p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：<br>
当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；<br>
当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</p>
<p>下面程序演示 emplace() 方法的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//插入键值对</span></span><br><span class="line">    pair&lt;map&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入新键值对</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//失败插入的样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p>
<p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p>
<ul>
<li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li>
<li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li>
</ul>
<p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p>
<h3 id="插入效率">插入效率</h3>
<p>上一节在学习 C++STL map 容器的 emplace() 和 emplace_hint() 的基本用法时，还遗留了一个问题，即为什么 emplace() 和 emplace_hint() 的执行效率会比 insert() 高？</p>
<p>原因很简单，它们向 map 容器插入键值对时，底层的实现方式不同：</p>
<ul>
<li>使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；</li>
<li>使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。</li>
</ul>
<p>也就是说，向 map 容器中插入键值对时，emplace() 和 emplace_hint() 方法都省略了移动键值对的过程，因此执行效率更高。下面程序提供了有利的证明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, testDemo&gt;mymap;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="built_in">testDemo</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace</span>( <span class="string">&quot;http://c.biancheng.net/stl/:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_hint():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert():</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace():</span><br><span class="line">调用构造函数</span><br><span class="line">emplace_hint():</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure>
<p>分析一下这个程序。首先，我们创建了一个存储 &lt;string,tempDemo&gt; 类型键值对的空 map 容器，接下来分别用 insert()、emplace() 和 emplace_hint() 方法向该 map 容器中插入相同的键值对。</p>
<p>从输出结果可以看出，在使用 insert() 方法向 map 容器插入键值对时，整个插入过程调用了 1 次 tempDemo 类的构造函数，同时还调用了 2 次移动构造函数。实际上，程序第 28 行代码底层的执行过程，可以分解为以下 3 步：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造类对象</span></span><br><span class="line">testDemo val = <span class="built_in">testDemo</span>(<span class="number">1</span>); <span class="comment">//调用 1 次构造函数</span></span><br><span class="line"><span class="comment">//构造键值对</span></span><br><span class="line"><span class="keyword">auto</span> pai = <span class="built_in">make_pair</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, val); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"><span class="comment">//完成插入操作</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(pai); <span class="comment">//调用 1 次移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>而完成同样的插入操作，emplace() 和 emplace_hint() 方法都只调用了 1 次构造函数，这足以证明，这 2 个方法是在 map 容器内部直接构造的键值对。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第一九八题：打家劫舍</title>
    <url>/LeetCode%E7%AC%AC%E4%B8%80%E4%B9%9D%E5%85%AB%E9%A2%98%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p>引言：本文主要分析LeetCode第一九八题，属于典型动态规划，最后C++实现。</p>
<span id="more"></span>
<h4 id="题目">题目</h4>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<h4 id="示例">示例</h4>
<h5 id="示例1">示例1</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<h5 id="示例2">示例2</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>
<h5 id="提示">提示</h5>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<h4 id="分析">分析</h4>
<p>对于第i辆车，可以选择偷和不偷，最后求偷的情况下和不偷的情况下哪种情况偷的总数更多就可以了。偷的情况<code>dp[i]=dp[i-2]+p[i]</code>，不偷的情况<code>dp[i]=dp[i-1]</code>。</p>
<h4 id="实现">实现</h4>
<p>C++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> prepre = <span class="number">0</span>, pre = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        now = <span class="built_in">max</span>(pre, prepre+nums[i]);</span><br><span class="line">        prepre = pre;</span><br><span class="line">        pre = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结">总结</h4>
<p>这道题很典型的dp问题，而且思路比较简单，我刚开始复杂了，但是也没太复杂：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">y</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">n</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        y[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        n[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            y[i] = n[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">            n[i] = <span class="built_in">max</span>(y[i - <span class="number">1</span>], n[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(y[nums.<span class="built_in">size</span>() - <span class="number">1</span>], n[nums.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = &#123;nums[<span class="number">0</span>], <span class="number">0</span>, nums[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>] + nums[i];</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第一百六十题：相交链表</title>
    <url>/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%85%AD%E5%8D%81%E9%A2%98%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>引言：本文主要介绍LeetCode第一百六十题，判断两个链表是否相交，并找出相交的结点。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://s2.loli.net/2022/01/17/xf6UjXkD2TeWI3F.png" alt="image.png"></p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<h3 id="示例">示例</h3>
<p><strong>示例1</strong></p>
<p><img src="https://s2.loli.net/2022/01/17/deKrCEjBOtQgmWI.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<p><img src="https://s2.loli.net/2022/01/17/pec9sSCqiohBu5r.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例3</strong></p>
<p><img src="https://s2.loli.net/2022/01/17/hEXnDypY7I56LfO.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>listA 中节点数目为 m</li>
<li>listB 中节点数目为 n</li>
<li>1 &lt;= m, n &lt;= 3 * 104</li>
<li>1 &lt;= Node.val &lt;= 105</li>
<li>0 &lt;= skipA &lt;= m</li>
<li>0 &lt;= skipB &lt;= n</li>
<li>如果 listA 和 listB 没有交点，intersectVal 为 0</li>
<li>如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</li>
</ul>
<h3 id="分析">分析</h3>
<p>如果只是判断两个链表是否相交，那么就很简单了，只需要判断最后一个结点是否是同一个结点。但是本题要返回相交的那个结点，一个最直接的思路是使用哈希表，先将一个链表的每个结点地址存储起来，然后在遍历第二个链表的时候去查表，这样时间复杂度是O(m+n)，空间复杂度为O(m)。另一种常用的思路是用双指针，同时遍历两个链表，当遍历到尾结点的时候，指向另一个链表的头结点，这样如果有相交的话，那么一定会指到同一个结点上；如果不相交的话，那么最后他们一定同时指向nullptr。</p>
<h3 id="实现">实现</h3>
<p><strong>方法一：哈希</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; hashset;</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        hashset.<span class="built_in">emplace</span>(headA);</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.<span class="built_in">find</span>(headB) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：双指针</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">    ListNode* workA &#x3D; headA;</span><br><span class="line">    ListNode* workB &#x3D; headB;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        </span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            return workB;</span><br><span class="line">        &#125;</span><br><span class="line">        workA &#x3D; workA-&gt;next;</span><br><span class="line">        workB &#x3D; workB-&gt;next;</span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workA &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workA &#x3D; headB;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workB &#x3D; headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的思路，看一下大神写的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA &#x3D;&#x3D; nullptr || headB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA &#x3D; headA, *pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>NB!!!</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第一题：两数之和</title>
    <url>/LeetCode%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>引言：本文主要分析LeetCode第一题，Python和C++实现；并对哈希做了简单说明。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>
你可以按任意顺序返回答案。</p>
<h3 id="示例">示例</h3>
<p>输入：nums = [2,7,11,15], target = 9<br>
输出：[0,1]<br>
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
<h3 id="分析">分析</h3>
<p>1.注意题目输出下标，同时注意条件约束：返回结果不能是同一个元素的下标，但是可以使两个相等的元素的下标。</p>
<p>2.最直观的想法是两层循环嵌套，时间复杂度O(n<sup>2</sup>)</p>
<p>3.耗时主要在查找上，由于哈希查找的时间复杂度为O(1)，所以采用哈希</p>
<h3 id="实现">实现</h3>
<h4 id="Python">Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> target - num <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">return</span> [i, hashmap.get(target - num)]</span><br><span class="line">        hashmap[num] = i</span><br><span class="line">        <span class="comment"># 注意，hashmap[num] = i一定要写在if之后，否则不能返回两个元素相等的情况</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小技巧：访问字典最好使用dict.get(key)而不是使用dict[key]，因为当key不存在时前者会返回None，而后者会抛出异常。</li>
</ul>
<h4 id="C">C++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;	<span class="comment">// 初始化存放结果的容器为&#123;-1， -1&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">count</span>(target - nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = i;</span><br><span class="line">            result[<span class="number">1</span>] = hashmap[target - nums[i]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashmap[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展">拓展</h3>
<h4 id="什么是哈希表？">什么是哈希表？</h4>
<p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>记录的存储位置=f(关键字)</p>
<p>这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。</p>
<p>哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）<br>
而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>
<h4 id="Hash的应用">Hash的应用</h4>
<p>1、Hash主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<p>2、查找：哈希表，又称为散列，是一种更加快捷的查找技术。我们之前的查找，都是这样一种思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，继续查找。而哈希表是完全另外一种思路：当我知道key值以后，我就可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找！</p>
<p>举一个例子，假如我的数组A中，第i个元素里面装的key就是i，那么数字3肯定是在第3个位置，数字10肯定是在第10个位置。哈希表就是利用利用这种基本的思想，建立一个从key到位置的函数，然后进行直接计算查找。</p>
<p>3、Hash表在海量数据处理中有着广泛应用。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第三题：无重复字符的最长子串</title>
    <url>/LeetCode%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>引言：本文主要分析LeetCode第三题，Python和C++实现；并进行了哈希优化和数组桶优化。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是子串的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>0 &lt;= s.length &lt;= 5 * 104</li>
<li>s由英文字母、数字、符号和空格组成</li>
</ul>
<h3 id="分析">分析</h3>
<p>1.设置两个游标，采用滑动窗口，右游标一直右滑，每滑动一位，从左游标开始遍历查找与右游标相等的值，如果找到，左游标移到相等位置的下一位，更新长度</p>
<h3 id="实现">实现</h3>
<h4 id="python">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        length = result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(start,end):</span><br><span class="line">                <span class="keyword">if</span> s[index] == s[end]:</span><br><span class="line">                    length = end - index- <span class="number">1</span></span><br><span class="line">                    start = index + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            result = <span class="built_in">max</span>(length, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="c">c++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start; j &lt; end; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == s[end]) &#123;</span><br><span class="line">                start = j + <span class="number">1</span>;</span><br><span class="line">                length = end - start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = <span class="built_in">max</span>(result, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<strong>哈希</strong>对查找相等元素进行优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">find</span>(s[end]) != hashmap.<span class="built_in">end</span>() &amp;&amp; hashmap[s[end]] &gt;= start) &#123;</span><br><span class="line">            start = hashmap[s[end]] + <span class="number">1</span>;</span><br><span class="line">            length = end - start;</span><br><span class="line">        &#125;</span><br><span class="line">        hashmap[s[end]] = end;</span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = <span class="built_in">max</span>(result, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展">拓展</h3>
<ul>
<li>
<p>map操作，find与count的区别</p>
</li>
<li>
<p>map与unordered_map的区别，到底哪个快？</p>
</li>
<li>
<p>利用数组进行桶优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    <span class="keyword">int</span> sSize = <span class="built_in"><span class="keyword">int</span></span>(s.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; sSize) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpChar = s[end];</span><br><span class="line">        <span class="keyword">if</span> (vec[<span class="built_in"><span class="keyword">int</span></span>(tmpChar)] &gt;= start)</span><br><span class="line">        &#123;</span><br><span class="line">            start = vec[<span class="built_in"><span class="keyword">int</span></span>(tmpChar)] + <span class="number">1</span>;</span><br><span class="line">            length = end - start;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[<span class="built_in"><span class="keyword">int</span></span>(tmpChar)] = end;</span><br><span class="line">        </span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = <span class="built_in">max</span>(result, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>桶优化</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第一百四十二题：环形链表二</title>
    <url>/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/</url>
    <content><![CDATA[<p>引言：本文主要分析LeetCode第一百四十二题，判断一个链表是否有环，有环的话找到入环的结点，用佛洛依德判圈算法实现。</p>
<span id="more"></span>
<h3 id="题目：">题目：</h3>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改链表。</p>
<h3 id="示例">示例</h3>
<p><strong>示例一</strong></p>
<p><img src="https://s2.loli.net/2022/01/16/p4XMYle9k8yqxwm.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例二</strong></p>
<p><img src="https://s2.loli.net/2022/01/16/v8whclNoCksYBQT.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例三</strong></p>
<p><img src="https://s2.loli.net/2022/01/16/2PmvFTZqnyrhkap.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 [0, 10^4] 内</li>
<li>-10^5 &lt;= Node.val &lt;= 10^5</li>
<li>pos 的值为 -1 或者链表中的一个有效索引</li>
</ul>
<h3 id="分析">分析</h3>
<p>本题可使用佛洛依德判圈算法求解。</p>
<h3 id="实现">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* slow = dummy1;</span><br><span class="line">    ListNode* dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* fast = dummy2;</span><br><span class="line">    slow-&gt;next = head;</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow-&gt;next) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里虚拟了一个dummy结点，这样可以将头结点当作一般结点看待，否则可能需要判断头结点为空的情况，这样做就不用单独判断了。另外<strong>新开辟的无用内存，在返回前一定要释放，否则会内存泄漏</strong>，这里的slow和fast相当于工作结点。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>判圈算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第二十一题：合并两个有序链表</title>
    <url>/LeetCode%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>引言：本文主要分析LeetCode第二十一题，合并两个有序链表，用迭代和递归两种方法实现。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h3 id="示例">示例</h3>
<p><img src="https://s2.loli.net/2022/01/09/L8AQHIcVbtk1ZUe.png" alt="image.png"></p>
<p>示例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>0 &lt;= s.length &lt;= 5 * 104</li>
<li>s由英文字母、数字、符号和空格组成</li>
</ul>
<h3 id="分析">分析</h3>
<p>该题目常规思路就是迭代两个链表的结点，比较大小，小的往后面移动一个结点，然后再比较大小，如此迭代下去，直到一个链表指针域为空，然后把另一个链表接上即可；另一种思路是递归，这种方法比较巧妙</p>
<p><img src="https://s2.loli.net/2022/01/09/BrE9Dsg1YaKXQvc.png" alt="image.png"></p>
<p>但是需要考虑其中一个为空的情况，作为迭代的出口。</p>
<h3 id="实现">实现</h3>
<h4 id="方法一-迭代">方法一(迭代)</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode *work = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *dummy = work;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* &amp;tmp = list1-&gt;val &lt; list2-&gt;val ? list1 : list2;</span><br><span class="line">        work-&gt;next = tmp;</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    work-&gt;next = (list1 == <span class="literal">nullptr</span>) ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二-递归">方法二(递归)</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">        list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结">总结</h4>
<p>链表中常用到dummy结点，用来解决头结点问题，这样可以使得头结点和一般结点没有什么区别，注意灵活应用。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第二百零六题：反转链表</title>
    <url>/LeetCode%E7%AC%AC%E4%BA%8C%E7%99%BE%E9%9B%B6%E5%85%AD%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>引言：本文主要介绍LeetCode第二百零六题，将一个链表进行反转。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>
<strong>示例1</strong></p>
<p><img src="https://s2.loli.net/2022/01/20/h8WBedLgsJ6qRYw.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<p><img src="https://s2.loli.net/2022/01/20/8IV4ybzfQXGHJxi.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong></p>
<ul>
<li>链表中节点的数目范围是 [0, 5000]</li>
<li>-5000 &lt;= Node.val &lt;= 5000</li>
</ul>
<h3 id="分析">分析</h3>
<p><strong>要深刻理解链表的结构，每个结点在存储上并不连续，他们之间的关系就是指针的指向，所以反转一个链表就是将每个结点的指针域由指向后一个结点变成指向前一个结点即可</strong>；另一种思路是递归，这种思路比较好想到，但是实现起来需要一定的功底；工程中应尽量避免递归，基本上所有的递归都能改成用stack和dfs实现，这个也不例外，而且stack是先进后出，很适合这种反转操作。</p>
<h3 id="实现">实现</h3>
<p><strong>迭代</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head; </span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p><strong>递归</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* end = head-&gt;next;</span><br><span class="line">    ListNode* new_head = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    end-&gt;next = head;</span><br><span class="line">    end-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>注意：在递归的写法中，前面两个判断条件可以写成同一个，都返回head；另外<code>head == nullptr</code>可以写成<code>!head</code>；需要注意递归方法的时间复杂度。</p>
<p><strong>stack</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* res = stack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ListNode* top = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            top-&gt;next = stack.<span class="built_in">top</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            top-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第一四一题：环形链表</title>
    <url>/LeetCode%E7%AC%AC%E4%B8%80%E5%9B%9B%E4%B8%80%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>引言：本文主要介绍leetcode第一四一题，判断一个链表是否有环，并给出其实现。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<h3 id="示例">示例</h3>
<p><strong>示例1</strong></p>
<p><img src="https://s2.loli.net/2022/01/09/TPnu4a8cX2GUMkJ.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<p><img src="https://s2.loli.net/2022/01/09/QzmCcjGbatMUu1E.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例3</strong></p>
<p><img src="https://s2.loli.net/2022/01/09/QncUVqxFeY8jEyl.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 [0, 10^4]</li>
<li>10^5 &lt;= Node.val &lt;= 10^5</li>
<li>pos 为 -1 或者链表中的一个 有效索引 。</li>
</ul>
<h3 id="分析">分析</h3>
<p>本题目最容易想到的是遍历链表，在遍历的过程中把每个结点存储起来，同时查询存储的里面是否有当前结点，如果有，那么说明是个环，如果遍历完没有，说明没有环；但是链表判圈有更加适合的判圈算法——<strong>佛洛依德判圈算法</strong>。</p>
<h3 id="实现">实现</h3>
<h4 id="实现一（哈希）">实现一（哈希）</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; hashset;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.<span class="built_in">find</span>(head) != hashset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashset.<span class="built_in">emplace</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h4 id="实现二（判圈算法）">实现二（判圈算法）</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    slow-&gt;next = head;</span><br><span class="line">    ListNode *fast = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p><strong>注意开始的状态，要把slow和fast定义为不同的指针，否则直接就输出true了，总而言之，一定要保证特殊情况下，尤其是开始状态的正确性</strong></p>
<h3 id="拓展">拓展</h3>
<p>1.<a href="">哈希容器（无序关联式容器）</a></p>
<p>2.<a href="">佛洛依德判圈算法</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>链表</tag>
        <tag>判圈算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode第二百三十四题：回文链表</title>
    <url>/Leetcode%E7%AC%AC%E4%BA%8C%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>引言：本文主要介绍LeetCode第二百三十四题，判断一个链表是否是回文链表，并给出c++实现。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p><strong>示例1</strong></p>
<p><img src="https://s2.loli.net/2022/01/21/ZG1w5Au2j8v9KsT.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<p><img src="https://s2.loli.net/2022/01/21/DcblhSoI8WV9QMg.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong></p>
<ul>
<li>链表中节点数目在范围[1, 10^5] 内</li>
<li>0 &lt;= Node.val &lt;= 9</li>
</ul>
<h3 id="分析">分析</h3>
<p>常规思路是用一个容器把结点全部按顺序存起来，然后遍历链表一一比对，但是消耗空间比较大，另一种容易想到的思路是反转链表，然后遍历判断每个结点是否相等，但是反转之后原链表就丢失了，所以不能这么做；正确思路应该是反转链表的后半部分，和前半部分的结点一一比对，如何找到中间的结点呢？用快慢指针！</p>
<h3 id="实现">实现</h3>
<p><strong>容器</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">uint8_t</span>&gt; vec;</span><br><span class="line">    ListNode* work = head;</span><br><span class="line">    <span class="keyword">while</span>(work) &#123;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(work-&gt;val);</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> itr = vec.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (itr != vec.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        itr--;</span><br><span class="line">        <span class="keyword">if</span> ((*itr) != head-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p><strong>双指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!(head-&gt;next)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> reverse = [](ListNode* head)&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* rev = <span class="built_in">reverse</span>(slow);</span><br><span class="line">            <span class="keyword">while</span> (rev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rev-&gt;val != head-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rev = rev-&gt;next;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* rev = <span class="built_in">reverse</span>(slow-&gt;next);</span><br><span class="line">            <span class="keyword">while</span> (rev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rev-&gt;val != head-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rev = rev-&gt;next;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习：几何绘制</title>
    <url>/OpenCV%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%87%A0%E4%BD%95%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[<p>引言：本文主要介绍OpenCV中的部分几何绘制函数的用法，包括：圆，椭圆，矩形，直线，填充多边形。</p>
<span id="more"></span>
<h3 id="示例">示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> w 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span></span>;</span><br><span class="line"><span class="comment">// 入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cv::Mat atom_image = cv::Mat::zeros(h, w, CV_8UC3);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 0);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 90);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 45);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, -45);</span></span><br><span class="line"><span class="comment">    MyCircle(atom_image, cv::Point(w/2, w/2));</span></span><br><span class="line"><span class="comment">    cv::imshow(&quot;ellipse&quot;, atom_image);</span></span><br><span class="line"><span class="comment">    cv::waitKey();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 注意这里是 h,w 的格式</span></span><br><span class="line">    cv::Mat rook_image = cv::Mat::<span class="built_in">zeros</span>(h, w, CV_8UC3);</span><br><span class="line">    <span class="built_in">MyPolygon</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyRectangle</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">0</span>, <span class="number">15</span>*w/<span class="number">16</span> ), cv::<span class="built_in">Point</span>( w, <span class="number">15</span>*w/<span class="number">16</span> ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, w ) );</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;rook&quot;</span>, rook_image);</span><br><span class="line">    <span class="comment">// 窗口显示在屏幕上的位置</span></span><br><span class="line">    cv::<span class="built_in">moveWindow</span>(<span class="string">&quot;rook&quot;</span>, <span class="number">2000</span>, <span class="number">800</span> );</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 椭圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = <span class="number">4</span>;</span><br><span class="line">    cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">                cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">                angle,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">360</span>,</span><br><span class="line">                cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">                thickness,</span><br><span class="line">                lineType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">circle</span>(img,</span><br><span class="line">               center,</span><br><span class="line">               w/<span class="number">32</span>,</span><br><span class="line">               cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">               <span class="number">2</span>,</span><br><span class="line">               <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                  cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                  cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                  cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                  <span class="number">-1</span>,</span><br><span class="line">                  <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意多边形填充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Create some points */</span></span><br><span class="line">  cv::Point rook_points[<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">0</span>]  = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">1</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">2</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">3</span>]  = cv::<span class="built_in">Point</span>( <span class="number">11</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">4</span>]  = cv::<span class="built_in">Point</span>( <span class="number">19</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">5</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">6</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">7</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">8</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">9</span>]  = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">10</span>] = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">11</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">12</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">13</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">14</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">15</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">16</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">17</span>] = cv::<span class="built_in">Point</span>( <span class="number">13</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">18</span>] = cv::<span class="built_in">Point</span>(  <span class="number">5</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">19</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ppt为二级指针（rook_points[0]是一个指针，所以ppt是一个指针数组，数组名是指向数组的指针）</span></span><br><span class="line">  <span class="keyword">const</span> cv::Point* ppt[<span class="number">1</span>] = &#123;rook_points[<span class="number">0</span>]&#125;;</span><br><span class="line">  <span class="keyword">int</span> npt[] = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">  cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="说明">说明</h3>
<p>1.椭圆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">            cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">            cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">            angle,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">360</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">            thickness,</span><br><span class="line">            lineType);</span><br></pre></td></tr></table></figure>
<p>img：cv::Mat图像</p>
<p>cv::Point(w/2, w/2)：椭圆心</p>
<p>cv::Size(w/4, w/16)：焦距</p>
<p>angle：旋转角度（不是弧度），注意是图像坐标系，右是正x，下是正y</p>
<p>angle_begin：圆弧的起始角度（不是弧度）</p>
<p>angle_end：圆弧的结束角度（不是弧度）</p>
<p>cv::Scalar( 255, 0, 0 )：颜色，BGR顺序</p>
<p>thickness：线宽， -1代表填充</p>
<p>lineType：线型，16是抗锯齿的线型，看起来边缘更平滑。可选-1，4， 8， 16，关于四邻域线型和八邻域线型，参考<a href="https://blog.csdn.net/young__fan/article/details/82696276">这里</a>。</p>
<p>2.圆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">circle</span>(img,</span><br><span class="line">            center,</span><br><span class="line">            w/<span class="number">32</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>img：cv::Mat图像</p>
<p>center：cv::Point，圆心</p>
<p>w/32：int,，半径</p>
<p>cv::Scalar(0, 0, 255)：颜色，BGR顺序</p>
<p>thickness：同上</p>
<p>lineType：同上</p>
<p>3.矩形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                <span class="number">-1</span>,</span><br><span class="line">                <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>img：cv::Mat图像</p>
<p>pt1：矩形左上角坐标，cv::Point</p>
<p>pt2：矩形右下角坐标，cv::Point</p>
<p>cv::Scalar(0, 255, 255)：颜色</p>
<p>thickness：同上</p>
<p>lineType：同上</p>
<p>4.直线（多边形）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br></pre></td></tr></table></figure>
<p>img：cv::Mat图像</p>
<p>start：cv::Point，起始点</p>
<p>end：cv::Point，终止点</p>
<p>cv::Scalar(0, 0, 0)：颜色</p>
<p>thickness：同上</p>
<p>lineType：同上</p>
<p>5.填充多边形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>img：cv::Mat图像</p>
<p>ppt：Array of polygons where each polygon is represented as an array of points.</p>
<p>npt：Array of 每个polygon的点数</p>
<p>ncontours：多边形数量</p>
<p>cv::Scalar(0, 0, 0)：颜色</p>
<p>lineType：同上</p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>PyTorch中反卷积的理解</title>
    <url>/PyTorch%E4%B8%AD%E5%8F%8D%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>引言：本文主要介绍PyTorch中反卷积的参数意义</p>
<span id="more"></span>
<h3 id="卷积">卷积</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">torch</span>.<span class="title">nn</span>.<span class="title">Conv2d</span>(<span class="params">in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, groups=<span class="number">1</span>, bias=<span class="literal">True</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>蓝色为输入，蓝色上的阴影为卷积核(kernel)，绿色为输出，蓝色边缘的白色框为padding</p>
<p><img src="https://i.loli.net/2021/05/12/V1Z63CdmKkYBlMe.png" alt="20201008164239753.png"></p>
<h3 id="反卷积">反卷积</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">torch</span>.<span class="title">nn</span>.<span class="title">ConvTranspose2d</span>(<span class="params">in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, output_padding=<span class="number">0</span>, bias=<span class="literal">True</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>卷积和反卷积函数中的in_channels与out_channels以及kernel_size的含义相同。</p>
<p>需要注意的是padding和stride和conv2d不同，padding不是蓝色的留白,是kernel像图像中心移动的单位。如下当padding=0时，卷积核刚好和输入边缘相交一个单位。因此pandding可以理解为卷积核向中心移动的步数。 同时stride也不再是kernel移动的步数，变为输入单元彼此散开的步数。<br>
即：<br>
<strong>padding=0时，卷积核的起始位置和输入层相交一个像素，当padding=1时，卷积核的起始位置和输入层相交2个像素，依此类推；<br>
stride=1时，输入层元素之间没有间隔，当stride=2时，输入层元素之间间隔为1，stride=3时，输入层元素之间间隔为2，以此类推。</strong></p>
<p>示意图如下图所示：</p>
<p>padding=0,kernel_size=3,stride=1<br>
output_padding是对反卷积后的特征图进行边缘填补0.<br>
output_padding=0表示不进行填补，output_padding=1表示进行填补一圈0，等于2表示进行填补2圈0.</p>
<p><img src="https://i.loli.net/2021/05/12/uXN6tYkZJU4El7C.png" alt="20201008165335118.png"></p>
<p>padding=2,kernel_size=4,stride=1</p>
<p><img src="https://i.loli.net/2021/05/12/RX34ZnjP1lpxHBk.png" alt="20201008165432987.png"></p>
<p>padding=2,kernel_size=3,stride=1</p>
<p><img src="https://i.loli.net/2021/05/12/PdsEA1wf2QymZiR.png" alt="20201008165450382.png"></p>
<p>padding=0,kernel_size=3,stride=2</p>
<p><img src="https://i.loli.net/2021/05/12/3xfmNu8jWM59rOS.png" alt="20201008165511740.png"></p>
<p>padding=1,kernel_size=3,stride=2</p>
<p><img src="https://i.loli.net/2021/05/12/G32P46qh9LxRIan.png" alt="20201008165531435.png"></p>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>反卷积</tag>
        <tag>转置卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第十九题：删除链表的倒数第 N 个结点</title>
    <url>/LeetCode%E7%AC%AC%E5%8D%81%E4%B9%9D%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>引言：本文主要介绍LeetCode第十九题，删除链表的倒数第N个结点，并给出c++实现。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p><strong>示例1</strong></p>
<p><img src="https://s2.loli.net/2022/01/24/Nyuo2cVLTt3iQ8z.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 sz</li>
<li>1 &lt;= sz &lt;= 30</li>
<li>0 &lt;= Node.val &lt;= 100</li>
<li>1 &lt;= n &lt;= sz</li>
</ul>
<h3 id="分析">分析</h3>
<p>因为只有遍历才能求链表的长度，所以最常想到的方法就是遍历链表求长度l，删除倒数第n个结点，也就知道了删除正数第几个结点，这种方法效率较低，这里就不实现了；第二种方法就是用双指针，让第一个指针始终领先第二个指针n个结点，这样当第一个结点在链表尾结点上时，第二个结点正好在倒数第n个结点的前一个结点；第三种方法是使用stack实现。</p>
<h3 id="实现">实现</h3>
<p><strong>双指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">      ListNode* first = head;</span><br><span class="line">      ListNode* second = dummy;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      		first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    ListNode* ans = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> ans;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：用到node-&gt;next  一定要保证node不为空结点，避免为空的一个好方法是使用哨兵结点。</p>
<p><strong>stack</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* work = head;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(dummy);</span><br><span class="line">    <span class="keyword">while</span> (work) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(work);</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="built_in">top</span>()-&gt;next = stack.<span class="built_in">top</span>()-&gt;next-&gt;next;</span><br><span class="line">    ListNode* res = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>stack</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu ssh</title>
    <url>/Ubuntu-ssh/</url>
    <content><![CDATA[<p>引言：本文主要介绍Ubuntu的ssh相关服务。</p>
<span id="more"></span>
<h3 id="设置ssh免密登录">设置ssh免密登录</h3>
<p>ssh-copy-id &lt;username&gt;@&lt;target_host_ip&gt;</p>
<p>解决按照上述操作之后还不能免密登录的方法：将<code>/etc/ssh/sshd_config</code>中的<code>StrictModes yes</code>改成no。</p>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch源码解读之DP&amp;DDP：数据并行和分布式训练详解</title>
    <url>/PyTorch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BDP-DDP%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>引言：本文介绍 PyTorch 里的数据并行训练，涉及 nn.DataParallel (DP) 和 nn.parallel.DistributedDataParallel (DDP) 两个模块（基于 1.7 版本），涵盖分布式训练的原理以及源码解读。</p>
<span id="more"></span>
<h3 id="数据并行">数据并行</h3>
<p>当一张 GPU 可以存储一个模型时，可以采用数据并行得到更准确的梯度或者加速训练，即每个 GPU 复制一份模型，将一批样本分为多份输入各个模型并行计算。因为<strong>求导以及加和都是线性的</strong>，数据并行在数学上也有效。</p>
<p>假设我们一个 batch 有 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 个样本，一共有 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 个 GPU 每个 GPU 分到 <img src="https://www.zhihu.com/equation?tex=m_j" alt="[公式]"> 个样本。假设样本刚好等分，则有 <img src="https://www.zhihu.com/equation?tex=m_j+%3D+%5Cfrac%7Bn%7D%7Bk%7D" alt="[公式]"> 。我们考虑总的损失函数 <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 对参数 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 的导数：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%5C+Loss%7D%7B%5Cpartial+w%7D+%3D+%5Cfrac%7B%5Cpartial%5B%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dl%28x_i%2Cy_i%29%5D%7D%7B%5Cpartial+w%7D+%3D+%5Cfrac%7B1%7D%7Bn%7D+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D+%5Cfrac%7B%5Cpartial+l%28x_i%2Cy_i%29%7D%7B%5Cpartial+w%7D+%3D+%5Csum_%7Bj%3D1%7D%5E%7Bk%7D+%5Cfrac%7Bm_j%7D%7Bn%7D+%5Cfrac%7B%5Cpartial%5B%5Cfrac%7B1%7D%7Bm_j%7D%5Csum_%7Bi%3D+m_%7Bj-1%7D%7D%5E%7Bm_%7Bj-1%7D%2Bm_%7Bj%7D%7Dl%28x_i%2Cy_i%29%5D%7D%7B%5Cpartial+w%7D+%3D+%5Csum_%7Bj%3D1%7D%5E%7Bk%7D+%5Cfrac%7Bm_j%7D%7Bn%7D%5Cfrac%7B%5Cpartial%5C+loss_%7Bj%7D%7D%7B%5Cpartial+w%7D+%3D+%5Cfrac%7B1%7D%7Bk%7D+%5Csum_%7Bj%3D1%7D%5E%7Bk%7D+%5Cfrac%7B%5Cpartial%5C+loss_%7Bj%7D%7D%7B%5Cpartial+w%7D" alt="[公式]"></p>
<p>那么接下来我们看一下 PyTorch 究竟是怎么实现数据并行的。</p>
<h3 id="DP">DP</h3>
<h4 id="使用">使用</h4>
<p>DP 的好处是，使用起来非常方便，只需要将原来单卡的 model 用 DP 改成多卡:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = nn.DataParallel(model)</span><br></pre></td></tr></table></figure>
<h4 id="原理">原理</h4>
<p>DP 基于单机多卡，所有设备都负责计算和训练网络，除此之外， device[0] (并非 GPU 真实标号而是输入参数 device_ids 首位) 还要负责整合梯度，更新参数。图 1 即为 GPU 0 作为 device[0] 的例子。从图中我们可以看出，有三个主要过程：</p>
<ul>
<li>过程一（图中红色部分）：各卡分别计算损失和梯度</li>
<li>过程二（图中蓝色部分）：所有梯度整合到 device[0]</li>
<li>过程三（图中绿色部分）：device[0] 进行参数更新，其他卡复制 device[0] 的参数</li>
</ul>
<p><img src="https://i.loli.net/2021/05/15/E4lF2jLGf1N8SPV.jpg" alt="ps.jpg"></p>
<p>DP 只能实现单机训练，使用的是多线程而非多个进程，不能算是严格意义上的分布式训练（多个节点），但是其原理和分布式训练算法里的 Parameter Server 架构很相近，我们借用 PS 的伪代码来说明一下。</p>
<p><img src="https://i.loli.net/2021/05/15/9GVSsC2prZ3PiOq.jpg" alt="4089rq9421004o77o6nr15nq9s5sq2p0.jpg"></p>
<p>我们可以看到 PS 的并行梯度下降流程分为：</p>
<ul>
<li>
<p>Task Scheduler：负责加载数据并分发数据至每个 worker 节点，并执行多轮迭代</p>
</li>
<li>
<p>Worker：①初始化：载入数据并将全部模型参数从 server 节点拉下来；②梯度计算：利用该节点的数据计算梯度并将梯度更新到 server 节点</p>
</li>
<li>
<p>Server：①汇总梯度；②更新参数</p>
</li>
</ul>
<p>OK， 现在我们已经知道了 DP 使用的算法，接下来我们看一下 PyTorch 是如何实现的。</p>
<h4 id="实现">实现</h4>
<p>这一节主要讨论 DP 的实现，首先先贴上源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataParallel</span>(<span class="params">Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, module, device_ids=<span class="literal">None</span>, output_device=<span class="literal">None</span>, dim=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DataParallel, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否有可用的 GPU</span></span><br><span class="line">        device_type = _get_available_device_type()</span><br><span class="line">        <span class="keyword">if</span> device_type <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.module = module</span><br><span class="line">            self.device_ids = []</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 默认使用所有可见的 GPU</span></span><br><span class="line">        <span class="keyword">if</span> device_ids <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device_ids = _get_all_device_indices()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 默认 server 是 device_ids 列表上第一个</span></span><br><span class="line">        <span class="keyword">if</span> output_device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            output_device = device_ids[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.module = module</span><br><span class="line">        self.device_ids = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: _get_device_index(x, <span class="literal">True</span>), device_ids))</span><br><span class="line">        self.output_device = _get_device_index(output_device, <span class="literal">True</span>)</span><br><span class="line">        self.src_device_obj = torch.device(device_type, self.device_ids[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查负载是否平衡， 不平衡（指内存或者处理器 max/min &gt; 0.75 会有警告）</span></span><br><span class="line">        _check_balance(self.device_ids)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单卡</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.device_ids) == <span class="number">1</span>:</span><br><span class="line">            self.module.to(self.src_device_obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, *inputs, **kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 没 GPU 可用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.device_ids:</span><br><span class="line">            <span class="keyword">return</span> self.module(*inputs, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 运行前 GPU device_ids[0] （即我们的 server）上必须有 parallelized module 的parameters 和 buffers</span></span><br><span class="line">        <span class="comment"># 因为 DP 保证 GPU device_ids[0] 和 base parallelized module 共享存储</span></span><br><span class="line">        <span class="comment"># 所以在device[0] 上的 in-place 更新也会被保留下来，其他的则不会</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> chain(self.module.parameters(), self.module.buffers()):</span><br><span class="line">            <span class="keyword">if</span> t.device != self.src_device_obj:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;module must have its parameters and buffers &quot;</span></span><br><span class="line">                                   <span class="string">&quot;on device &#123;&#125; (device_ids[0]) but found one of &quot;</span></span><br><span class="line">                                   <span class="string">&quot;them on device: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.src_device_obj, t.device))</span><br><span class="line"></span><br><span class="line">         <span class="comment"># nice 现在 device[0] 上已经有了 module 和 input， 接下来我们就要开始 PS 算法了</span></span><br><span class="line">        <span class="comment"># 可以开始看正文了</span></span><br><span class="line"></span><br><span class="line">        inputs, kwargs = self.scatter(inputs, kwargs, self.device_ids)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果仅有单卡可用，直接单卡计算，不用并行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.device_ids) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.module(*inputs[<span class="number">0</span>], **kwargs[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        replicas = self.replicate(self.module, self.device_ids[:<span class="built_in">len</span>(inputs)])</span><br><span class="line">        outputs = self.parallel_apply(replicas, inputs, kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.gather(outputs, self.output_device)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replicate</span>(<span class="params">self, module, device_ids</span>):</span></span><br><span class="line">        <span class="keyword">return</span> replicate(module, device_ids, <span class="keyword">not</span> torch.is_grad_enabled())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scatter</span>(<span class="params">self, inputs, kwargs, device_ids</span>):</span></span><br><span class="line">        <span class="keyword">return</span> scatter_kwargs(inputs, kwargs, device_ids, dim=self.dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parallel_apply</span>(<span class="params">self, replicas, inputs, kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> parallel_apply(replicas, inputs, kwargs, self.device_ids[:<span class="built_in">len</span>(replicas)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">self, outputs, output_device</span>):</span></span><br><span class="line">        <span class="keyword">return</span> gather(outputs, output_device, dim=self.dim)</span><br></pre></td></tr></table></figure>
<p>从 forward 函数可以看出，关键函数有 scatter, replicate, parallel_apply 和 gather，我们一个一个看一下。</p>
<p>首先是 scatter 函数，即 scatter_kwargs 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatter_kwargs</span>(<span class="params">inputs, kwargs, target_gpus, dim=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;Scatter with support for kwargs dictionary&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主要函数</span></span><br><span class="line">    inputs = scatter(inputs, target_gpus, dim) <span class="keyword">if</span> inputs <span class="keyword">else</span> []</span><br><span class="line">    kwargs = scatter(kwargs, target_gpus, dim) <span class="keyword">if</span> kwargs <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用空项补全使 inputs 和 kwargs 长度相当</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inputs) &lt; <span class="built_in">len</span>(kwargs):</span><br><span class="line">        inputs.extend([() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(kwargs) - <span class="built_in">len</span>(inputs))])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(kwargs) &lt; <span class="built_in">len</span>(inputs):</span><br><span class="line">        kwargs.extend([&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inputs) - <span class="built_in">len</span>(kwargs))])</span><br><span class="line">    <span class="comment"># 返回 tuple</span></span><br><span class="line">    inputs = <span class="built_in">tuple</span>(inputs)</span><br><span class="line">    kwargs = <span class="built_in">tuple</span>(kwargs)</span><br><span class="line">    <span class="keyword">return</span> inputs, kwargs</span><br></pre></td></tr></table></figure>
<p>scatter_kwargs 函数中最重要的就是 scatter 函数，负责将 tensor 分成大概相等的块并将他们分给不同的 GPU。对其他的数据类型，则是复制分散给不同的 GPU 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatter</span>(<span class="params">inputs, target_gpus, dim=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Slices tensors into approximately equal chunks and</span></span><br><span class="line"><span class="string">    distributes them across given GPUs. Duplicates</span></span><br><span class="line"><span class="string">    references to objects that are not tensors.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scatter_map</span>(<span class="params">obj</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, torch.Tensor):</span><br><span class="line">            <span class="keyword">return</span> Scatter.apply(target_gpus, <span class="literal">None</span>, dim, obj)</span><br><span class="line">        <span class="keyword">if</span> is_namedtuple(obj):</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">type</span>(obj)(*args) <span class="keyword">for</span> args <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj))]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">tuple</span>) <span class="keyword">and</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj)))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">list</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj))]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">dict</span>) <span class="keyword">and</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">type</span>(obj)(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj.items()))]</span><br><span class="line">        <span class="keyword">return</span> [obj <span class="keyword">for</span> targets <span class="keyword">in</span> target_gpus]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># After scatter_map is called, a scatter_map cell will exist. This cell</span></span><br><span class="line">    <span class="comment"># has a reference to the actual function scatter_map, which has references</span></span><br><span class="line">    <span class="comment"># to a closure that has a reference to the scatter_map cell (because the</span></span><br><span class="line">    <span class="comment"># fn is recursive). To avoid this reference cycle, we set the function to</span></span><br><span class="line">    <span class="comment"># None, clearing the cell</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = scatter_map(inputs)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        scatter_map = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>其中，针对 tensor 的函数，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scatter</span>(<span class="params">Function</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, target_gpus, chunk_sizes, dim, <span class="built_in">input</span></span>):</span></span><br><span class="line">        target_gpus = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> target_gpus]</span><br><span class="line">        ctx.dim = dim</span><br><span class="line">        ctx.input_device = <span class="built_in">input</span>.get_device() <span class="keyword">if</span> <span class="built_in">input</span>.device.<span class="built_in">type</span> != <span class="string">&quot;cpu&quot;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        streams = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">and</span> ctx.input_device == -<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Perform CPU to GPU copies in a background stream</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 新建 cuda stream</span></span><br><span class="line">            streams = [_get_stream(device) <span class="keyword">for</span> device <span class="keyword">in</span> target_gpus]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 真正的操作</span></span><br><span class="line">        outputs = comm.scatter(<span class="built_in">input</span>, target_gpus, chunk_sizes, ctx.dim, streams)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Synchronize with the copy stream</span></span><br><span class="line">        <span class="keyword">if</span> streams <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> i, output <span class="keyword">in</span> <span class="built_in">enumerate</span>(outputs):</span><br><span class="line">                <span class="keyword">with</span> torch.cuda.device(target_gpus[i]):</span><br><span class="line">                    main_stream = torch.cuda.current_stream()</span><br><span class="line">                    main_stream.wait_stream(streams[i])</span><br><span class="line">                    output.record_stream(main_stream)</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, *grad_output</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, Gather.apply(ctx.input_device, ctx.dim, *grad_output)</span><br></pre></td></tr></table></figure>
<p>comm.scatter 依赖于 C++，就不介绍了。</p>
<p>回顾 DP 代码块，我们已经运行完 scatter函数，即将一个 batch 近似等分成更小的 batch。接下来我们要看 replicate 函数和 gather 函数 （假设我们有不少于两张卡）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DP forward 里的代码</span></span><br><span class="line">   replicas = self.replicate(self.module, self.device_ids[:<span class="built_in">len</span>(inputs)])</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 实现</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">replicate</span>(<span class="params">network, devices, detach=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> _replicatable_module(network):</span><br><span class="line">           <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Cannot replicate network where python modules are &quot;</span></span><br><span class="line">                              <span class="string">&quot;childrens of ScriptModule&quot;</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> devices:</span><br><span class="line">           <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 需要复制到哪些 GPU， 复制多少份</span></span><br><span class="line">       devices = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> devices]</span><br><span class="line">       num_replicas = <span class="built_in">len</span>(devices)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 复制 parameters</span></span><br><span class="line">       params = <span class="built_in">list</span>(network.parameters())</span><br><span class="line">       param_indices = &#123;param: idx <span class="keyword">for</span> idx, param <span class="keyword">in</span> <span class="built_in">enumerate</span>(params)&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 拉到代码块底部看原函数，然后再回来</span></span><br><span class="line">       param_copies = _broadcast_coalesced_reshape(params, devices, detach)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 复制 buffers</span></span><br><span class="line">       buffers = <span class="built_in">list</span>(network.buffers())</span><br><span class="line">       buffers_rg = []</span><br><span class="line">       buffers_not_rg = []</span><br><span class="line">       <span class="keyword">for</span> buf <span class="keyword">in</span> buffers:</span><br><span class="line">           <span class="keyword">if</span> buf.requires_grad <span class="keyword">and</span> <span class="keyword">not</span> detach:</span><br><span class="line">               buffers_rg.append(buf)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               buffers_not_rg.append(buf)</span><br><span class="line"></span><br><span class="line">               <span class="comment"># 记录需要和不需要求导的 buffer 的 index</span></span><br><span class="line">       buffer_indices_rg = &#123;buf: idx <span class="keyword">for</span> idx, buf <span class="keyword">in</span> <span class="built_in">enumerate</span>(buffers_rg)&#125;</span><br><span class="line">       buffer_indices_not_rg = &#123;buf: idx <span class="keyword">for</span> idx, buf <span class="keyword">in</span> <span class="built_in">enumerate</span>(buffers_not_rg)&#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment"># 分别拷贝，这个咱们已经会了</span></span><br><span class="line">       buffer_copies_rg = _broadcast_coalesced_reshape(buffers_rg, devices, detach=detach)</span><br><span class="line">       buffer_copies_not_rg = _broadcast_coalesced_reshape(buffers_not_rg, devices, detach=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 现在开始拷贝网络</span></span><br><span class="line">       <span class="comment"># 准备过程：将 network.modules() 变成list</span></span><br><span class="line">       <span class="comment"># 然后再为之后复制的模型准备好空的 list 和 indices</span></span><br><span class="line"></span><br><span class="line">       modules = <span class="built_in">list</span>(network.modules())</span><br><span class="line">       module_copies = [[] <span class="keyword">for</span> device <span class="keyword">in</span> devices]</span><br><span class="line">       module_indices = &#123;&#125;</span><br><span class="line">       scriptmodule_skip_attr = &#123;<span class="string">&quot;_parameters&quot;</span>, <span class="string">&quot;_buffers&quot;</span>, <span class="string">&quot;_modules&quot;</span>, <span class="string">&quot;forward&quot;</span>, <span class="string">&quot;_c&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> i, module <span class="keyword">in</span> <span class="built_in">enumerate</span>(modules):</span><br><span class="line">           module_indices[module] = i</span><br><span class="line">           <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">               replica = module._replicate_for_data_parallel()</span><br><span class="line">               <span class="comment"># This is a temporary fix for DDP. DDP needs to access the</span></span><br><span class="line">               <span class="comment"># replicated model parameters. It used to do so through</span></span><br><span class="line">               <span class="comment"># `mode.parameters()`. The fix added in #33907 for DP stops the</span></span><br><span class="line">               <span class="comment"># `parameters()` API from exposing the replicated parameters.</span></span><br><span class="line">               <span class="comment"># Hence, we add a `_former_parameters` dict here to support DDP.</span></span><br><span class="line">               replica._former_parameters = OrderedDict()</span><br><span class="line"></span><br><span class="line">               module_copies[j].append(replica)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 接下来分别复制 module，param，buffer</span></span><br><span class="line">       <span class="keyword">for</span> i, module <span class="keyword">in</span> <span class="built_in">enumerate</span>(modules):</span><br><span class="line">           <span class="keyword">for</span> key, child <span class="keyword">in</span> module._modules.items():</span><br><span class="line">               <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       replica._modules[key] = <span class="literal">None</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   module_idx = module_indices[child]</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       <span class="built_in">setattr</span>(replica, key, module_copies[j][module_idx])</span><br><span class="line">           <span class="keyword">for</span> key, param <span class="keyword">in</span> module._parameters.items():</span><br><span class="line">               <span class="keyword">if</span> param <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       replica._parameters[key] = <span class="literal">None</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   param_idx = param_indices[param]</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       param = param_copies[j][param_idx]</span><br><span class="line">                       <span class="comment"># parameters in replicas are no longer leaves,</span></span><br><span class="line">                       <span class="comment"># so setattr them as non-parameter attributes</span></span><br><span class="line">                       <span class="built_in">setattr</span>(replica, key, param)</span><br><span class="line">                       <span class="comment"># expose the parameter for DDP</span></span><br><span class="line">                       replica._former_parameters[key] = param</span><br><span class="line">           <span class="keyword">for</span> key, buf <span class="keyword">in</span> module._buffers.items():</span><br><span class="line">               <span class="keyword">if</span> buf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       replica._buffers[key] = <span class="literal">None</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   <span class="keyword">if</span> buf.requires_grad <span class="keyword">and</span> <span class="keyword">not</span> detach:</span><br><span class="line">                       buffer_copies = buffer_copies_rg</span><br><span class="line">                       buffer_idx = buffer_indices_rg[buf]</span><br><span class="line">                   <span class="keyword">else</span>:</span><br><span class="line">                       buffer_copies = buffer_copies_not_rg</span><br><span class="line">                       buffer_idx = buffer_indices_not_rg[buf]</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       <span class="built_in">setattr</span>(replica, key, buffer_copies[j][buffer_idx])</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> [module_copies[j][<span class="number">0</span>] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas)]</span><br><span class="line"></span><br><span class="line">   <span class="comment"># ！！！从replicate来看这里</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">_broadcast_coalesced_reshape</span>(<span class="params">tensors, devices, detach=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">from</span> ._functions <span class="keyword">import</span> Broadcast</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 先看 else 的 comment，因为不 detach 也会用到同样的函数</span></span><br><span class="line">     <span class="keyword">if</span> detach:</span><br><span class="line">         <span class="keyword">return</span> comm.broadcast_coalesced(tensors, devices)</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># Use the autograd function to broadcast if not detach</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(tensors) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 下拉看源码</span></span><br><span class="line">             tensor_copies = Broadcast.apply(devices, *tensors)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> [tensor_copies[i:i + <span class="built_in">len</span>(tensors)]</span><br><span class="line">                     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tensor_copies), <span class="built_in">len</span>(tensors))]</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment">#  Broadcast.apply</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Broadcast</span>(<span class="params">Function</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, target_gpus, *inputs</span>):</span></span><br><span class="line">       <span class="keyword">assert</span> <span class="built_in">all</span>(i.device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> inputs), (</span><br><span class="line">           <span class="string">&#x27;Broadcast function not implemented for CPU tensors&#x27;</span></span><br><span class="line">       )</span><br><span class="line">       target_gpus = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> target_gpus]</span><br><span class="line">       ctx.target_gpus = target_gpus</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(inputs) == <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">tuple</span>()</span><br><span class="line">       ctx.num_inputs = <span class="built_in">len</span>(inputs)</span><br><span class="line">       <span class="comment"># input 放在 device[0]</span></span><br><span class="line">       ctx.input_device = inputs[<span class="number">0</span>].get_device()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 和 detach 的情况一样</span></span><br><span class="line">       outputs = comm.broadcast_coalesced(inputs, ctx.target_gpus)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># comm.broadcast_coalesced 的代码</span></span><br><span class="line">       <span class="comment"># tensors 必须在同一个设备，CPU 或者 GPU； devices 即是要拷贝到的设备；buffer_size 则是最大的buffer</span></span><br><span class="line">       <span class="comment"># 这里用到 buffer 将小张量合并到缓冲区以减少同步次数</span></span><br><span class="line">       <span class="comment"># def broadcast_coalesced(tensors, devices, buffer_size=10485760):</span></span><br><span class="line">       <span class="comment">#    devices = [_get_device_index(d) for d in devices]</span></span><br><span class="line">           <span class="comment">#       return torch._C._broadcast_coalesced(tensors, devices, buffer_size)</span></span><br><span class="line"></span><br><span class="line">       non_differentiables = []</span><br><span class="line">       <span class="keyword">for</span> idx, input_requires_grad <span class="keyword">in</span> <span class="built_in">enumerate</span>(ctx.needs_input_grad[<span class="number">1</span>:]):</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> input_requires_grad:</span><br><span class="line">               <span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line">                   non_differentiables.append(output[idx])</span><br><span class="line">       ctx.mark_non_differentiable(*non_differentiables)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">tuple</span>([t <span class="keyword">for</span> tensors <span class="keyword">in</span> outputs <span class="keyword">for</span> t <span class="keyword">in</span> tensors])</span><br><span class="line"></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, *grad_outputs</span>):</span></span><br><span class="line">       <span class="keyword">return</span> (<span class="literal">None</span>,) + ReduceAddCoalesced.apply(ctx.input_device, ctx.num_inputs, *grad_outputs)</span><br></pre></td></tr></table></figure>
<p>下面继续 parallel_apply 部分。⚠️ DP 和 DDP 共用 parallel_apply 代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DP 代码</span></span><br><span class="line">outputs = self.parallel_apply(replicas, inputs, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># threading 实现，用前面准备好的 replica 和输入数据，然后</span></span><br><span class="line"><span class="comment"># for 循环启动多线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallel_apply</span>(<span class="params">modules, inputs, kwargs_tup=<span class="literal">None</span>, devices=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个 GPU 都有模型和输入</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(modules) == <span class="built_in">len</span>(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保每个 GPU 都有相应的数据，如没有就空白补全</span></span><br><span class="line">    <span class="keyword">if</span> kwargs_tup <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      	<span class="comment"># 咱们在 scatter 已经补全了</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(modules) == <span class="built_in">len</span>(kwargs_tup)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        kwargs_tup = (&#123;&#125;,) * <span class="built_in">len</span>(modules)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> devices <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(modules) == <span class="built_in">len</span>(devices)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        devices = [<span class="literal">None</span>] * <span class="built_in">len</span>(modules)</span><br><span class="line"></span><br><span class="line">    devices = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> devices]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程实现</span></span><br><span class="line"></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    grad_enabled, autocast_enabled = torch.is_grad_enabled(), torch.is_autocast_enabled()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义 worker</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_worker</span>(<span class="params">i, module, <span class="built_in">input</span>, kwargs, device=<span class="literal">None</span></span>):</span></span><br><span class="line">        torch.set_grad_enabled(grad_enabled)</span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = get_a_var(<span class="built_in">input</span>).get_device()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> torch.cuda.device(device), autocast(enabled=autocast_enabled):</span><br><span class="line">                <span class="comment"># this also avoids accidental slicing of `input` if it is a Tensor</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(<span class="built_in">input</span>, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">                    <span class="built_in">input</span> = (<span class="built_in">input</span>,)</span><br><span class="line">                output = module(*<span class="built_in">input</span>, **kwargs)</span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="comment"># 并行计算得到输出</span></span><br><span class="line">                results[i] = output</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                results[i] = ExceptionWrapper(</span><br><span class="line">                    where=<span class="string">&quot;in replica &#123;&#125; on device &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, device))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(modules) &gt; <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 如有一个进程控制多个 GPU ，起多个线程</span></span><br><span class="line">      <span class="comment"># 需要强调一下，虽然 DDP 推荐单卡单进程，即每次调用 DDP device_ids 都只输入一张卡的 id（通常是 args.local_rank），但是如果输入多个 device_id，此时 DDP 就是单进程多线程控制多卡，和 DP 一样，关于 DDP 的解读可以看下文</span></span><br><span class="line"></span><br><span class="line">        threads = [threading.Thread(target=_worker,</span><br><span class="line">                                    args=(i, module, <span class="built_in">input</span>, kwargs, device))</span><br><span class="line">                   <span class="keyword">for</span> i, (module, <span class="built_in">input</span>, kwargs, device) <span class="keyword">in</span></span><br><span class="line">                   <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(modules, inputs, kwargs_tup, devices))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">            thread.start()</span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">            thread.join()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 一个 GPU 一个进程 （ DDP 推荐操作）</span></span><br><span class="line">        _worker(<span class="number">0</span>, modules[<span class="number">0</span>], inputs[<span class="number">0</span>], kwargs_tup[<span class="number">0</span>], devices[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inputs)):</span><br><span class="line">        output = results[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># error handle</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(output, ExceptionWrapper):</span><br><span class="line">            output.reraise()</span><br><span class="line">        outputs.append(output)</span><br><span class="line">    <span class="comment"># 输出 n 个计算结果</span></span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure>
<p>现在我们已经得到并行计算的结果了，接下来我们要将结果收集到 device[0]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DP 代码</span></span><br><span class="line"><span class="keyword">return</span> self.gather(outputs, self.output_device)</span><br><span class="line"><span class="comment"># 收集到 devices[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">outputs, target_device, dim=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Gathers tensors from different GPUs on a specified device</span></span><br><span class="line"><span class="string">      (-1 means the CPU).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gather_map</span>(<span class="params">outputs</span>):</span></span><br><span class="line">        out = outputs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(out, torch.Tensor):</span><br><span class="line">            <span class="keyword">return</span> Gather.apply(target_device, dim, *outputs)</span><br><span class="line">        <span class="keyword">if</span> out <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(out, <span class="built_in">dict</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>((<span class="built_in">len</span>(out) == <span class="built_in">len</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> outputs)):</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&#x27;All dicts must have the same number of keys&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>(out)(((k, gather_map([d[k] <span class="keyword">for</span> d <span class="keyword">in</span> outputs]))</span><br><span class="line">                              <span class="keyword">for</span> k <span class="keyword">in</span> out))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(out)(<span class="built_in">map</span>(gather_map, <span class="built_in">zip</span>(*outputs)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursive function calls like this create reference cycles.</span></span><br><span class="line">    <span class="comment"># Setting the function to None clears the refcycle.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = gather_map(outputs)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        gather_map = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gather 源码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gather</span>(<span class="params">Function</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, target_device, dim, *inputs</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">all</span>(i.device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> inputs), (</span><br><span class="line">            <span class="string">&#x27;Gather function not implemented for CPU tensors&#x27;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        target_device = _get_device_index(target_device, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        ctx.target_device = target_device</span><br><span class="line"></span><br><span class="line">        ctx.dim = dim</span><br><span class="line">        ctx.input_gpus = <span class="built_in">tuple</span>(i.get_device() <span class="keyword">for</span> i <span class="keyword">in</span> inputs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(t.dim() == <span class="number">0</span> <span class="keyword">for</span> t <span class="keyword">in</span> inputs) <span class="keyword">and</span> dim == <span class="number">0</span>:</span><br><span class="line">            inputs = <span class="built_in">tuple</span>(t.view(<span class="number">1</span>) <span class="keyword">for</span> t <span class="keyword">in</span> inputs)</span><br><span class="line">            warnings.warn(<span class="string">&#x27;Was asked to gather along dimension 0, but all &#x27;</span></span><br><span class="line">                          <span class="string">&#x27;input tensors were scalars; will instead unsqueeze &#x27;</span></span><br><span class="line">                          <span class="string">&#x27;and return a vector.&#x27;</span>)</span><br><span class="line">            ctx.unsqueezed_scalar = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ctx.unsqueezed_scalar = <span class="literal">False</span></span><br><span class="line">        ctx.input_sizes = <span class="built_in">tuple</span>(i.size(ctx.dim) <span class="keyword">for</span> i <span class="keyword">in</span> inputs)</span><br><span class="line">        <span class="keyword">return</span> comm.gather(inputs, ctx.dim, ctx.target_device)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        scattered_grads = Scatter.apply(ctx.input_gpus, ctx.input_sizes, ctx.dim, grad_output)</span><br><span class="line">        <span class="keyword">if</span> ctx.unsqueezed_scalar:</span><br><span class="line">            scattered_grads = <span class="built_in">tuple</span>(g[<span class="number">0</span>] <span class="keyword">for</span> g <span class="keyword">in</span> scattered_grads)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">None</span>, <span class="literal">None</span>) + scattered_grads</span><br><span class="line"></span><br><span class="line"><span class="comment"># comm.gather 涉及到 C++，具体实现咱也不讲了 ；)  </span></span><br><span class="line"><span class="comment"># Gathers tensors from multiple GPU devices.   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">tensors, dim=<span class="number">0</span>, destination=<span class="literal">None</span>, *, out=<span class="literal">None</span></span>):</span></span><br><span class="line">    tensors = [_handle_complex(t) <span class="keyword">for</span> t <span class="keyword">in</span> tensors]</span><br><span class="line">    <span class="keyword">if</span> out <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> destination == -<span class="number">1</span>:</span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">&#x27;Using -1 to represent CPU tensor is deprecated. Please use a &#x27;</span></span><br><span class="line">                <span class="string">&#x27;device object or string instead, e.g., &quot;cpu&quot;.&#x27;</span>)</span><br><span class="line">        destination = _get_device_index(destination, allow_cpu=<span class="literal">True</span>, optional=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> torch._C._gather(tensors, dim, destination)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> destination <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">&quot;&#x27;destination&#x27; must not be specified when &#x27;out&#x27; is specified, but &quot;</span></span><br><span class="line">                <span class="string">&quot;got destination=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(destination))</span><br><span class="line">        <span class="keyword">return</span> torch._C._gather_out(tensors, out, dim)</span><br></pre></td></tr></table></figure>
<p>前向传播的时候我们会先用 Scatter 函数将数据从 device[0] 分配并复制到不同的卡，之后用 Replicate 函数将模型从 device[0] 复制到不同的卡，之后各个卡都有了同样的模型和不同的数据，分别调用 forward 计算损失和梯度。</p>
<p>反向传播的时候，我们会将梯度收集到 device[0] 然后在 device[0] 更新参数。</p>
<h4 id="分析">分析</h4>
<ul>
<li>
<p>负载不均衡</p>
<p>device[0] 负载大一些</p>
</li>
<li>
<p>通信开销</p>
<p>假设有 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 个 GPU， 完成一次通信需要时间 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7Bp%7D%7Bb%7D" alt="[公式]"> ，那么使用 PS 算法，总共需要花费时间 <img src="https://www.zhihu.com/equation?tex=T+%3D+2%28k-1%29%5Cfrac%7Bp%7D%7Bb%7D+" alt="[公式]"></p>
</li>
<li>
<p>单进程</p>
<p>The difference between <code>DistributedDataParallel</code> and <code>DataParallel</code> is: <code>DistributedDataParallel</code> uses multiprocessing where a process is created for each GPU, while <code>DataParallel</code> uses multithreading. By using multiprocessing, each GPU has its dedicated process, this avoids the performance overhead caused by GIL of Python interpreter.</p>
<p>全局解释器锁，简单来说就是，一个 Python 进程只能利用一个 CPU kernel，即单核多线程并发时，只能执行一个线程。考虑多核，多核多线程可能出现线程颠簸 (thrashing) 造成资源浪费，所以 Python 想要利用多核最好是多进程。</p>
</li>
</ul>
<h3 id="DDP">DDP</h3>
<h4 id="使用-2">使用</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;--save_dir&quot;</span>, default=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--local_rank&quot;</span>, default=-<span class="number">1</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--world_size&quot;</span>, default=<span class="number">1</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化后端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># world_size 指的是总的并行进程数目</span></span><br><span class="line"><span class="comment"># 比如16张卡单卡单进程 就是 16</span></span><br><span class="line"><span class="comment"># 等到连接的进程数等于world_size，程序才会继续运行</span></span><br><span class="line">torch.distributed.init_process_group(backend=<span class="string">&#x27;nccl&#x27;</span>,</span><br><span class="line">                                         world_size=ws,</span><br><span class="line">                                         init_method=<span class="string">&#x27;env://&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.cuda.set_device(args.local_rank)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">f&#x27;cuda:<span class="subst">&#123;args.local_rank&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = nn.Linear(<span class="number">2</span>,<span class="number">3</span>).to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train dataset</span></span><br><span class="line"><span class="comment"># train_sampler</span></span><br><span class="line"><span class="comment"># train_loader</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 DDP，这里我们通过规定 device_id 用了单卡单进程</span></span><br><span class="line"><span class="comment"># 实际上根据我们前面对 parallel_apply 的解读，DDP 也支持一个进程控制多个线程利用多卡</span></span><br><span class="line">model = DDP(model,</span><br><span class="line">            device_ids=[args.local_rank],</span><br><span class="line">            output_device=args.local_rank).to(device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存模型 </span></span><br><span class="line"><span class="keyword">if</span> torch.distributed.get_rank() == <span class="number">0</span>:</span><br><span class="line">  torch.save(model.module.state_dict(),</span><br><span class="line">             <span class="string">&#x27;results/%s/model.pth&#x27;</span> % args.save_dir)</span><br></pre></td></tr></table></figure>
<h4 id="原理-2">原理</h4>
<p>和DP的区别：</p>
<p>1.多进程：和 DP 不同， DDP 采用多进程，最推荐的做法是每张卡一个进程从而避免上一节所说单进程带来的影响。前文也提到了 DP 和 DDP 共用一个 parallel_apply 函数，所以 DDP 同样支持单进程多线程多卡操作，自然也支持多进程多线程，不过需要注意一下 world_size。</p>
<p>2.通信效率：DP 的通信成本随着 GPU 数量线性增长，而 DDP 支持 Ring AllReduce，其通信成本是恒定的，与 GPU 数量无关。</p>
<p>3.同步参数：DP 通过收集梯度到 device[0]，在device[0] 更新参数，然后其他设备复制 device[0] 的参数实现各个模型同步；DDP 通过保证初始状态相同并且改变量也相同（指同步梯度） ，保证模型同步。</p>
<p>Ring AllReduce模型如下所示：</p>
<p><img src="https://i.loli.net/2021/05/16/kOYXy9deM3oUG4c.png" alt="ring-gpus.png"></p>
<p>Ring AllReduce是一种利用带宽优化环解决通信问题的方法，解决了DP通信成本和GPU的数量线性相关的问题，分为两个步骤：Scatter Reduce和All Gather</p>
<p>Scatter Reduce过程：首先，我们将参数分为k份，相邻的GPU传递不同的参数，在传递k-1次之后，可以得到每一份参数的累积（在不同的GPU上）。</p>
<p><img src="https://i.loli.net/2021/05/16/ctNmUGaEBXT2uA5.gif" alt="v2-4590aeb5fd981b1e6f926cc68605884a_b.gif"></p>
<p>All Gather：得到每一份参数的累积之后，再做一次传递，同步到所有的GPU上。</p>
<p><img src="https://i.loli.net/2021/05/16/clDb6TRnw1BPHf2.gif" alt="v2-c9df34575d7d95ec87d85575d25d6f37_b.gif"></p>
<p>根据这两个过程，我们可以计算到All Reduce的通信成本为： <img src="https://www.zhihu.com/equation?tex=2%28k-1%29%5Cfrac%7B%5Cfrac%7Bp%7D%7Bk%7D%7D%7Bb%7D" alt="[公式]"> ，和 GPU 数量无关了。</p>
<p>DDP 也是数据并行，所以每张卡都有模型和输入。我们以多进程多线程为例，每起一个进程，该进程的 device[0] 都会从本地复制模型，如果该进程仍有多线程，就像 DP，模型会从 device[0] 复制到其他设备。</p>
<p>DDP 通过 Reducer 来管理梯度同步。为了提高通讯效率， Reducer 会将梯度归到不同的桶里（按照模型参数的 reverse order， 因为反向传播需要符合这样的顺序），一次归约一个桶。其中桶的大小为参数 bucket_cap_mb 默认为 25，可根据需要调整。下图即为一个例子。</p>
<p>可以看到每个进程里，模型参数都按照倒序放在桶里，每次归约一个桶。</p>
<p><img src="https://i.loli.net/2021/05/17/umiJGts7Y2qfjzI.png" alt="72401724-d296d880-371a-11ea-90ab-737f86543df9.png"></p>
<p>终于可以看 DDP 的实现了！！首先我们贴上伪代码！</p>
<p><img src="https://i.loli.net/2021/05/17/D7NZUTiWJ23qfBb.png" alt="Screenshot from 2021-05-17 00-23-12.png"></p>
<p>从 DDP 的伪代码我们可以看出，DDP 最重要的包括三部分：</p>
<ul>
<li>
<p>constructor：负责在构建的时候将 rank 0 的 state_dict() 广播 ➜ 保证所有网络初始状态相同；初始化 buckets 并尽可能按逆序将 parameters 分配进 buckets ➜ 按桶通信提高效率；为每个 parameter 加上 grad_accumulator 以及在 autograd_graph 注册 autograd_hook ➜ 在 backward 时负责梯度同步。</p>
</li>
<li>
<p>forward：正常的 forward 操作；如果 self.find_unused_parameters 设置为 True，DDP 会在 forward 结束时 traverse autograd graph 找到所有没用过的parameters 并标记为 ready ➜ 虽说这一步开销很大，但是有时计算动态图会改变，所以很必要。</p>
</li>
<li>
<p>autograd_hook：这个 hook 是挂在 autograd graph 在 backward 时负责梯度同步的。当一个梯度计算好后，相应的 hook 会告诉 DDP 可以用来归约。当一个桶里的梯度都可以了，Reducer 就会启动异步 allreduce 去计算所有进程的平均值。当所有桶都可以了，Reducer 会等所有 allreduce 完成，然后将得到的梯度写到 param.grad。</p>
</li>
</ul>
<p>好的，但现在为止我们应该对 DDP 有了大致了解了，接下来就一起看一下代码是怎么实现的！</p>
<ul>
<li>通信：因为 DDP 依赖 c10d 的 ProcessGroup 进行通信，所以开始前我们先要有个 ProcessGroup 实例。这步可以通过 torch.distributed.init_process_group 实现。</li>
<li>构建：我们先贴上 DDP 初始化的源码，最重要的是 _ddp_init_helper 这个函数，负责多线程时复制模型、将 parameters 分组、创建 reducer 以及为 SyncBN 做准备等。这部分代码看 comment 就能懂，我们会重点说一下 dist.Reducer，作为管理器，自然很重要了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedDataParallel</span>(<span class="params">Module</span>):</span>       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, module, device_ids=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 output_device=<span class="literal">None</span>, dim=<span class="number">0</span>, broadcast_buffers=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 process_group=<span class="literal">None</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 bucket_cap_mb=<span class="number">25</span>,       </span></span></span><br><span class="line"><span class="function"><span class="params">                 find_unused_parameters=<span class="literal">False</span>,       </span></span></span><br><span class="line"><span class="function"><span class="params">                 check_reduction=<span class="literal">False</span>,      </span></span></span><br><span class="line"><span class="function"><span class="params">                 gradient_as_bucket_view=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(DistributedDataParallel, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">any</span>((p.requires_grad <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters())), (</span><br><span class="line">            <span class="string">&quot;DistributedDataParallel is not needed when a module &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t have any parameter that requires a gradient.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.is_multi_device_module = <span class="built_in">len</span>(&#123;p.device <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()&#125;) &gt; <span class="number">1</span></span><br><span class="line">        distinct_device_types = &#123;p.device.<span class="built_in">type</span> <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()&#125;</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(distinct_device_types) == <span class="number">1</span>, (</span><br><span class="line">            <span class="string">&quot;DistributedDataParallel&#x27;s input module must be on &quot;</span></span><br><span class="line">            <span class="string">&quot;the same type of devices, but input module parameters locate in &#123;&#125;.&quot;</span></span><br><span class="line">        ).<span class="built_in">format</span>(distinct_device_types)</span><br><span class="line">        self.device_type = <span class="built_in">list</span>(distinct_device_types)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.device_type == <span class="string">&quot;cpu&quot;</span> <span class="keyword">or</span> self.is_multi_device_module:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">not</span> device_ids <span class="keyword">and</span> <span class="keyword">not</span> output_device, (</span><br><span class="line">                <span class="string">&quot;DistributedDataParallel device_ids and output_device arguments &quot;</span></span><br><span class="line">                <span class="string">&quot;only work with single-device GPU modules, but got &quot;</span></span><br><span class="line">                <span class="string">&quot;device_ids &#123;&#125;, output_device &#123;&#125;, and module parameters &#123;&#125;.&quot;</span></span><br><span class="line">            ).<span class="built_in">format</span>(device_ids, output_device, &#123;p.device <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()&#125;)</span><br><span class="line"></span><br><span class="line">            self.device_ids = <span class="literal">None</span></span><br><span class="line">            self.output_device = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Use all devices by default for single-device GPU modules</span></span><br><span class="line">            <span class="keyword">if</span> device_ids <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                device_ids = _get_all_device_indices()</span><br><span class="line"></span><br><span class="line">            self.device_ids = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: _get_device_index(x, <span class="literal">True</span>), device_ids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> output_device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                output_device = device_ids[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            self.output_device = _get_device_index(output_device, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> process_group <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.process_group = _get_default_group()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.process_group = process_group</span><br><span class="line"></span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.module = module</span><br><span class="line">        self.device = <span class="built_in">list</span>(self.module.parameters())[<span class="number">0</span>].device</span><br><span class="line">        self.broadcast_buffers = broadcast_buffers</span><br><span class="line">        self.find_unused_parameters = find_unused_parameters</span><br><span class="line">        self.require_backward_grad_sync = <span class="literal">True</span></span><br><span class="line">        self.require_forward_param_sync = <span class="literal">True</span></span><br><span class="line">        self.ddp_join_enabled = <span class="literal">False</span></span><br><span class="line">        self.gradient_as_bucket_view = gradient_as_bucket_view</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check_reduction:</span><br><span class="line">            <span class="comment"># This argument is no longer used since the reducer</span></span><br><span class="line">            <span class="comment"># will ensure reduction completes even if some parameters</span></span><br><span class="line">            <span class="comment"># do not receive gradients.</span></span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">&quot;The `check_reduction` argument in `DistributedDataParallel` &quot;</span></span><br><span class="line">                <span class="string">&quot;module is deprecated. Please avoid using it.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># used for intra-node param sync and inter-node sync as well</span></span><br><span class="line">        self.broadcast_bucket_size = <span class="built_in">int</span>(<span class="number">250</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># reduction bucket size</span></span><br><span class="line">        self.bucket_bytes_cap = <span class="built_in">int</span>(bucket_cap_mb * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保证初始状态一样</span></span><br><span class="line">        <span class="comment"># Sync params and buffers</span></span><br><span class="line">        self._sync_params_and_buffers(authoritative_rank=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下拉看源码</span></span><br><span class="line">        self._ddp_init_helper()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sync_params_and_buffers</span>(<span class="params">self, authoritative_rank=<span class="number">0</span></span>):</span></span><br><span class="line">        module_states = <span class="built_in">list</span>(self.module.state_dict().values())</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(module_states) &gt; <span class="number">0</span>:</span><br><span class="line">            self._distributed_broadcast_coalesced(</span><br><span class="line">                module_states,</span><br><span class="line">                self.broadcast_bucket_size,</span><br><span class="line">                authoritative_rank)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_ddp_init_helper</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialization helper function that does the following:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        (1) replicating the module from device[0] to the other devices （前文提到 DDP 也支持一个进程多线程利用多卡，类似 DP ，这时候就会用到第一步）</span></span><br><span class="line"><span class="string">        (2) bucketing the parameters for reductions （把 parameter 分组，梯度通讯时，先得到梯度的会通讯）</span></span><br><span class="line"><span class="string">        (3) resetting the bucketing states</span></span><br><span class="line"><span class="string">        (4) registering the grad hooks （创建管理器）</span></span><br><span class="line"><span class="string">        (5) passing a handle of DDP to SyncBatchNorm Layer （为 SyncBN 准备）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">parameters</span>(<span class="params">m, recurse=<span class="literal">True</span></span>):</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">model_parameters</span>(<span class="params">m</span>):</span></span><br><span class="line">                ps = m._former_parameters.values() \</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">hasattr</span>(m, <span class="string">&quot;_former_parameters&quot;</span>) \</span><br><span class="line">                    <span class="keyword">else</span> m.parameters(recurse=<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">                    <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> m.modules() <span class="keyword">if</span> recurse <span class="keyword">else</span> [m]:</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> model_parameters(m):</span><br><span class="line">                    <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.device_ids <span class="keyword">and</span> <span class="built_in">len</span>(self.device_ids) &gt; <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">&quot;Single-Process Multi-GPU is not the recommended mode for &quot;</span></span><br><span class="line">                <span class="string">&quot;DDP. In this mode, each DDP instance operates on multiple &quot;</span></span><br><span class="line">                <span class="string">&quot;devices and creates multiple module replicas within one &quot;</span></span><br><span class="line">                <span class="string">&quot;process. The overhead of scatter/gather and GIL contention &quot;</span></span><br><span class="line">                <span class="string">&quot;in every forward pass can slow down training. &quot;</span></span><br><span class="line">                <span class="string">&quot;Please consider using one DDP instance per device or per &quot;</span></span><br><span class="line">                <span class="string">&quot;module replica by explicitly setting device_ids or &quot;</span></span><br><span class="line">                <span class="string">&quot;CUDA_VISIBLE_DEVICES. &quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># only create replicas for single-device CUDA modules</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># <span class="doctag">TODO:</span> we don&#x27;t need to replicate params in here. they&#x27;re always going to</span></span><br><span class="line">            <span class="comment"># be broadcasted using larger blocks in broadcast_coalesced, so it might be</span></span><br><span class="line">            <span class="comment"># better to not pollute the caches with these small blocks</span></span><br><span class="line">            self._module_copies = replicate(self.module, self.device_ids, detach=<span class="literal">True</span>)</span><br><span class="line">            self._module_copies[<span class="number">0</span>] = self.module</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> module_copy <span class="keyword">in</span> self._module_copies[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">for</span> param, copy_param <span class="keyword">in</span> <span class="built_in">zip</span>(self.module.parameters(), parameters(module_copy)):</span><br><span class="line">                    <span class="comment"># Reducer requires param copies have the same strides across replicas.</span></span><br><span class="line">                    <span class="comment"># Fixes up copy_param strides in case replicate didn&#x27;t match param strides.</span></span><br><span class="line">                    <span class="keyword">if</span> param.layout <span class="keyword">is</span> torch.strided <span class="keyword">and</span> param.stride() != copy_param.stride():</span><br><span class="line">                        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                            copy_param.set_(copy_param.clone()</span><br><span class="line">                                                      .as_strided(param.size(), param.stride())</span><br><span class="line">                                                      .copy_(copy_param))</span><br><span class="line">                    copy_param.requires_grad = param.requires_grad</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._module_copies = [self.module]</span><br><span class="line"></span><br><span class="line">        self.modules_params = [<span class="built_in">list</span>(parameters(m)) <span class="keyword">for</span> m <span class="keyword">in</span> self._module_copies]</span><br><span class="line">        self.modules_buffers = [<span class="built_in">list</span>(m.buffers()) <span class="keyword">for</span> m <span class="keyword">in</span> self._module_copies]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Build tuple of (module, parameter) for all parameters that require grads.</span></span><br><span class="line">        modules_and_parameters = [</span><br><span class="line">            [</span><br><span class="line">                (module, parameter)</span><br><span class="line">                <span class="keyword">for</span> module <span class="keyword">in</span> replica.modules()</span><br><span class="line">                <span class="keyword">for</span> parameter <span class="keyword">in</span> <span class="built_in">filter</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> parameter: parameter.requires_grad,</span><br><span class="line">                    parameters(module, recurse=<span class="literal">False</span>))</span><br><span class="line">            ] <span class="keyword">for</span> replica <span class="keyword">in</span> self._module_copies]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Build list of parameters.</span></span><br><span class="line">        parameters = [</span><br><span class="line">            <span class="built_in">list</span>(parameter <span class="keyword">for</span> _, parameter <span class="keyword">in</span> replica)</span><br><span class="line">            <span class="keyword">for</span> replica <span class="keyword">in</span> modules_and_parameters]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Checks if a module will produce a sparse gradient.</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">produces_sparse_gradient</span>(<span class="params">module</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(module, torch.nn.Embedding):</span><br><span class="line">                <span class="keyword">return</span> module.sparse</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(module, torch.nn.EmbeddingBag):</span><br><span class="line">                <span class="keyword">return</span> module.sparse</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Build list of booleans indicating whether or not to expect sparse</span></span><br><span class="line">        <span class="comment"># gradients for the corresponding parameters.</span></span><br><span class="line">        expect_sparse_gradient = [</span><br><span class="line">            <span class="built_in">list</span>(produces_sparse_gradient(module) <span class="keyword">for</span> module, _ <span class="keyword">in</span> replica)</span><br><span class="line">            <span class="keyword">for</span> replica <span class="keyword">in</span> modules_and_parameters]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The bucket size limit is specified in the constructor.</span></span><br><span class="line">        <span class="comment"># Additionally, we allow for a single small bucket for parameters</span></span><br><span class="line">        <span class="comment"># that are defined first, such that their gradients don&#x27;t spill into</span></span><br><span class="line">        <span class="comment"># a much larger bucket, adding unnecessary latency after gradient</span></span><br><span class="line">        <span class="comment"># computation finishes. Experiments showed 1MB is a reasonable value.</span></span><br><span class="line">        bucket_indices = dist._compute_bucket_assignment_by_size(</span><br><span class="line">            parameters[<span class="number">0</span>],</span><br><span class="line">            [dist._DEFAULT_FIRST_BUCKET_BYTES, self.bucket_bytes_cap],</span><br><span class="line">            expect_sparse_gradient[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Note: reverse list of buckets because we want to approximate the</span></span><br><span class="line">        <span class="comment"># order in which their gradients are produced, and assume they</span></span><br><span class="line">        <span class="comment"># are used in the forward pass in the order they are defined.</span></span><br><span class="line">        <span class="comment"># 管理器</span></span><br><span class="line">        self.reducer = dist.Reducer(</span><br><span class="line">            parameters,</span><br><span class="line">            <span class="built_in">list</span>(<span class="built_in">reversed</span>(bucket_indices)),</span><br><span class="line">            self.process_group,</span><br><span class="line">            expect_sparse_gradient,</span><br><span class="line">            self.bucket_bytes_cap,</span><br><span class="line">            self.find_unused_parameters,</span><br><span class="line">            self.gradient_as_bucket_view)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># passing a handle to torch.nn.SyncBatchNorm layer</span></span><br><span class="line">        self._passing_sync_batchnorm_handle(self._module_copies)</span><br></pre></td></tr></table></figure>
<p>每个 DDP 进程都会创建本地 Reducer 在 backward 时管理梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.reducer = dist.Reducer(</span><br><span class="line">     parameters,</span><br><span class="line">     <span class="built_in">list</span>(<span class="built_in">reversed</span>(bucket_indices)),</span><br><span class="line">     self.process_group,</span><br><span class="line">     expect_sparse_gradient,</span><br><span class="line">     self.bucket_bytes_cap,</span><br><span class="line">     self.find_unused_parameters,</span><br><span class="line">     self.gradient_as_bucket_view)</span><br></pre></td></tr></table></figure>
<p>我们看 Reducer.cpp 可以发现，构建 Reducer 时，除了各种初始化，最重要的一步就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> replica_count = replicas_.<span class="built_in">size</span>();</span><br><span class="line">  grad_accumulators_.<span class="built_in">resize</span>(replica_count);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> replica_index = <span class="number">0</span>; replica_index &lt; replica_count;</span><br><span class="line">       replica_index++) &#123;         </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> variable_count = replicas_[replica_index].<span class="built_in">size</span>();</span><br><span class="line">    grad_accumulators_[replica_index].<span class="built_in">resize</span>(variable_count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> variable_index = <span class="number">0</span>; variable_index &lt; variable_count;</span><br><span class="line">         variable_index++) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="keyword">auto</span>&amp; variable = replicas_[replica_index][variable_index];  </span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> index = <span class="built_in">VariableIndex</span>(replica_index, variable_index);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The gradient accumulator function is lazily initialized once.</span></span><br><span class="line">      <span class="comment">// Therefore we can use its presence in the autograd graph as</span></span><br><span class="line">      <span class="comment">// evidence that the parameter has participated in an iteration.</span></span><br><span class="line">      <span class="keyword">auto</span> grad_accumulator =</span><br><span class="line">          torch::autograd::impl::<span class="built_in">grad_accumulator</span>(variable);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">        <span class="keyword">using</span> torch::distributed::autograd::ThreadLocalDistAutogradContext;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// grad_accumulator 执行完后，autograd_hook 就会运行</span></span><br><span class="line">        hooks.<span class="built_in">emplace_back</span>(</span><br><span class="line">            grad_accumulator-&gt;<span class="built_in">add_post_hook</span>(</span><br><span class="line">                torch::make_unique&lt;torch::autograd::utils::LambdaPostHook&gt;(</span><br><span class="line">                    [=](<span class="keyword">const</span> torch::autograd::variable_list&amp; outputs,</span><br><span class="line">                        <span class="keyword">const</span> torch::autograd::variable_list&amp; <span class="comment">/* unused */</span>)&#123;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></span><br><span class="line">                         <span class="keyword">this</span>-&gt;rpc_context.<span class="built_in">set</span>(</span><br><span class="line">                             ThreadLocalDistAutogradContext::<span class="built_in">getContextPtr</span>());   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                         <span class="keyword">this</span>-&gt;<span class="built_in">autograd_hook</span>(index);</span><br><span class="line">                         <span class="keyword">return</span> outputs;</span><br><span class="line">                       &#125;)),</span><br><span class="line">               grad_accumulator);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Map raw function pointer to replica index and parameter index.</span></span><br><span class="line">          <span class="comment">// This is used later on when the autograd graph is traversed</span></span><br><span class="line">          <span class="comment">// to check for parameters for which no gradient is computed.</span></span><br><span class="line">          func_[grad_accumulator.<span class="built_in">get</span>()] = index;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// The gradient accumulator is stored as weak_ptr in the autograd</span></span><br><span class="line">          <span class="comment">// metadata of the variable, so we have to keep it alive here for</span></span><br><span class="line">          <span class="comment">// the raw pointer to be valid.</span></span><br><span class="line">          grad_accumulators_[replica_index][variable_index] =</span><br><span class="line">              std::<span class="built_in">move</span>(grad_accumulator);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unordered_map&lt;torch::autograd::Node*, VariableIndex&gt; func_;</span></span><br><span class="line">    <span class="comment">// func_ 存了grad_accumulator &amp; index 的对应，方便我们之后在 autograd graph 寻找 unused parameters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  std::vector&lt;std::vector&lt;std::shared_ptr&lt;torch::autograd::Node&gt;&gt;&gt;</span></span><br><span class="line">    <span class="comment">//  grad_accumulators_;</span></span><br><span class="line">    <span class="comment">//  grad_accumulators_ 对应的 index 存了相应的 grad_accumulator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//   std::vector&lt;std::pair&lt;uintptr_t, std::shared_ptr&lt;torch::autograd::Node&gt;&gt;&gt;</span></span><br><span class="line">    <span class="comment">//   hooks_;</span></span><br></pre></td></tr></table></figure>
<p>其中，发挥重要功能的 autograd_hook 如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reducer::autograd_hook</span><span class="params">(VariableIndex index)</span> </span>&#123;</span><br><span class="line">     <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;mutex_)</span></span>;</span><br><span class="line">     <span class="keyword">if</span> (find_unused_parameters_) &#123;</span><br><span class="line">       <span class="comment">// 在 no_sync 时，只要参数被用过一次，就会被标记为用过</span></span><br><span class="line">       <span class="comment">// Since it gets here, this param has been used for this iteration. We want</span></span><br><span class="line">       <span class="comment">// to mark it in local_used_maps_. During no_sync session, the same var can</span></span><br><span class="line">       <span class="comment">// be set multiple times, which is OK as does not affect correctness. As</span></span><br><span class="line">       <span class="comment">// long as it is used once during no_sync session, it is marked as used.</span></span><br><span class="line">       local_used_maps_[index.replica_index][index.variable_index] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore if we don&#x27;t expect to be called.</span></span><br><span class="line">    <span class="comment">// This may be the case if the user wants to accumulate gradients</span></span><br><span class="line">    <span class="comment">// for number of iterations before reducing them.</span></span><br><span class="line">    <span class="keyword">if</span> (!expect_autograd_hooks_) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild bucket only if 1) it is the first time to rebuild bucket 2)</span></span><br><span class="line">    <span class="comment">// find_unused_parameters_ is false, currently it does not support when there</span></span><br><span class="line">    <span class="comment">// are unused parameters 3) this backward pass needs to run allreduce. Here,</span></span><br><span class="line">    <span class="comment">// we just dump tensors and their parameter indices into rebuilt_params_ and</span></span><br><span class="line">    <span class="comment">// rebuilt_param_indices_ based on gradient arriving order, and then at the</span></span><br><span class="line">    <span class="comment">// end of finalize_backward(), buckets will be rebuilt based on</span></span><br><span class="line">    <span class="comment">// rebuilt_params_ and rebuilt_param_indices_, and then will be broadcasted</span></span><br><span class="line">    <span class="comment">// and initialized. Also we only need to dump tensors and parameter indices of</span></span><br><span class="line">    <span class="comment">// one replica.</span></span><br><span class="line">    <span class="built_in">push_rebuilt_params</span>(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If `find_unused_parameters_` is true there may be model parameters that</span></span><br><span class="line">    <span class="comment">// went unused when computing the model output, they won&#x27;t be part of the</span></span><br><span class="line">    <span class="comment">// autograd graph, and won&#x27;t receive gradients. These parameters are</span></span><br><span class="line">    <span class="comment">// discovered in the `prepare_for_backward` function and their indexes stored</span></span><br><span class="line">    <span class="comment">// in the `unused_parameters_` vector.</span></span><br><span class="line">    <span class="keyword">if</span> (!has_marked_unused_parameters_ &amp;&amp; find_unused_parameters_) &#123;</span><br><span class="line">      has_marked_unused_parameters_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; unused_index : unused_parameters_) &#123;</span><br><span class="line">        <span class="built_in">mark_variable_ready</span>(unused_index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally mark variable for which this function was originally called.</span></span><br><span class="line">    <span class="built_in">mark_variable_ready</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前向传播</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs, *kwargs</span>):</span>           <span class="keyword">if</span> self.ddp_join_enabled:               ones = torch.ones(                   <span class="number">1</span>, device=self.device               )               work = dist.all_reduce(ones, group=self.process_group, async_op=<span class="literal">True</span>)               self.reducer._set_forward_pass_work_handle(                   work, self.ddp_join_divide_by_initial_world_size               )</span><br><span class="line"><span class="comment"># Calling _rebuild_buckets before forward compuation,</span></span><br><span class="line">      <span class="comment"># It may allocate new buckets before deallocating old buckets</span></span><br><span class="line">      <span class="comment"># inside _rebuild_buckets. To save peak memory usage,</span></span><br><span class="line">      <span class="comment"># call _rebuild_buckets before the peak memory usage increases</span></span><br><span class="line">      <span class="comment"># during forward computation.</span></span><br><span class="line">      <span class="comment"># This should be called only once during whole training period.</span></span><br><span class="line">      <span class="keyword">if</span> self.reducer._rebuild_buckets():</span><br><span class="line">          logging.info(<span class="string">&quot;Reducer buckets have been rebuilt in this iteration.&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> self.require_forward_param_sync:</span><br><span class="line">          self._sync_params()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> self.ddp_join_enabled:</span><br><span class="line">          <span class="comment"># Notify joined ranks whether they should sync in backwards pass or not.</span></span><br><span class="line">          self._check_global_requires_backward_grad_sync(is_joined_rank=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># ！！！</span></span><br><span class="line">      <span class="keyword">if</span> self.device_ids:</span><br><span class="line">          inputs, kwargs = self.scatter(inputs, kwargs, self.device_ids)</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(self.device_ids) == <span class="number">1</span>:</span><br><span class="line">              output = self.module(*inputs[<span class="number">0</span>], **kwargs[<span class="number">0</span>])</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 单进程多线程多卡的情况</span></span><br><span class="line">              outputs = self.parallel_apply(self._module_copies[:<span class="built_in">len</span>(inputs)], inputs, kwargs)</span><br><span class="line">              output = self.gather(outputs, self.output_device)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          output = self.module(*inputs, **kwargs)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> torch.is_grad_enabled() <span class="keyword">and</span> self.require_backward_grad_sync:</span><br><span class="line">          self.require_forward_param_sync = <span class="literal">True</span></span><br><span class="line">          <span class="comment"># We&#x27;ll return the output object verbatim since it is a freeform</span></span><br><span class="line">          <span class="comment"># object. We need to find any tensors in this object, though,</span></span><br><span class="line">          <span class="comment"># because we need to figure out which parameters were used during</span></span><br><span class="line">          <span class="comment"># this forward pass, to ensure we short circuit reduction for any</span></span><br><span class="line">          <span class="comment"># unused parameters. Only if `find_unused_parameters` is set.</span></span><br><span class="line">          <span class="keyword">if</span> self.find_unused_parameters:</span><br><span class="line">          <span class="comment"># 当DDP参数 find_unused_parameter 为 true 时，其会在 forward 结束时，启动一个回溯，标记出所有没被用到的 parameter，提前把这些设定为 ready，这样 backward 就可以在一个 subgraph 进行，但这样会牺牲一部分时间。</span></span><br><span class="line">              self.reducer.prepare_for_backward(<span class="built_in">list</span>(_find_tensors(output)))</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              self.reducer.prepare_for_backward([])</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          self.require_forward_param_sync = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<ul>
<li>反向传播</li>
</ul>
<p>那么，DDP 究竟是怎么启动 allreduce 的呢？我们看一下 reducer.cpp 里对桶的定义以及用法，主要是在mark_*_ready。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span>       std::vector replicas;</span><br><span class="line"><span class="comment">// Global indices of participating variables in the bucket</span></span><br><span class="line">  std::vector&lt;<span class="keyword">size_t</span>&gt; variable_indices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of replicas to be marked done before this bucket is ready.</span></span><br><span class="line">  <span class="comment">// 计数</span></span><br><span class="line">  <span class="keyword">size_t</span> pending;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep work handle around when this set of buckets is being reduced.</span></span><br><span class="line">  std::shared_ptr&lt;c10d::ProcessGroup::Work&gt; work;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep future work handle around if DDP comm hook is registered.</span></span><br><span class="line">  c10::intrusive_ptr&lt;torch::jit::Future&gt; future_work;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this bucket should expect a single sparse gradient.</span></span><br><span class="line">  <span class="comment">// Implies: replicas[i].variables.size() == 1.</span></span><br><span class="line">  <span class="keyword">bool</span> expect_sparse_gradient = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先看 mark_variable_ready，截取片段（指去除报错信息）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reducer::mark_variable_ready</span><span class="params">(VariableIndex index)</span> </span>&#123;     <span class="keyword">const</span> <span class="keyword">auto</span> replica_index = index.replica_index;     <span class="keyword">const</span> <span class="keyword">auto</span> variable_index = index.variable_index;     <span class="built_in">TORCH_CHECK</span>(replica_index &lt; replicas_.<span class="built_in">size</span>(), <span class="string">&quot;Out of range replica index.&quot;</span>);     <span class="built_in">TORCH_CHECK</span>(         variable_index &lt; variable_locators_.<span class="built_in">size</span>(),         <span class="string">&quot;Out of range variable index.&quot;</span>);     backward_stats_[replica_index][variable_index] =         <span class="built_in">current_time_in_nanos</span>() - backward_stats_base_;</span><br><span class="line"><span class="comment">// 每当变量被标记成 ready 了，都要调用一下 finalize</span></span><br><span class="line">require_finalize_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; bucket_index = variable_locators_[variable_index];</span><br><span class="line"><span class="keyword">auto</span>&amp; bucket = buckets_[bucket_index.bucket_index];</span><br><span class="line"><span class="keyword">auto</span>&amp; replica = bucket.replicas[replica_index];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// If it was scheduled, wait on allreduce in forward pass that tells us</span></span><br><span class="line"><span class="comment">// division factor based on no. of currently participating processes.</span></span><br><span class="line"><span class="keyword">if</span> (divFactor_ == kUnsetDivFactor) &#123;</span><br><span class="line">  divFactor_ = process_group_-&gt;<span class="built_in">getSize</span>();</span><br><span class="line">  <span class="keyword">auto</span>&amp; workHandle = forwardPassWorkHandle_.workHandle;</span><br><span class="line">  <span class="keyword">if</span> (workHandle &amp;&amp; !forwardPassWorkHandle_.useStaticWorldSize) &#123;</span><br><span class="line">    workHandle-&gt;<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">auto</span> results = workHandle-&gt;<span class="built_in">result</span>();</span><br><span class="line">    <span class="comment">// Guard against the results being empty</span></span><br><span class="line">    <span class="built_in">TORCH_INTERNAL_ASSERT</span>(results.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">    at::Tensor&amp; res = results.<span class="built_in">front</span>();</span><br><span class="line">    divFactor_ = res.<span class="built_in">item</span>().to&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bucket.expect_sparse_gradient) &#123;</span><br><span class="line">  <span class="built_in">mark_variable_ready_sparse</span>(index);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">mark_variable_ready_dense</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查桶里的变量是不是都ready了，如果没有东西 pending，那就是都 ready了</span></span><br><span class="line"><span class="keyword">if</span> (--replica.pending == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (--bucket.pending == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">mark_bucket_ready</span>(bucket_index.bucket_index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run finalizer function and kick off reduction for local_used_maps once the</span></span><br><span class="line"><span class="comment">// final bucket was marked ready.</span></span><br><span class="line"><span class="keyword">if</span> (next_bucket_ == buckets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (find_unused_parameters_) &#123;</span><br><span class="line">    <span class="comment">// H2D from local_used_maps_ to local_used_maps_dev_</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; local_used_maps_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">// We do async H2D to avoid the blocking overhead. The async copy and</span></span><br><span class="line">      <span class="comment">// allreduce respect the current stream, so will be sequenced correctly.</span></span><br><span class="line">      local_used_maps_dev_[i].<span class="built_in">copy_</span>(local_used_maps_[i], <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    local_used_work_ = process_group_-&gt;<span class="built_in">allreduce</span>(local_used_maps_dev_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The autograd engine uses the default stream when running callbacks, so we</span></span><br><span class="line">  <span class="comment">// pass in the current CUDA stream in case it is not the default.</span></span><br><span class="line">  c10::DeviceType deviceType = replica.contents.<span class="built_in">device</span>().<span class="built_in">type</span>();</span><br><span class="line">  <span class="keyword">const</span> c10::impl::VirtualGuardImpl guard =</span><br><span class="line">      c10::impl::VirtualGuardImpl&#123;deviceType&#125;;</span><br><span class="line">  <span class="keyword">const</span> c10::Stream currentStream =</span><br><span class="line">      guard.<span class="built_in">getStream</span>(replica.contents.<span class="built_in">device</span>());</span><br><span class="line">  torch::autograd::Engine::<span class="built_in">get_default_engine</span>().<span class="built_in">queue_callback</span>([=] &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;mutex_);</span><br><span class="line">    <span class="comment">// Run callback with the current stream</span></span><br><span class="line">    c10::OptionalStreamGuard currentStreamGuard&#123;currentStream&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">finalize_backward</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reducer::mark_bucket_ready</span><span class="params">(<span class="keyword">size_t</span> bucket_index)</span> </span>&#123;     <span class="built_in">TORCH_INTERNAL_ASSERT</span>(bucket_index &gt;= next_bucket_);</span><br><span class="line"><span class="comment">// Buckets are reduced in sequence. Ignore this bucket if</span></span><br><span class="line"><span class="comment">// it&#x27;s not its turn to be reduced.</span></span><br><span class="line"><span class="keyword">if</span> (bucket_index &gt; next_bucket_) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep going, until we either:</span></span><br><span class="line"><span class="comment">// - 所有桶都在 allreduce 那就等着 or</span></span><br><span class="line"><span class="comment">// - 还有桶没好，那也等着.</span></span><br><span class="line"><span class="keyword">for</span> (; next_bucket_ &lt; buckets_.<span class="built_in">size</span>() &amp;&amp; buckets_[next_bucket_].pending == <span class="number">0</span>;</span><br><span class="line">     next_bucket_++) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; bucket = buckets_[next_bucket_];</span><br><span class="line">  std::vector&lt;at::Tensor&gt; tensors;</span><br><span class="line">  tensors.<span class="built_in">reserve</span>(bucket.replicas.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; replica : bucket.replicas) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CUDA default stream 都按时序排好了</span></span><br><span class="line">    tensors.<span class="built_in">push_back</span>(replica.contents);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (comm_hook_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没注册 comm_hook，直接 allreduce</span></span><br><span class="line">    bucket.work = process_group_-&gt;<span class="built_in">allreduce</span>(tensors);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注册了 comm_hook 那就先跑 hook</span></span><br><span class="line">    <span class="comment">// 需要注意的是，这个comm_hook 只是处理通信的底层hook，如果想在 reduce 前分别进行梯度裁剪，还是需要在 autograph 挂 hook</span></span><br><span class="line">    bucket.future_work = comm_hook_-&gt;<span class="built_in">runHook</span>(<span class="built_in">GradBucket</span>(tensors));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>除了正常的前向传播，DDP 还允许在 subgraph 进行反向传播，只需将 self.find_unused_parameters 设置为 True。或许有朋友会问，如果 find_unused_parameters 设置为 True，那每次都要 traverse 计算图，明明开销很大，为什么有时候我们还要将 self.find_unused_parameters 设置为 True？ 这是因为训练时有可能某次迭代只用到整个模型的一个 subgraph， 并且这个 subgraph 迭代时可能会改变，就是说某些参数可能会在训练时被跳过。但因为所有parameters 在一开始就被分好桶了，而我们的 hook 又规定了只有整个桶 ready 了（pending==0）才会通信，如果我们不将 unused parameter 标记为 ready，整个过程会没法进行。我们在这节结束的部分附上一个小实验验证一下。</p>
<p>DDP 通过在构建时注册 autograd hook 进行梯度同步。当一个梯度计算好后，相应的 hook 会告诉 DDP 可以用来归约。当一个桶里的梯度都可以了，Reducer 就会启动异步 allreduce 去计算所有进程的平均值。当所有桶都可以了，Reducer 会等所有 allreduce 完成，然后将得到的梯度写到 param.grad。</p>
<p>optimizer step 独立于 DDP，所有进程的模型能够同步是因为初始状态相同并且改变量也相同。</p>
<ul>
<li>实验：find_unused_params</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> torch   </span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist   </span><br><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp   </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn   </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim   </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP</span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> default_timer <span class="keyword">as</span> timer</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="string">&#x27;localhost&#x27;</span>   </span><br><span class="line">os.environ[<span class="string">&#x27;MASTER_PORT&#x27;</span>] = <span class="string">&#x27;12138&#x27;</span>   </span><br><span class="line"><span class="comment"># sync   </span></span><br><span class="line">seed = <span class="number">0</span>   </span><br><span class="line">torch.manual_seed(seed)   </span><br><span class="line">torch.cuda.manual_seed(seed)   </span><br><span class="line">torch.cuda.manual_seed_all(seed)   </span><br><span class="line">os.environ[<span class="string">&#x27;PYTHONHASHSEED&#x27;</span>] = <span class="built_in">str</span>(seed)   </span><br><span class="line">torch.backends.cudnn.deterministic = <span class="literal">True</span>   </span><br><span class="line">torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span>(<span class="params">rank, world_size</span>):</span>       </span><br><span class="line">    <span class="comment"># create default process group       </span></span><br><span class="line">    dist.init_process_group(<span class="string">&quot;gloo&quot;</span>,rank=rank, </span><br><span class="line">world_size=world_size,init_method=<span class="string">&#x27;env://&#x27;</span>)       </span><br><span class="line">    <span class="comment"># create local model</span></span><br><span class="line">    model = nn.Linear(<span class="number">10</span>, <span class="number">10</span>).to(rank)</span><br><span class="line">    <span class="comment"># construct DDP model</span></span><br><span class="line">    ddp_model = DDP(model, device_ids=[rank])</span><br><span class="line">    <span class="comment"># define loss function and optimizer</span></span><br><span class="line">    loss_fn = nn.MSELoss()</span><br><span class="line">    optimizer = optim.SGD(ddp_model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    buf = <span class="number">0</span></span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        start = timer()</span><br><span class="line">        <span class="comment"># forward pass</span></span><br><span class="line">        outputs = ddp_model(torch.randn(<span class="number">20</span>, <span class="number">10</span>).to(rank))</span><br><span class="line">        end = timer()</span><br><span class="line"></span><br><span class="line">        tmp = end-start</span><br><span class="line">        buf+=tmp</span><br><span class="line">        labels = torch.randn(<span class="number">20</span>, <span class="number">10</span>).to(rank)</span><br><span class="line">        <span class="comment"># backward pass</span></span><br><span class="line">        loss_fn(outputs, labels).backward()</span><br><span class="line">        <span class="comment"># update parameters</span></span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="built_in">print</span>(tmp)</span><br><span class="line">    <span class="built_in">print</span>(buf)</span><br><span class="line">    <span class="built_in">print</span>(buf/<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    world_size = <span class="number">1</span></span><br><span class="line">    mp.spawn(example,</span><br><span class="line">        args=(world_size,),</span><br><span class="line">        nprocs=world_size,</span><br><span class="line">        join=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">     main()</span><br></pre></td></tr></table></figure>
<p>将 find_unused_params 分别设置成 True 或者 False 跑多次取平均，可以得到：</p>
<ul>
<li>find_unused_params=True: 0.3367 ms</li>
<li>find_unused_params=False: 0.2993 ms</li>
</ul>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DDP</tag>
        <tag>源码解读</tag>
        <tag>分布式训练</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第二题：两数相加</title>
    <url>/LeetCode%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>引言：本文主要分析LeetCode第二题，Python和C++实现；并对链表做了简单说明。</p>
<span id="more"></span>
<h3 id="题目">题目</h3>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h3 id="示例">示例</h3>
<p><strong>示例1：</strong></p>
<p><img src="https://i.loli.net/2021/05/18/7lnuBY3hgVbz5PN.jpg" alt="addtwonumber1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<h3 id="分析">分析</h3>
<p>1.注意链表是一种数据结构，不同于python中的list</p>
<p>2.注意最后的进位不要忘记</p>
<p>3.本题的精髓在于这个while循环，可以不用补齐使得两个链表长度相等</p>
<h3 id="实现">实现</h3>
<h4 id="python">python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    head = result = ListNode()</span><br><span class="line">    carry = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">        val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            val += l1.val</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            val += l2.val</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            val+=<span class="number">1</span>	<span class="comment">#注意在python中没有自增和自减运算符！</span></span><br><span class="line">        carry = (val &gt;= <span class="number">10</span>)</span><br><span class="line">        val = val % <span class="number">10</span>;</span><br><span class="line">        result.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        result = result.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> carry:</span><br><span class="line">        result.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h4 id="c">c++</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *result = head;</span><br><span class="line">    <span class="keyword">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> || carry) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = sum % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// result-&gt;next-&gt;val = res;    // 错误，事先不存在，注意开辟空间，而不是赋值</span></span><br><span class="line">        result-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(res);</span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">        carry = (sum &gt;= <span class="number">10</span>) ? <span class="literal">true</span> : <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展">拓展</h3>
<p>数据结构：<a href="http://zsh4614.cn/2021/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/">链表</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04 Server安装OpenPAI v1.8.0</title>
    <url>/Ubuntu18-04-Server%E5%AE%89%E8%A3%85OpenPAI-v1-8-0/</url>
    <content><![CDATA[<p>引言：本文主要介绍如何在Ubuntu18.04上安装OpenPAI v1.8.0。</p>
<span id="more"></span>
<h3 id="环境要求">环境要求</h3>
<p>OpenPAI的部署要求您至少有2台独立的机器：一台dev-box机器、一台master机器和一台worker机器。master，worker必须为物理机器，dev-box可以是硬盘空间不少于40GB的虚拟机，毕竟他只有安装和维护系统的时候才用到，用物理机器太浪费了。</p>
<h4 id="硬件要求">硬件要求</h4>
<p><strong>master：</strong></p>
<ul>
<li>至少40GB内存。</li>
<li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li>
<li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li>
</ul>
<p><strong>worker：</strong></p>
<ul>
<li>至少16GB内存。</li>
<li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li>
<li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li>
<li>必须有Nvidia的gpu。</li>
</ul>
<h4 id="软件要求">软件要求</h4>
<p><strong>master：</strong></p>
<ul>
<li>Ubuntu 18.04 (16.04、20.04应该可用)</li>
<li>SSH服务已开启。</li>
<li>和所有worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</li>
<li>Docker已被正确安装。</li>
<li>NTP已被成功开启。 您可以用命令<code>apt install ntp</code>来检查。</li>
<li>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</li>
</ul>
<p><strong>worker：</strong></p>
<ul>
<li>
<p>Ubuntu 16.04 (18.04、20.04应该可用，但没有经过完整测试)</p>
</li>
<li>
<p>SSH服务已开启。</p>
</li>
<li>
<p>所有master和worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</p>
</li>
<li>
<p>Docker已被正确安装。</p>
</li>
<li>
<p>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</p>
</li>
<li>
<p>nvidia驱动已被正确安装</p>
</li>
<li>
<p>nvidia-container-runtime已被正确安装，并且被设置为Docker的默认runtime。</p>
</li>
</ul>
<h3 id="依赖安装">依赖安装</h3>
<p>1.master和所有worker安装Ubuntu18.04系统。</p>
<p>参考这里</p>
<p>2.master和所有worker进行磁盘挂载。</p>
<p>参考这里</p>
<p>3.所有worker安装nvidia显卡驱动，并设置持久模式。</p>
<p>参考这里</p>
<p>4.master和所有worker安装docker。</p>
<p>参考这里</p>
<p>5.所有worker安装nvidia-container-runtime。</p>
<p>参考这里</p>
<p>6.master开启ntp服务。</p>
<p>7.dev-box设置免密登录master和所有worker。</p>
<p>参考这里</p>
<p>8.master部署docker私有仓库和UI服务。</p>
<p>参考这里</p>
<p>9.master和所有worker都安装unzip</p>
<h3 id="K8s安装OpenPAI">K8s安装OpenPAI</h3>
<p>该步骤的所有操作都在dev-box机器上。</p>
<h4 id="准备项目">准备项目</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;pai.git</span><br><span class="line">cd pai</span><br><span class="line">git checkout v1.8.0</span><br></pre></td></tr></table></figure>
<h4 id="准备离线相关文件">准备离线相关文件</h4>
<p>由于网络限制，部分镜像和服务需要离线下载安装。</p>
<p>1.下载离线文件并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:zsh4614/pai-offline.git</span><br><span class="line">cd pai-offline</span><br><span class="line">unzip pai-offline-deploy-distribute.zip</span><br></pre></td></tr></table></figure>
<p>2.将<code>offline-deploy-files-distribute.yml</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd pai-offline-deploy-distribute</span><br><span class="line">cp offline-deploy-files-distribute.yml &lt;pai-code-dir&gt;/contrib/kubespray</span><br></pre></td></tr></table></figure>
<p>3.将<code>roles/offline-deploy-files-distribute</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray/roles</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r roles/offline-deploy-files-distribute &lt;pai-code-dir&gt;/contrib/kubespray/roles</span><br></pre></td></tr></table></figure>
<p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/b0fcc1ad1d78a373a12c109491914b877fc2d56d/roles/download/defaults/main.yml#L2">这一行</a>可知，安装的时候下载的文件会存放在<code>/tmp/releases/</code>文件夹，故可提前下载好相关文件以避免网络问题。</p>
<p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/daed3e5b6a085ac99e076b51d314fcf76e4127b4/roles/kubernetes/node/tasks/install.yml#L11">这一行</a>可知，如果使用了<code>skip_downloads: true</code>参数，kubeadm默认不会在master节点安装，所以手动安装kubeadm。</p>
<h4 id="修改安装脚本">修改安装脚本</h4>
<p>1.在<code>/contrib/kubespray/quick-start-kubespray.sh</code>中添加如下一行，在安装过程中安装上述离线文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">echo &quot;Performing docker-cache config distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml docker-cache-config-distribute.yml -e &quot;@$&#123;CLUSTER_CONFIG&#125;&quot; || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Performing offline deploy file distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml offline-deploy-files-distribute.yml || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Starting kubernetes...&quot;</span><br><span class="line">/bin/bash script/kubernetes-boot.sh || exit $?</span><br></pre></td></tr></table></figure>
<p>2.将<code>/contrib/kubespray/docker-cache-config-distribute.yml</code>中的<code>docker_cache_host</code>的端口改成master节点的docker私有仓库端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker_cache_host: &quot;&#123;&#123; hostvars[groups[&#x27;kube-master&#x27;][0]][&#x27;ip&#x27;] &#125;&#125;:5000&quot;</span><br></pre></td></tr></table></figure>
<h4 id="编写参数文件">编写参数文件</h4>
<p>1.修改<code>/contrib/kubespray/config/config.yaml</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user: &lt;your-ssh-username&gt;</span><br><span class="line">password: &lt;your-ssh-password&gt;</span><br><span class="line">docker_image_tag: v1.8.0</span><br><span class="line"></span><br><span class="line">enable_docker_cache: false</span><br><span class="line">docker_cache_storage_backend: &quot;filesystem&quot;</span><br><span class="line">docker_cache_fs_mount_path: &quot;/sda/pai/registry&quot;</span><br><span class="line">enable_marketplace: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">docker_data_root: /sda/pai/data</span><br><span class="line"></span><br><span class="line">openpai_kubespray_extra_var:</span><br><span class="line">  download_container: false</span><br><span class="line">  skip_downloads: true</span><br></pre></td></tr></table></figure>
<p>2.修改<code>/contrib/kubespray/config/layout.yaml</code>文件</p>
<p>仿照官方用例即可</p>
<h4 id="安装K8s">安装K8s</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd contrib/kubespray</span><br><span class="line">bash quick-start-kubespray.sh</span><br></pre></td></tr></table></figure>
<h4 id="安装OpenPAI">安装OpenPAI</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash quick-start-service.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>OpenPAI</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch源码解读之torch.autograd：梯度计算详解</title>
    <url>/PyTorch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Btorch-autograd%EF%BC%9A%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>引言：本篇笔记以介绍 pytorch 中的 autograd 模块功能为主，主要涉及 torch/autograd 下代码，不涉及底层的 C++ 实现。</p>
<span id="more"></span>
<ul>
<li>torch.autograd.function （函数的反向传播）</li>
<li>torch.autograd.functional （计算图的反向传播）</li>
<li>torch.autograd.gradcheck （数值梯度检查）</li>
<li>torch.autograd.anomaly_mode （在自动求导时检测错误产生路径）</li>
<li>torch.autograd.grad_mode （设置是否需要梯度）</li>
<li>model.eval() 与 torch.no_grad()</li>
<li>torch.autograd.profiler （提供 function 级别的统计信息）</li>
</ul>
<h3 id="torch-autograd-function（函数的反向传播）">torch.autograd.function（函数的反向传播）</h3>
<p>我们在构建网络的时候，通常使用 pytorch 所提供的<code>nn.Module</code> （例如<code>nn.Conv2d</code>, <code>nn.ReLU</code>等）作为基本单元。而这些 Module 通常是包裹 autograd function，以其作为真正实现的部分。例如<code>nn.ReLU</code> 实际使用<code>torch.nn.functional.relu</code>（<code>F.relu</code>）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReLU</span>(<span class="params">Module</span>):</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;inplace&#x27;</span>]</span><br><span class="line">    inplace: <span class="built_in">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inplace: <span class="built_in">bool</span> = <span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ReLU, self).__init()__()</span><br><span class="line">        self.inplace = inplace</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span>: Tensor</span>) -&gt; Tensor:</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(<span class="built_in">input</span>, inplace=self.inplace)</span><br></pre></td></tr></table></figure>
<p>这里的<code>F.relu</code>类型为<code>function</code>，若再剥开一层，其实际包裹的函数类型为<code>builtin_function_or_method</code>，这也是真正完成运算的部分。这些部分通常使用 C++ 实现（如<code>ATen</code>）。至此我们知道，一个模型的运算部分由 autograd functions 组成，这些 autograd functions 内部定义了 forward，backward 用以描述前向和梯度反传的过程，组合后可以实现整个模型的前向和梯度反传。以<code>torch.autograd.function</code>中所定义的<code>Function</code>类为基类，我们可以实现自定义的autograd function，所实现的 function 需包含<code>forward</code>及<code>backward</code>两个方法。以下以<code>Exp</code>和<code>GradCoeff</code>两个自定义 autograd function 为例进行讲解：</p>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>torch.autograd</tag>
        <tag>梯度</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu server基础环境搭建</title>
    <url>/Ubuntu%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>引言：本文主要介绍如何在ubuntu电脑上制作ubuntu server 18.04的启动盘，并安装系统和基础环境。</p>
<span id="more"></span>
<h3 id="制作ubuntu18-04-server的系统盘">制作ubuntu18.04 server的系统盘</h3>
<p>首先，在<a href="https://ubuntu.com/download/server">官网</a>或者<a href="https://ubuntu.mirror.garr.it/ubuntu-releases/18.04.6/">镜像网站</a>下载.iso镜像，这里选择稳定版server 18.04.6。</p>
<p>在ubuntu系统上推荐两种方法制作系统盘，一种是ubuntu自带的Startup Disk Creator，方法比较简单，直接选择镜像文件和启动盘，一键制作即可完成。另一种是一款免费的第三方启动盘制作工具Etcher，安装和使用方法如下：</p>
<p>1.在<a href="https://www.balena.io/etcher/">官网</a>找到下载链接，找到自己对应系统的AppImage下载；</p>
<p>2.unzip解压下载的zip文件；</p>
<p>3.运行<code>./xxxxx.AppImage</code>即可启动；</p>
<p>4.选择镜像，选择U盘，等待完成即可。</p>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>ubuntu基础环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu挂载磁盘</title>
    <url>/Ubuntu%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<p>引言：本文主要介绍ubuntu系统（包含desktop和server版本）挂载磁盘的方法，包括临时挂载和永久挂载。</p>
<span id="more"></span>
<h3 id="格式化磁盘">格式化磁盘</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkfs -t ext4 /dev/sdb</span><br></pre></td></tr></table></figure>
<p>-t ext4是将硬盘格式化为ext4文件系统类型。</p>
<h3 id="临时挂载">临时挂载</h3>
<p>一般情况下,我们想挂载一个分区的办法就是用mount命令,如我想把/dev/sda3挂载到/data下，使用以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/sda3 /data</span><br></pre></td></tr></table></figure>
<p>但这种方法有个不好的都方是机器<strong>重启后变又得手工重新挂载。</strong></p>
<h3 id="永久挂载">永久挂载</h3>
<p>永久性挂载分区的办法是修改分区文件/etc/fstab</p>
<p>常用磁盘命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看所有的磁盘：</span><br><span class="line">sudo fdisk -l</span><br><span class="line">2.查看某个磁盘的UUID和类型：</span><br><span class="line">sudo blkid &#x2F;dev&#x2F;sda3</span><br></pre></td></tr></table></figure>
<p><code>vim /etc/fstab</code>文件如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UUID=cec82a6a-c594-4bbd-b07a-af079cc670f2 /sdb ext4 defaults 0 0</span><br><span class="line">UUID=79abd6b3-c462-4fb3-9fc2-6b71eb0a8659 /sdc ext4 defaults 0 0</span><br><span class="line">UUID=bc28f3b0-bdbd-448f-b0d0-50cc499302d1 /sdd ext4 defaults 0 0</span><br><span class="line">UUID=63259855-0d99-4475-8b9d-6f19f93872b5 /sdf ext4 defaults 0 0</span><br></pre></td></tr></table></figure>
<p>各个字段含义如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UUID 	挂载点 	文件系统类型 		挂载参数 	是否备份 	是否检测</span><br></pre></td></tr></table></figure>
<p>保存后，需要重启或者执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure>
<p>才能生效。</p>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>基础环境</tag>
        <tag>磁盘挂载</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装docker</title>
    <url>/Ubuntu%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<p>引言：本文主要介绍在ubuntu上安装docker的方法。</p>
<span id="more"></span>
<h3 id="docker安装">docker安装</h3>
<p>1.（可选）更换国内镜像源，推荐清华源或中科大源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i &#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>2.安装需要的依赖包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br></pre></td></tr></table></figure>
<p>3.添加GPG密钥，需指定源（采用中科大源，采用默认的源下载速度慢，经常失败）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure>
<p>4.更新软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>5.安装docker-ce</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure>
<p>6.测试docker安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<h3 id="nvidia-container-runtime安装">nvidia-container-runtime安装</h3>
<p>docker19.03之后建议使用nvidia-container-runtime取代nvidia-docker2。</p>
<p>1.添加GPG密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-container-runtime&#x2F;gpgkey | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>2.添加源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br></pre></td></tr></table></figure>
<p>3.更新软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>4.安装nvidia-container-runtime</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nvidia-container-runtime</span><br></pre></td></tr></table></figure>
<p>5.设置默认运行时</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在/etc/docker/daemon.json中写入以下内容:</span><br><span class="line">&#123;</span><br><span class="line">&quot;default-runtime&quot;: &quot;nvidia&quot;,</span><br><span class="line">    &quot;runtimes&quot;: &#123;</span><br><span class="line">        &quot;nvidia&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.重启docker服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>7.验证安装成功（出现显卡信息）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --rm nvidia/cuda:10.0-base nvidia-smi</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>基础环境</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch学习笔记：transforms中的方法</title>
    <url>/PyTorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Atransforms%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>引言 ：torchvision.transforms是pytorch中的图像预处理包，包含了很多种对图像数据进行变换的函数，这些都是在我们进行图像数据读入步骤中必不可少的。</p>
<span id="more"></span>
<h3 id="1-综述">1.综述</h3>
<p>transforms中的方法可以归纳为四大类：</p>
<ul>
<li>
<p>裁剪：</p>
<p>中心裁剪：<code>transforms.CenterCrop</code><br>
随机裁剪：<code>transforms.RandomCrop</code><br>
随机长宽比裁剪：<code>transforms.RandomResizedCrop</code><br>
上下左右中心裁剪：<code>transforms.FiveCrop</code><br>
上下左右中心裁剪后翻转：<code>transforms.TenCrop</code></p>
</li>
<li>
<p>翻转和旋转：</p>
<p>依概率p水平翻转：<code>transforms.RandomHorizontalFlip</code><br>
依概率p垂直翻转：<code>transforms.RandomVerticalFlip</code><br>
随机翻转：<code>transforms.RandomRotation</code></p>
</li>
<li>
<p>图像变换：</p>
<p>resize：<code>transforms.Resize</code><br>
标准化：<code>transforms.Normalize</code><br>
转tensor并归一化：<code>transforms.ToTensor</code><br>
填充：<code>transforms.Pad</code><br>
修改亮度、对比度、饱和度：<code>transforms.ColorTitter</code><br>
转灰度图：<code>transforms.Grayscale</code><br>
线性变换：<code>transforms.LinearTransformation</code><br>
仿射变换：<code>transforms.RandomAffine</code><br>
依概率p转为灰度图：<code>transforms.RandomGrayscale</code><br>
将数据转换为PILImage：<code>transforms.ToPILImage</code><br>
依自定义的lambda函数变换：<code>transforms.Lambda</code></p>
</li>
<li>
<p>对transforms操作，使数据增强更灵活：</p>
<p>选择一个transforms进行操作：<code>transforms.RandomChoice(transforms)</code><br>
给一个transforms加上概率，依概率进行操作：<code>transforms.RandomApply(transforms,p=0.5)</code><br>
将transforms中的操作随机打乱：<code>transforms.RandomOrder</code></p>
</li>
</ul>
<h3 id="2-裁剪">2.裁剪</h3>
<p><strong>1.中心裁剪</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.CenterCrop(size) </span><br></pre></td></tr></table></figure>
<p><code>size</code>：为sequence或者int，若为sequence，则为(h，w)，若为int，则进行正方形裁剪</p>
<p><strong>2.随机裁剪</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomCrop(size，padding = <span class="literal">None</span>，pad_if_needed = <span class="literal">False</span>，fill = <span class="number">0</span>，padding_mode =<span class="string">&#x27;constant&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>size</code>：为sequence或者int，若为sequence，则为(h，w)，若为int，则进行正方形裁剪</p>
<p><code>padding</code>：为sequence或者int，可选的，图像每个边上的填充，默认为None，即不填充。如果提供长度为4的序列，则它用于分别填充左，上，右，下边界。如果提供长度为2的序列，则分别用于填充左/右，上/下边界</p>
<p><code>pad_if_needed</code>：bool类型，如果小于所需大小，它将填充图像以避免引发异常</p>
<p><code>fill</code>：恒定填充的像素填充值。默认值为0.如果长度为3的元组，则分别用于填充R，G，B通道。仅当padding_mode为constant时才使用此值</p>
<p><code>padding_mode</code>：填充类型，可选：constant，edge，reflect，symmetric。constant是填充指定像素值，edge是填充边缘像素值，reflect是反射填充，比如用2个元素填充[1,2,3,4]为[3,2,1,2,3,4,3,2]，symmetric是对称填充，比如用2个像素填充[1,2,3,4]为[2,1,1,2,3,4,4,3]</p>
<p><strong>3.随机长宽比裁剪</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomResizedCrop(size, scale=(<span class="number">0.08</span>, <span class="number">1.0</span>), ratio=(<span class="number">0.75</span>, <span class="number">1.3333333333333333</span>), interpolation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>将给定的PIL图像随机大小和宽高比裁剪，最后resize到指定大小</p>
<p><code>size</code>：输出大小</p>
<p><code>scale</code>：裁剪的原始尺寸的大小范围</p>
<p><code>ratio</code>：裁剪的原始宽高比的宽高比范围</p>
<p><code>interpolation</code>：resize的插值方式，默认为BILINEAR</p>
<p><strong>4.上下左右中心裁剪</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.FiveCrop(size)</span><br></pre></td></tr></table></figure>
<p>对图片进行上下左右以及中心裁剪，获得5张图片，返回一个4D-tensor</p>
<p><code>size</code>： sequence或者int，若为sequence,则为(h,w)，若为int，则为正方形</p>
<p><strong>5.上下左右中心裁剪后翻转</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.TenCrop(size, vertical_flip=<span class="literal">False</span>) </span><br></pre></td></tr></table></figure>
<p>对图片进行上下左右以及中心裁剪，返回裁剪得到的5张图像加上5张翻转图像共10张图像（默认水平翻转）</p>
<p><code>size</code>：sequence或者int，若为sequence,则为(h,w)，若为int，则为正方形</p>
<p><code>vertical_flip</code>：bool类型，使用垂直翻转而不是水平翻转</p>
<h3 id="3-翻转和旋转">3.翻转和旋转</h3>
<p><strong>6.依概率p水平翻转</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>以给定的概率随机水平翻转给定的PIL图像</p>
<p><code>p</code>：图像被翻转的概率，默认为0.5</p>
<p><strong>7.依概率p垂直翻转</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomVerticalFlip(p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>以给定的概率随机垂直翻转给定的PIL图像</p>
<p><code>p</code>：图像被翻转的概率，默认为0.5</p>
<p><strong>8.随机旋转</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomRotation(degrees, resample=<span class="literal">False</span>, expand=<span class="literal">False</span>, center=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>按角度旋转图像</p>
<p><code>degrees</code>：sequence 或float或int，要选择的度数范围。如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+ degrees）</p>
<p><code>resample</code>：插值方式</p>
<p><code>expand</code>：可选的扩展标志。如果为true，则展开输出以使其足够大以容纳整个旋转图像。如果为false或省略，则使输出图像与输入图像的大小相同。</p>
<p><code>center</code>：2元tuple，可选的旋转中心。原点是左上角。默认值是图像的中心。</p>
<h3 id="4-图像变换">4.图像变换</h3>
<p><strong>9.resize</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Resize(size, interpolation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>将输入PIL图像的大小调整为给定大小。</p>
<p><code>size</code>：sequence 或int，所需的输出大小。如果size是类似（h，w）的序列，则输出大小将与此匹配。如果size是int，则<strong>图像的较小边缘将与此数字匹配。即，如果高度&gt;宽度，则图像将重新缩放为（尺寸*高度/宽度，尺寸）</strong></p>
<p><code>interpolation</code>：插值方式，默认为BILINEAR</p>
<p><strong>10.标准化</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Normalize(mean, std)</span><br></pre></td></tr></table></figure>
<p>用平均值和标准差归一化张量图像。给定mean：(M1,…,Mn)和std：(S1,…,Sn)对于n通道，此变换将标准化输入的每个通道</p>
<p><code>mean</code>：sequence，每个通道的均值序列</p>
<p><code>std</code>：sequence，每个通道的标准差序列</p>
<p><strong>11.转tensor并归一化</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.ToTensor</span><br></pre></td></tr></table></figure>
<p>将PIL Image或者 ndarray 转换为tensor，并且归一化至[0-1]。<strong>若自己的ndarray数据尺度有变化，则需要自行修改。</strong></p>
<p><strong>12.填充</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Pad(padding, fill=<span class="number">0</span>, padding_mode=<span class="string">&#x27;constant&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>padding</code>：为sequence或者int，可选的，图像每个边上的填充，默认为None，即不填充。如果提供长度为4的序列，则它用于分别填充左，上，右，下边界。如果提供长度为2的序列，则分别用于填充左/右，上/下边界</p>
<p><code>fill</code>：恒定填充的像素填充值。默认值为0.如果长度为3的元组，则分别用于填充R，G，B通道。仅当padding_mode为constant时才使用此值</p>
<p><code>padding_mode</code>：填充类型，可选：constant，edge，reflect，symmetric。constant是填充指定像素值，edge是填充边缘像素值，reflect是反射填充，比如用2个元素填充[1,2,3,4]为[3,2,1,2,3,4,3,2]，symmetric是对称填充，比如用2个像素填充[1,2,3,4]为[2,1,1,2,3,4,4,3]</p>
<p><strong>13.修改亮度、对比度和饱和度</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.ColorJitter(brightness=<span class="number">0</span>, contrast=<span class="number">0</span>, saturation=<span class="number">0</span>, hue=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>brightness</code>： float或者元组，从该范围内随机选择brightness_factor</p>
<p><code>contrast</code>：float或者元组，从该范围内随机选择contrast_factor</p>
<p><code>saturation</code>：float或者元组，从该范围内随机选择saturation_factor</p>
<p><code>hue</code>：float或者元组，从该范围内随机选择hue_factor</p>
<p><strong>14.转灰度图</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Grayscale(num_output_channels=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>num_output_channels</code>：当为1时，正常的灰度图，当为3时，r == g == b的图像</p>
<p><strong>15.线性变换</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.LinearTransformation(transformation_matrix) </span><br></pre></td></tr></table></figure>
<p>用一个转换矩阵和一个离线计算出的均值向量将图片进行转换。给定转换矩阵transformation_matrix后,会将torch.*Tensor平铺并按位减mean_vector之后与转换矩阵做点积（dot product）运算，最后将shape转换成原始尺寸</p>
<p><strong>16.仿射变换</strong></p>
<p>图像保持中心不变的随机仿射变换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomAffine(degrees, translate=<span class="literal">None</span>, scale=<span class="literal">None</span>, shear=<span class="literal">None</span>, resample=<span class="literal">False</span>, fillcolor=<span class="number">0</span>) </span><br></pre></td></tr></table></figure>
<p><code>degrees</code>：sequence或float或int，要选择的度数范围。如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+degrees）。设置为0可停用旋转</p>
<p><code>translate</code>：元组，可选。水平和垂直平移的最大绝对分数元组。例如translate =（a，b），然后在范围-img_width * a &lt;dx &lt;img_width * a中随机采样水平移位，并且在-img_height * b &lt;dy &lt;img_height * b范围内随机采样垂直移位。默认情况下不会平移</p>
<p><code>scale</code>：元组，可选。缩放因子间隔，例如（a，b），然后从范围a &lt;= scale &lt;= b中随机采样缩放。默认情况下会保持原始比例</p>
<p><code>shear</code>：sequence 或float或int，可选，错切角度范围， 如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+ degrees）。默认情况下不会应用错切</p>
<p><code>resample</code>：插值方式，默认为BILINEAR</p>
<p><code>fillcolor</code>：输出图像中变换外部区域的可选填充颜色</p>
<p><strong>17.依概率p转为灰度图</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomGrayscale(p=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p>依概率p将图片转换为灰度图，若通道数为3，则输出r == g == b的图像</p>
<p><strong>18.将数据转换为PILImage</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.ToPILImage()</span><br></pre></td></tr></table></figure>
<p>将tensor 或者 ndarray的数据转换为 PIL Image 类型数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：对于一个Tensor的转化过程是</span><br><span class="line">1.将张量的每个元素乘上255</span><br><span class="line">2.将张量的数据类型由FloatTensor转化成Uint8</span><br><span class="line">3.将张量转化成numpy的ndarray类型</span><br><span class="line">4.对ndarray对象做permute (1, 2, 0)的操作</span><br><span class="line">5.利用Image下的fromarray函数，将ndarray对象转化成PILImage形式</span><br><span class="line">6.输出PILImage</span><br></pre></td></tr></table></figure>
<p><strong>19.依自定义的lambda函数变换</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Lambda（<span class="keyword">lambda</span>）</span><br></pre></td></tr></table></figure>
<p>将用户定义的lambda应用为变换。</p>
<p><code>lambda</code>：用于转换的Lambda函数</p>
<h3 id="5-对transforms操作，使数据增强更灵活">5.对transforms操作，使数据增强更灵活</h3>
<p><strong>20.选择一个transforms进行操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomChoice(transforms)</span><br></pre></td></tr></table></figure>
<p>从给定的一系列transforms中选一个进行操作</p>
<p><strong>21.给一个transform加上概率，以一定的概率执行该操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomApply(transforms, p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p><code>transforms</code>：列表或元组，要操作的transforms列表</p>
<p><code>p</code>：概率</p>
<p><strong>22.将transforms中的操作随机打乱</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomOrder(transforms)</span><br></pre></td></tr></table></figure>
<p><code>transforms</code>：列表或元组，要操作的transforms列表</p>
<h3 id="6-Compose操作">6.Compose操作</h3>
<p>将一系列操作组合在一起，按顺序执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Compose(transforms)</span><br></pre></td></tr></table></figure>
<p><code>transforms</code>：要组合的transforms列表</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), std = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="7-总结">7.总结</h3>
<p>上面所述transforms方法中，只有少部分是经常用到的，熟练掌握经常用到的即可。</p>
]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>torchvision.transforms</tag>
        <tag>图像预处理函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu私有仓库UI服务部署</title>
    <url>/Ubuntu%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93UI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>引言：本文主要介绍利用第三方镜像部署docker私有仓库可视化界面服务的方法。</p>
<span id="more"></span>
<h3 id="方法一">方法一</h3>
<p>1.从官方仓库拉取第三方镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure>
<p>2.启动UI服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -itd -p 60022:80 --restart=always --name=docker-registry-ui -e SINGLE_REGISTRY=true -e REGISTRY_TITLE=&quot;xxxxxxxx registry&quot; -e SHOW_CONTENT_DIGEST=true -e DELETE_IMAGES=true -e NGINX_PROXY_PASS_URL=&quot;http://10.10.8.185:5000&quot; joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure>
<p><strong>注意：这些环境变量一个也不能错</strong></p>
<p>3.访问http://10.10.8.185:60022可以登录UI界面。</p>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>多传感器时间同步机制</title>
    <url>/ros%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>引言：多传感器时间同步是高级辅助驾驶系统和自动驾驶中必不可少的关键步骤，本文主要介绍一种多传感器时间同步的方法，并进行了C++实现。</p>
<span id="more"></span>
<h3 id="介绍">介绍</h3>
<p>多传感器时间同步就是把不同传感器发出的message序列在时间上进行匹配，比如有多个激光雷达，多个摄像头，多个radar，以及组合惯导等传感器，在系统启动后，这些传感器都在以一定的频率往外部发送消息，那么某一时刻而言，究竟取这些传感器的哪一个消息，才是同一时刻的呢？这些传感器的频率可能不同，但是每一帧消息应该都有一个时间戳，代表这个消息是哪个时间产生的，比如一共有20个传感器，同步好的代表当前的所有消息应该也是20帧，他们之间的时间戳应该一致，但是由于频率不一致，所以很难保证具有完全相同的时间戳，所以退而求其次，可以在一定的时间范围内认为这20个消息是同步的，他们应该满足一个条件，就是不应该存在另一个选择，使得这20个消息的时间跨度（最早时间和最晚时间之差）小于当前的时间跨度，这样才认为这个同步是正确的，ros实现了这种时间同步的方法，下面将对其使用方法和原理进行详细说明，由于该算法比较绕，考虑的情况也比较多，个人也只是一知半解。</p>
<h3 id="使用方法">使用方法</h3>
<p>下面是一个4个激光雷达产生的点云消息和1个组合惯导产生的pose消息，其中雷达发出的点云消息为10hz，惯导产生的pose消息为100hz。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/subscriber.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/synchronizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/sync_policies/approximate_time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg0,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg1,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg2,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg3,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> geometry_msgs::PoseStampedConstPtr &amp;msg4)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; <span class="string">&quot;/back_lidar: &quot;</span> &lt;&lt; msg3-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/left_lidar: &quot;</span> &lt;&lt; msg1-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/middle_lidar: &quot;</span> &lt;&lt; msg0-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/pose_stamp: &quot;</span> &lt;&lt; msg4-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/right_lidar: &quot;</span> &lt;&lt; msg2-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl;</span><br><span class="line">                            </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------------------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;ros_sync_test&quot;</span>);</span><br><span class="line">    ros::NodeHandlePtr node_ptr;</span><br><span class="line">    node_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> ros::NodeHandle);</span><br><span class="line"></span><br><span class="line">    std::string topic0, topic1, topic2, topic3, topic4;</span><br><span class="line">    topic0 = <span class="string">&quot;/mems_front/rslidar_points&quot;</span>;</span><br><span class="line">    topic1 = <span class="string">&quot;/mems_left/rslidar_points&quot;</span>;</span><br><span class="line">    topic2 = <span class="string">&quot;/mems_right/rslidar_points&quot;</span>;</span><br><span class="line">    topic3 = <span class="string">&quot;/mems_back/rslidar_points&quot;</span>;</span><br><span class="line">    topic4 = <span class="string">&quot;/loc/car_pose_1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic0</span><span class="params">(*node_ptr, topic0, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic1</span><span class="params">(*node_ptr, topic1, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic2</span><span class="params">(*node_ptr, topic2, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic3</span><span class="params">(*node_ptr, topic3, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt; <span class="title">sub_topic4</span><span class="params">(*node_ptr, topic4, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> message_filters::sync_policies::ApproximateTime&lt;sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            geometry_msgs::PoseStamped&gt; syncPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function">message_filters::Synchronizer&lt;syncPolicy&gt; <span class="title">sync</span><span class="params">(syncPolicy(<span class="number">100</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic3,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic4)</span></span>;</span><br><span class="line"></span><br><span class="line">    sync.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;callback, _1, _2, _3, _4, _5));</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>syncPolicy(100)中的100是每个消息队列的最大长度，如果某个消息队列缓存长度大于100（即连续100个消息还没有同步上），就会产生问题，所以这个尽可能设置的大一些。</p>
<h3 id="算法实现">算法实现</h3>
<p>ros规定这种时间同步机制最多支持9个不同的消息，下面在不改变算法原理的基础上进行了异步实现，且不限制同步的消息个数。</p>
<p><a href="https://github.com/zsh4614/time_sync">github代码链接</a></p>
]]></content>
      <categories>
        <category>ADAS和自动驾驶</category>
      </categories>
      <tags>
        <tag>时间同步</tag>
      </tags>
  </entry>
  <entry>
    <title>个人主页</title>
    <url>/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 密码错误, 请联系翟少华获取密码." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9345f896d37b9f5e2abf07cc2119690b0e471c839e507e20a27ee4e54a5d9fbf">518e54c91656481a908483089544e9165d5d3967b07fc15a6a03d2b43aa7874a07b7ad9973e03ffb04e093a7e4f51cd1a0d7eefaba3ff3ae23ee18e70f504d445e25643067bd41745f781595f666d10a0bb2348c890c7bb510da1604b342d0cb53f621b8622fd1dfc0875d772f114618fc9acc2feac2d3fd4c52ad023ede8bf8aea6169152d090235ecf3d93aafcc9a8090e4fd32a560c637199c40cd3b511afee5ccbf6619ad2e8bd7ba45feb855ed6158b6beffa62dac690ed11a4f966ea0a25a680f827c5fe72ba26adc6464a70c7e2d656ccc5bac89fcaeb0fe97e0d42828050b9fc752029f485aa9acfa02619096854b580f3fa04c2ad4fa55d389ebe2b44423c76b684444988916965cf1925e3bb2f690c6062ce3edab2e185066d543b08f0997983205d4e7d73cdc27b756d625087fea6e7fa14e8108ec119f16de65decf066a5b9db4b3d8bb0dbe7d07d7e1158d558786820c8f0f64424e0cc787306523414e00edbbae22e559b1e5c7079977099c4cc88df877752b8f91559c7469ebcca2a9cd9b4488c84ffe287bee3597608f294f2491307ecf935b735a7668ddcc62ce83162866dc84ac50969c91a073193bcd855f06ef23a65e0e4887dc249c1345752940a222e8d71acad0e25684e9fc3492515c4576d1479a33fc62e057133</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-up">
      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-up">您好, 请单击此处输入本文密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>外部资源</category>
      </categories>
  </entry>
  <entry>
    <title>搭建私有镜像仓库</title>
    <url>/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>引言：本文主要介绍如何docker私有仓库，在公司中使用，避免商业项目暴露出去的风险。</p>
<span id="more"></span>
<h3 id="背景">背景</h3>
<p>在docker中，当我们执行docker pull xxx的时候，可能会比较好奇，docker会去哪查找并下载镜像呢？它实际上是从 <a href="http://registry.hub.docker.com">registry.hub.docker.com</a> 这个地址去查找，这就是Docker公司为我们提供的公共仓库，上面的镜像，大家都可以看到，也可以使用。所以，我们也可以带上仓库地址去拉取镜像，如：docker pull <a href="http://registry.hub.docker.com/library/alpine%EF%BC%8C">registry.hub.docker.com/library/alpine，</a> 不过要注意，这种方式下载的镜像的默认名称就会长一些。如果要在公司中使用Docker，我们基本不可能把商业项目上传到公共仓库中，那如果要多个机器共享，又能怎么办呢？</p>
<p>正因为这种需要，所以私有仓库也就有用武之地了。</p>
<p>所谓私有仓库，也就是在本地（局域网）搭建的一个类似公共仓库的东西，搭建好之后，我们可以将镜像提交到私有仓库中。这样我们既能使用 Docker 来运行我们的项目镜像，也避免了商业项目暴露出去的风险。</p>
<p>下面我们用官方提供的registry镜像来搭建私有镜像仓库，当然还有其它很多方法。</p>
<h3 id="环境">环境</h3>
<p>准备两台安装好docker的服务器：<br>
服务端机器 （主机名为registry）：docker私有仓库服务器，运行registry容器；<br>
测试端机器 （主机名为node）：普通的docker服务器，在这台服务器上下载一个测试镜像busybox，然后上传到registry服务器进行测试；</p>
<p>假设服务器ip（内网ip）是10.18.133.2</p>
<h3 id="部署（服务端操作）">部署（服务端操作）</h3>
<h4 id="下载镜像registry">下载镜像registry</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@registry ~]# sudo docker pull registry</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">81033e7c1d6a: Pull complete </span><br><span class="line">b235084c2315: Pull complete </span><br><span class="line">c692f3a6894b: Pull complete </span><br><span class="line">ba2177f3a70e: Pull complete </span><br><span class="line">a8d793620947: Pull complete </span><br><span class="line">Digest: sha256:672d519d7fd7bbc7a448d17956ebeefe225d5eb27509d8dc5ce67ecb4a0bce54</span><br><span class="line">Status: Downloaded newer image for registry:latest</span><br></pre></td></tr></table></figure>
<h4 id="查看镜像是否pull下来了">查看镜像是否pull下来了</h4>
<p><img src="https://i.loli.net/2021/05/12/OteNH8Mgj1GlU7D.png" alt="180310200921851.png"></p>
<h4 id="运行registry容器">运行registry容器</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@registry ~]# sudo docker run -itd -v /data/registry:/var/lib/registry -p 5000:5000 --restart=always -e REGISTRY_STORAGE_DELETE_ENABLED=true --name registry registry:latest </span><br><span class="line">06a972de6218b1f1c3bf9b53eb9068dc66d147d14e18a89ab51db13e339d3dc9</span><br></pre></td></tr></table></figure>
<p>参数说明<br>
-itd：在容器中打开一个伪终端进行交互操作，并在后台运行；<br>
-v：把宿主机的/data/registry目录绑定 到 容器/var/lib/registry目录(这个目录是registry容器中存放镜像文件的目录)，来实现数据的持久化；<br>
-p：映射端口；访问宿主机的5000端口就访问到registry容器的服务了；<br>
–restart=always：这是重启的策略，假如这个容器异常退出会自动重启容器；<br>
–name registry：创建容器命名为registry，你可以随便命名；<br>
registry:latest：这个是刚才pull下来的镜像；<br>
-e REGISTRY_STORAGE_DELETE_ENABLED=true，允许删除仓库中的镜像；</p>
<h4 id="测试镜像仓库中所有的镜像">测试镜像仓库中所有的镜像</h4>
<p>[root@registry ~]# curl <a href="http://10.18.133.2:5000/v2/_catalog">http://10.18.133.2:5000/v2/_catalog</a><br>
{“repositories”:[]}</p>
<p>现在是空的，因为才刚运行，里面没有任何镜像内容。</p>
<h3 id="测试镜像仓库（测试端操作）">测试镜像仓库（测试端操作）</h3>
<h4 id="修改镜像源并重启docker服务">修改镜像源并重启docker服务</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node ~]# vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [ &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]，</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;10.18.133.2:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>
<h4 id="从官方仓库下载busybox镜像">从官方仓库下载busybox镜像</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node ~]# docker pull busybox</span><br><span class="line">[root@node ~]# docker images</span><br><span class="line">REPOSITORY          TAG                IMAGE ID            CREATED            SIZE</span><br><span class="line">busybox            latest              f6e427c148a7        36 hours ago        1.15MB</span><br></pre></td></tr></table></figure>
<h4 id="为镜像打标签">为镜像打标签</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node ~]# docker tag busybox:latest 10.18.133.2:5000/busybox:v1</span><br></pre></td></tr></table></figure>
<p>busybox:lastest 这是源镜像，也是刚才pull下来的镜像文件；<br>
10.18.133.2:500/busybox:v1：这是目标镜像，也是registry私有镜像服务器的IP地址和端口；</p>
<p>查看一下打好的tag：</p>
<p><img src="https://i.loli.net/2021/05/12/Iba8UejM3LrqntV.png" alt="180310200921852.png"></p>
<h4 id="上传到私有镜像仓库">上传到私有镜像仓库</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node ~]# docker push 10.18.133.2:5000/busybox:v1 </span><br><span class="line">The push refers to repository [10.18.133.2:5000/busybox]</span><br><span class="line">c5183829c43c: Pushed </span><br><span class="line">v1: digest: sha256:c7b0a24019b0e6eda714ec0fa137ad42bc44a754d9cea17d14fba3a80ccc1ee4 size: 527</span><br></pre></td></tr></table></figure>
<h4 id="测试下载镜像">测试下载镜像</h4>
<p>上传测试没问题了，我们接下来测试一下从registry服务器上下载刚才上传的busybox镜像，先删除node主机上的镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node ~]# docker rmi f6e427c148a7</span><br></pre></td></tr></table></figure>
<p>(注意如果此处报错image is being used by stopped container，说明该镜像被某个容器使用，先删掉这个容器，docker ps -a查看使用这个镜像的容器，然后docker rm -f 容器id)</p>
<p>然后，从registry服务器上下载busybox镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node ~]# docker pull 10.18.133.2:5000&#x2F;busybox:v1</span><br><span class="line">v1: Pulling from busybox</span><br><span class="line">d070b8ef96fc: Pull complete </span><br><span class="line">Digest: sha256:c7b0a24019b0e6eda714ec0fa137ad42bc44a754d9cea17d14fba3a80ccc1ee4</span><br><span class="line">Status: Downloaded newer image for 10.18.133.2:5000&#x2F;busybox:v1</span><br><span class="line">[root@node ~]# docker images</span><br><span class="line">REPOSITORY                  TAG                IMAGE ID            CREATED            SIZE</span><br><span class="line">172.18.18.90:5000&#x2F;busybox  v1                  f6e427c148a7        36 hours ago        1.15MB</span><br></pre></td></tr></table></figure>
<p>列出所有镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node ~]# curl  http://10.18.133.2:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;busybox&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>列出busybox镜像有哪些tag：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node ~]# curl  http://10.18.133.2:5000/v2/busybox/tags/list</span><br><span class="line">&#123;&quot;name&quot;:&quot;busybox&quot;,&quot;tags&quot;:[&quot;v1&quot;]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题解答">问题解答</h3>
<p>1.当上传镜像时会出现上传失败<code>Get https://10.10.8.185:5000/v2/: http: server gave HTTP response to HTTPS client</code></p>
<p>这是因为Docker与Docker Registry交互默认使用https，然而此处搭建的Docker Registry只提供http服务，所以当和Registry私有仓库交互时会失败，为了解决这个问题需要在启动Docker时配置Registry不安全选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;insecure-registries&quot;:[&quot;10.10.8.185:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>sudo systemctl restart docker</code>重启docker服务即可。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>私有镜像仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构及实现：二叉查找树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<p>引言：二叉查找树的C++实现代码，并进行了测试。</p>
<span id="more"></span>
<h3 id="二叉查找树简介">二叉查找树简介</h3>
<p>二叉查找树(Binary Search Tree)，又被称为二叉搜索树。它是特殊的二叉树：对于二叉树，假设x为二叉树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。那么，这棵树就是二叉查找树。如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/20/Ddq61aksuTCjpWK.jpg" alt="二叉查找树.jpg"></p>
<p>在二叉查找树中：</p>
<p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>
（2）任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>
（3）任意节点的左、右子树也分别为二叉查找树；<br>
（4）没有key值相等的节点。</p>
<h3 id="二叉查找树的C-实现">二叉查找树的C++实现</h3>
<h4 id="节点和二叉查找树的定义">节点和二叉查找树的定义</h4>
<h5 id="二叉查找树节点">二叉查找树节点</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T key;	<span class="comment">// 关键字（键值）</span></span><br><span class="line">    BSTNode* left; <span class="comment">// 左孩子</span></span><br><span class="line">    BSTNode* right;	<span class="comment">// 右孩子</span></span><br><span class="line">    BSTNode* parent;	<span class="comment">// 父节点</span></span><br><span class="line">    <span class="built_in">BSTNode</span>(T value, BSTNode *p, BSTNode *l, BSTNode *r):</span><br><span class="line">    	<span class="built_in">key</span>(value),<span class="built_in">parent</span>(p),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BSTNode是二叉查找树的节点，它包含二叉查找树的几个基本信息：</p>
<p>（1）key – 它是关键字，是用来对二叉查找树的节点进行排序的；<br>
（2）left – 它指向当前节点的左孩子；<br>
（3）right – 它指向当前节点的右孩子；<br>
（4）parent – 它指向当前节点的父结点。</p>
<h5 id="二叉树操作">二叉树操作</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BSTNode&lt;T&gt;* mRoot;    <span class="comment">// 根结点</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTree</span>();</span><br><span class="line">    ~<span class="built_in">BSTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (递归实现)查找二叉树中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找二叉树中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回最小结点的键值</span></span><br><span class="line">    <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">    <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(z)插入到二叉树(tree)中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除二叉树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BSTree是二叉树。它包含二叉查找树的根节点和二叉查找树的操作。二叉查找树的操作中有许多重载函数，例如insert()函数，其中一个是内部接口，另一个是提供给外部的接口。</p>
<h4 id="遍历">遍历</h4>
<p>这里讲解前序遍历、中序遍历、后序遍历3种方式。</p>
<h5 id="前序遍历">前序遍历</h5>
<p>若二叉树非空，则执行以下操作：</p>
<p>（1）访问根结点；<br>
（2）先序遍历左子树；<br>
（3）先序遍历右子树。</p>
<p>前序遍历代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序遍历">中序遍历</h5>
<p>若二叉树非空，则执行以下操作：</p>
<p>（1）中序遍历左子树；<br>
（2）访问根结点；<br>
（3）中序遍历右子树。</p>
<p>中序遍历代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历">后序遍历</h5>
<p>若二叉树非空，则执行以下操作：</p>
<p>（1）后序遍历左子树；<br>
（2）后序遍历右子树；<br>
（3）访问根结点。</p>
<p>后序遍历代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看下面这颗树的各种遍历方式：</p>
<p><img src="https://i.loli.net/2021/04/22/yiEtOTcJC1bw8Wu.jpg" alt="二叉树遍历.jpg"></p>
<p>对于上面的二叉树而言，<br>
（1）前序遍历结果： 3 1 2 5 4 6<br>
（2）中序遍历结果： 1 2 3 4 5 6<br>
（3）后序遍历结果： 2 1 4 6 5 3</p>
<h4 id="查找">查找</h4>
<p>递归版本的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归版本的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大值和最小值">最大值和最小值</h4>
<p>查找最大值的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">maximum</span>(BSTNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">maximum</span>() &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找最小值的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">minimum</span>(BSTNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">minimum</span>() &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前驱和后继">前驱和后继</h4>
<p>节点的前驱：是该节点的左子树中的最大节点。<br>
节点的后继：是该节点的右子树中的最小节点。</p>
<p>查找前驱节点的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">predecessor</span>(BSTNode&lt;T&gt; *x) &#123;</span><br><span class="line">    <span class="comment">// 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maximum</span>(x-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;left)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找后继节点的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">successor</span>(BSTNode&lt;T&gt; *x) &#123;</span><br><span class="line">    <span class="comment">// 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(x-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;right)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入">插入</h4>
<p>插入节点的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)  &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(T key) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除">删除</h4>
<p>删除节点的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">remove</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *x=<span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *y=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == <span class="literal">NULL</span>) || (z-&gt;right == <span class="literal">NULL</span>) )</span><br><span class="line">        y = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = <span class="built_in">successor</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = y-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        tree = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left)</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z) </span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">remove</span>(T key) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z, *node; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> ( (node = <span class="built_in">remove</span>(mRoot, z)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印">打印</h4>
<p>打印二叉查找树的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值 </span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction) &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="销毁">销毁</h4>
<p>销毁二叉查找树的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>(BSTNode&lt;T&gt;* &amp;tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">    tree=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>() &#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树的C-实现（完整源码）">二叉查找树的C++实现（完整源码）</h3>
<p>二叉查找树的C++实现文件(BSTree.h)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BINARY_SEARCH_TREE_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BINARY_SEARCH_TREE_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T key;            <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode *parent;<span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">BSTNode</span>(T value, BSTNode *p, BSTNode *l, BSTNode *r):</span><br><span class="line">            <span class="built_in">key</span>(value),<span class="built_in">parent</span>(),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        BSTNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BSTree</span>();</span><br><span class="line">        ~<span class="built_in">BSTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;二叉树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;二叉树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line">        <span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到二叉树(tree)中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除二叉树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTree&lt;T&gt;::<span class="built_in">BSTree</span>():<span class="built_in">mRoot</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTree&lt;T&gt;::~<span class="built_in">BSTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">minimum</span>(BSTNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">minimum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">maximum</span>(BSTNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">maximum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">successor</span>(BSTNode&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(x-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;right))</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">predecessor</span>(BSTNode&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maximum</span>(x-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;left))</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">remove</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *x=<span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *y=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == <span class="literal">NULL</span>) || (z-&gt;right == <span class="literal">NULL</span>) )</span><br><span class="line">        y = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = <span class="built_in">successor</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = y-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        tree = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left)</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z)</span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z, *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> ( (node = <span class="built_in">remove</span>(mRoot, z)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>(BSTNode&lt;T&gt;* &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">    tree=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值</span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>关于二叉查找树的C++实现有两点需要补充说明的:<br>
第1点：采用了STL模板。因此，二叉查找树支持任意数据类型。<br>
<strong>第2点：将二叉查找树的&quot;声明&quot;和&quot;实现&quot;都位于BSTree.h中。这是因为，在二叉查找树的实现采用了模板；而C++编译器不支持对模板的分离式编译！</strong></p>
<h3 id="二叉查找树的C-测试程序">二叉查找树的C++测试程序</h3>
<p>二叉查找树的C++测试程序(BSTreeTest.cpp)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BSTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]= &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ilen;</span><br><span class="line">    BSTree&lt;<span class="keyword">int</span>&gt;* tree=<span class="keyword">new</span> BSTree&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 依次添加: &quot;</span>;</span><br><span class="line">    ilen = <span class="built_in">TBL_SIZE</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree-&gt;<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 前序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">preOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 后序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最小值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">minimum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最大值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">maximum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 删除根节点: &quot;</span> &lt;&lt; arr[<span class="number">3</span>];</span><br><span class="line">    tree-&gt;<span class="built_in">remove</span>(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    tree-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">== 依次添加: <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line">== 前序遍历: <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line">== 中序遍历: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line">== 后序遍历: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line">== 最小值: <span class="number">1</span></span><br><span class="line">== 最大值: <span class="number">6</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"> <span class="number">1</span> is root</span><br><span class="line"> <span class="number">5</span> is  <span class="number">1&#x27;</span>s  right child</span><br><span class="line"> <span class="number">4</span> is  <span class="number">5&#x27;</span>s   left child</span><br><span class="line"> <span class="number">3</span> is  <span class="number">4&#x27;</span>s   left child</span><br><span class="line"> <span class="number">2</span> is  <span class="number">3&#x27;</span>s   left child</span><br><span class="line"> <span class="number">6</span> is  <span class="number">5&#x27;</span>s  right child</span><br><span class="line">== 删除根节点: <span class="number">3</span></span><br><span class="line">== 中序遍历: <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>下面对测试程序的流程进行分析！</p>
<p>（1）新建&quot;二叉查找树&quot;root。</p>
<p>（2）向二叉查找树中依次插入1,5,4,3,2,6 。如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/23/FEi64SOw2lDA5Ye.jpg" alt="二叉树插入.jpg"></p>
<p>（3）遍历和查找，插入1,5,4,3,2,6之后，得到的二叉查找树如下：</p>
<p><img src="https://i.loli.net/2021/04/23/6TpIrWFCBYcxJKw.jpg" alt="二叉树插入结果.jpg"></p>
<p>​	前序遍历结果: <strong>1 5 4 3 2 6</strong><br>
​	中序遍历结果: <strong>1 2 3 4 5 6</strong><br>
​	后序遍历结果: <strong>2 3 4 6 5 1</strong><br>
​	最小值是1，而最大值是6。</p>
<p>（4）删除节点3。如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/23/8tqzVLSWJUEb4rX.jpg" alt="二叉树删除节点.jpg"></p>
<p>（5）重新遍历该二叉查找树。<br>
​	中序遍历结果: <strong>1 2 4 5 6</strong></p>
<h3 id="总结">总结</h3>
<p>二叉查找树的C++实现代码，并进行了测试。</p>
<blockquote>
<p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3576373.html">https://www.cnblogs.com/skywang12345/p/3576373.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构及实现</category>
      </categories>
      <tags>
        <tag>二叉查找树</tag>
        <tag>前序遍历</tag>
        <tag>前驱节点和后继节点</tag>
        <tag>递归和迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构及实现：二叉树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>引言：整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。</p>
<span id="more"></span>
<h3 id="1-树的定义">1.树的定义</h3>
<p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p>
<p><img src="https://i.loli.net/2021/04/19/jiL6wsCPZEWlOA3.jpg" alt="二叉树.jpg"></p>
<p>把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<p>(1) 每个节点有零个或多个子节点；<br>
(2)没有父节点的节点称为根节点；<br>
(3)每一个非根节点有且只有一个父节点；<br>
(4) 除了根节点外，每个子节点可以分为多个不相交的子树。</p>
<h3 id="2-树的基本术语">2.树的基本术语</h3>
<p>若一个结点有子树，那么该结点称为子树根的&quot;双亲&quot;，子树的根是该结点的&quot;孩子&quot;。有相同双亲的结点互为&quot;兄弟&quot;。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。</p>
<p><strong>结点的度</strong>：结点拥有的子树的数目。<br>
<strong>叶子</strong>：度为零的结点。<br>
<strong>分支结点</strong>：度不为零的结点。<br>
<strong>树的度</strong>：树中结点的最大的度。<br>
<strong>层次</strong>：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br>
<strong>树的高度</strong>：树中结点的最大层次。<br>
<strong>无序树</strong>：如果树中结点的各子树之间的次序是不重要的，可以交换位置。<br>
<strong>有序树</strong>：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。<br>
<strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</p>
<h3 id="3-二叉树的定义">3.二叉树的定义</h3>
<p>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</p>
<p><img src="https://i.loli.net/2021/04/19/hUJdVmo3Ln9H4GD.jpg" alt="二叉树2.jpg"></p>
<h3 id="4-二叉树的性质">4.二叉树的性质</h3>
<p>二叉树有以下几个性质：</p>
<p><strong>性质1</strong>：二叉树第i层上的结点数目最多为 2<sup>{i-1}</sup> (i≥1)。<br>
<strong>性质2</strong>：深度为k的二叉树至多有2<sup>{k}</sup>-1个结点(k≥1)。<br>
<strong>性质3</strong>：包含n个结点的二叉树的高度至少为log<sub>2</sub> (n+1)。<br>
<strong>性质4</strong>：在任意一棵二叉树中，若叶子结点的个数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</p>
<blockquote>
<p>注：性质4的证明<br>
因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=“0度结点数(n<sub>0</sub>)” + “1度结点数(n<sub>1</sub>)” + “2度结点数(n<sub>2</sub>)”。由此，得到 n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>；<br>
另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n<sub>1</sub>+2n<sub>2</sub>。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为n=n<sub>1</sub>+2n<sub>2</sub>+1，两式相等，可得。</p>
</blockquote>
<h3 id="5-满二叉树，完全二叉树和二叉查找树">5.满二叉树，完全二叉树和二叉查找树</h3>
<p><strong>满二叉树</strong>：高度为h，并且由2<sup>{h}</sup> –1个结点的二叉树，被称为满二叉树。</p>
<p><img src="https://i.loli.net/2021/04/20/uPBhqe7XQxT6wKU.jpg" alt="满二叉树.jpg"></p>
<p><strong>完全二叉树</strong>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p>
<p><img src="https://i.loli.net/2021/04/20/cdp2J1GUN87EvjS.jpg" alt="完全二叉树.jpg"></p>
<p><strong>二叉查找树</strong>：二叉查找树，又被称为<strong>二叉搜索树</strong>。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p>
<p><img src="https://i.loli.net/2021/04/20/Ddq61aksuTCjpWK.jpg" alt="二叉查找树.jpg"></p>
<p>在二叉查找树中：</p>
<p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>
（2）任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>
（3）任意节点的左、右子树也分别为二叉查找树；<br>
（4）没有key值相等的节点。</p>
<h3 id="6-总结">6.总结</h3>
<p>整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。</p>
<blockquote>
<p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3576328.html">https://www.cnblogs.com/skywang12345/p/3576328.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构及实现</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装nvidia显卡驱动</title>
    <url>/Ubuntu%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>引言：本文主要介绍在ubuntu系统上安装nvidia显卡驱动的方法，并优化驱动。</p>
<span id="more"></span>
<h3 id="安装显卡驱动">安装显卡驱动</h3>
<h4 id="方法一：ppa源">方法一：ppa源</h4>
<p>1.安装PPA源，根据提示按Enter执行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br></pre></td></tr></table></figure>
<p>2.更新源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update </span><br></pre></td></tr></table></figure>
<p>3.安装显卡驱动工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ubuntu-drivers-common</span><br></pre></td></tr></table></figure>
<p>4.查看可以安装的显卡驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu-drivers devices </span><br></pre></td></tr></table></figure>
<p>5.选择推荐的驱动进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nvidia-driver-470</span><br></pre></td></tr></table></figure>
<p>6.重启生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h3 id="开启持久模式">开启持久模式</h3>
<p><code>-pm --persistence-mode</code></p>
<p>启用持久性模式后，即使没有活动的客户端 (such as X11 or nvidia-smi)，NVIDIA 驱动程序也会保持加载状态。这样可以最大程度地减少与运行依赖的应用程序 (例如 CUDA 程序) 相关的驱动程序加载延迟。适用于所有支持 CUDA 的产品。**persistence mode 持久模式默认关闭。persistence mode 能够让 GPU 更快响应任务，待机功耗增加。关闭 persistence mode 同样能够启动任务。开机默认为关闭。**开启后可解决GPU初始化缓慢、无任务运行但是利用率居高不下、偶尔丢卡等问题。（不担心功耗的情况下尽量开启）</p>
<p>在<strong>18.04</strong>上设置开机默认开启的方法：</p>
<p>1.<code>/lib/systemd/system/rc-local.service</code>文件新增以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=rc-local.service</span><br></pre></td></tr></table></figure>
<p>2.设置rc-local开机自启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable rc-local</span><br></pre></td></tr></table></figure>
<p>3.在<code>/etc/rc.local</code>中填入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">nvidia-smi -pm 1</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>4.赋予可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure>
<p>5.测试是否成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重启之后nvidia-smi看Persistence-M的状态为On，则配置成功。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Deploy</category>
      </categories>
      <tags>
        <tag>基础环境</tag>
        <tag>显卡驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构及实现：数组和链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>引言：线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表；随后给出双向链表C++的实现。</p>
<span id="more"></span>
<h3 id="数组">数组</h3>
<p>数组有上界和下界，数组的元素在上下界内是连续的。</p>
<p>存储10,20,30,40,50的数组的示意图如下：</p>
<p><img src="https://i.loli.net/2021/05/18/Klmj2bxLcHB3FNA.jpg" alt="231243264043298.jpg"></p>
<p>数组的特点是：<strong>数据是连续的；随机访问速度快。</strong></p>
<p>数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了<strong>Vector</strong>；</p>
<h3 id="单向链表">单向链表</h3>
<p>单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。</p>
<p>单链表的示意图如下：</p>
<p><img src="https://i.loli.net/2021/05/18/bPtqAMNe76wlFjO.jpg" alt="单链表.jpg"></p>
<p>表头为空，表头的后继节点是&quot;节点10&quot;(数据为10的节点)，“节点10&quot;的后继节点是&quot;节点20”(数据为10的节点)，…</p>
<h4 id="单链表删除节点">单链表删除节点</h4>
<p><img src="https://i.loli.net/2021/05/18/IbHdyTAaxPgZqoF.jpg" alt="删除节点.jpg"></p>
<p>删除&quot;节点30&quot;<br>
删除之前：“节点20” 的后继节点为&quot;节点30&quot;，而&quot;节点30&quot; 的后继节点为&quot;节点40&quot;。<br>
删除之后：“节点20” 的后继节点为&quot;节点40&quot;。</p>
<h4 id="单链表添加节点">单链表添加节点</h4>
<p><img src="https://i.loli.net/2021/05/18/yJx3m5GUtiqV9XK.jpg" alt="添加节点.jpg"></p>
<p>在&quot;节点10&quot;与&quot;节点20&quot;之间添加&quot;节点15&quot;<br>
添加之前：“节点10” 的后继节点为&quot;节点20&quot;。<br>
添加之后：“节点10” 的后继节点为&quot;节点15&quot;，而&quot;节点15&quot; 的后继节点为&quot;节点20&quot;。</p>
<p>单链表的特点是：节点的链接方向是单向的；<strong>相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</strong></p>
<h3 id="双向链表">双向链表</h3>
<p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p>
<p>双链表的示意图如下：</p>
<p><img src="https://i.loli.net/2021/05/18/CeNdqmtyGZjSiUr.jpg" alt="双链表.jpg"></p>
<p>表头为空，表头的后继节点为&quot;节点10&quot;(数据为10的节点)；“节点10&quot;的后继节点是&quot;节点20”(数据为10的节点)，“节点20&quot;的前继节点是&quot;节点10”；“节点20&quot;的后继节点是&quot;节点30”，“节点30&quot;的前继节点是&quot;节点20”；…；末尾节点的后继节点是表头。</p>
<h4 id="双链表删除节点">双链表删除节点</h4>
<p><img src="https://i.loli.net/2021/05/19/paljhibM65RerWo.jpg" alt="双链表删除.jpg"></p>
<p>删除&quot;节点30&quot;<br>
删除之前：“节点20&quot;的后继节点为&quot;节点30”，“节点30” 的前继节点为&quot;节点20&quot;。“节点30&quot;的后继节点为&quot;节点40”，“节点40” 的前继节点为&quot;节点30&quot;。<br>
删除之后：“节点20&quot;的后继节点为&quot;节点40”，“节点40” 的前继节点为&quot;节点20&quot;。</p>
<h4 id="双链表添加节点">双链表添加节点</h4>
<p><img src="https://i.loli.net/2021/05/19/fvbJOLEWg9UBshM.jpg" alt="双链表添加节点.jpg"></p>
<p>在&quot;节点10&quot;与&quot;节点20&quot;之间添加&quot;节点15&quot;<br>
添加之前：“节点10&quot;的后继节点为&quot;节点20”，“节点20” 的前继节点为&quot;节点10&quot;。<br>
添加之后：“节点10&quot;的后继节点为&quot;节点15”，“节点15” 的前继节点为&quot;节点10&quot;。“节点15&quot;的后继节点为&quot;节点20”，“节点20” 的前继节点为&quot;节点15&quot;。</p>
<h3 id="C-实现双链表">C++实现双链表</h3>
<p>双向链表文件(DoubleLink.h)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOUBLE_LINK_HXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLE_LINK_HXX</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value;</span><br><span class="line">        DNode *prev;</span><br><span class="line">        DNode *next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DNode</span>() &#123; &#125;</span><br><span class="line">        <span class="built_in">DNode</span>(T t, DNode *prev, DNode *next) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = t;</span><br><span class="line">            <span class="keyword">this</span>-&gt;prev  = prev;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next  = next;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLink</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DoubleLink</span>();</span><br><span class="line">        ~<span class="built_in">DoubleLink</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">get_first</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">get_last</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, T t)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">insert_first</span><span class="params">(T t)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">append_last</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">delete_first</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">delete_last</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        DNode&lt;T&gt; *phead;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function">DNode&lt;T&gt; *<span class="title">get_node</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">DoubleLink&lt;T&gt;::<span class="built_in">DoubleLink</span>() : <span class="built_in">count</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建“表头”。注意：表头没有存储数据！</span></span><br><span class="line">    phead = <span class="keyword">new</span> DNode&lt;T&gt;();</span><br><span class="line">    phead-&gt;prev = phead-&gt;next = phead;</span><br><span class="line">    <span class="comment">// 设置链表计数为0</span></span><br><span class="line">    <span class="comment">//count = 0;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">DoubleLink&lt;T&gt;::~<span class="built_in">DoubleLink</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除所有的节点</span></span><br><span class="line">    DNode&lt;T&gt;* ptmp;</span><br><span class="line">    DNode&lt;T&gt;* pnode = phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (pnode != phead)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode=pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除&quot;表头&quot;</span></span><br><span class="line">    <span class="keyword">delete</span> phead;</span><br><span class="line">    phead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回节点数目</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">is_empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第index位置的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">DNode&lt;T&gt;* DoubleLink&lt;T&gt;::<span class="built_in">get_node</span>(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断参数有效性</span></span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index&gt;=count)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;get node failed! the index in out of bound!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= count/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        DNode&lt;T&gt;* pindex = phead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; index) &#123;</span><br><span class="line">            pindex = pindex-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pindex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向查找</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rindex = count - index <span class="number">-1</span>;</span><br><span class="line">    DNode&lt;T&gt;* prindex = phead-&gt;prev;</span><br><span class="line">    <span class="keyword">while</span> (j++ &lt; rindex) &#123;</span><br><span class="line">        prindex = prindex-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prindex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第index位置的节点的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T DoubleLink&lt;T&gt;::<span class="built_in">get</span>(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_node</span>(index)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第1个节点的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T DoubleLink&lt;T&gt;::<span class="built_in">get_first</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_node</span>(<span class="number">0</span>)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一个节点的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T DoubleLink&lt;T&gt;::<span class="built_in">get_last</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_node</span>(count<span class="number">-1</span>)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点插入到第index位置之前</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">insert</span>(<span class="keyword">int</span> index, T t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_first</span>(t);</span><br><span class="line"></span><br><span class="line">    DNode&lt;T&gt;* pindex = <span class="built_in">get_node</span>(index);</span><br><span class="line">    DNode&lt;T&gt;* pnode  = <span class="keyword">new</span> DNode&lt;T&gt;(t, pindex-&gt;prev, pindex);</span><br><span class="line">    pindex-&gt;prev-&gt;next = pnode;</span><br><span class="line">    pindex-&gt;prev = pnode;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点插入第一个节点处。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">insert_first</span>(T t)</span><br><span class="line">&#123;</span><br><span class="line">    DNode&lt;T&gt;* pnode  = <span class="keyword">new</span> DNode&lt;T&gt;(t, phead, phead-&gt;next);</span><br><span class="line">    phead-&gt;next-&gt;prev = pnode;</span><br><span class="line">    phead-&gt;next = pnode;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点追加到链表的末尾</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">append_last</span>(T t)</span><br><span class="line">&#123;</span><br><span class="line">    DNode&lt;T&gt;* pnode = <span class="keyword">new</span> DNode&lt;T&gt;(t, phead-&gt;prev, phead);</span><br><span class="line">    phead-&gt;prev-&gt;next = pnode;</span><br><span class="line">    phead-&gt;prev = pnode;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除index位置的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">del</span>(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    DNode&lt;T&gt;* pindex = <span class="built_in">get_node</span>(index);</span><br><span class="line">    pindex-&gt;next-&gt;prev = pindex-&gt;prev;</span><br><span class="line">    pindex-&gt;prev-&gt;next = pindex-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> pindex;</span><br><span class="line">    count--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">delete_first</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">del</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">delete_last</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">del</span>(count<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>双向链表测试文件(DlinkTest.cpp)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DoubleLink.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表操作int数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[<span class="number">4</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n----int_test----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建双向链表</span></span><br><span class="line">    DoubleLink&lt;<span class="keyword">int</span>&gt;* pdlink = <span class="keyword">new</span> DoubleLink&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">20</span>);        <span class="comment">// 将 20 插入到第一个位置</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">append_last</span>(<span class="number">10</span>);    <span class="comment">// 将 10 追加到链表末尾</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert_first</span>(<span class="number">30</span>);    <span class="comment">// 将 30 插入到第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_empty()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">is_empty</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 双向链表的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印双向链表中的全部数据</span></span><br><span class="line">    <span class="keyword">int</span> sz = pdlink-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pdlink(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">get</span>(i) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string sarr[<span class="number">4</span>] = &#123;<span class="string">&quot;ten&quot;</span>, <span class="string">&quot;twenty&quot;</span>, <span class="string">&quot;thirty&quot;</span>, <span class="string">&quot;forty&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n----string_test----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建双向链表</span></span><br><span class="line">    DoubleLink&lt;string&gt;* pdlink = <span class="keyword">new</span> DoubleLink&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, sarr[<span class="number">1</span>]);        <span class="comment">// 将 sarr中第2个元素 插入到第一个位置</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">append_last</span>(sarr[<span class="number">0</span>]);    <span class="comment">// 将 sarr中第1个元素  追加到链表末尾</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert_first</span>(sarr[<span class="number">2</span>]);    <span class="comment">// 将 sarr中第3个元素  插入到第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_empty()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">is_empty</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 双向链表的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印双向链表中的全部数据</span></span><br><span class="line">    <span class="keyword">int</span> sz = pdlink-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pdlink(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">get</span>(i) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> stu arr_stu[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="string">&quot;sky&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">20</span>, <span class="string">&quot;jody&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">30</span>, <span class="string">&quot;vic&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">40</span>, <span class="string">&quot;dan&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_STU_SIZE ( (sizeof(arr_stu)) / (sizeof(arr_stu[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n----object_test----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建双向链表</span></span><br><span class="line">    DoubleLink&lt;stu&gt;* pdlink = <span class="keyword">new</span> DoubleLink&lt;stu&gt;();</span><br><span class="line"></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, arr_stu[<span class="number">1</span>]);        <span class="comment">// 将 arr_stu中第2个元素 插入到第一个位置</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">append_last</span>(arr_stu[<span class="number">0</span>]);    <span class="comment">// 将 arr_stu中第1个元素  追加到链表末尾</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert_first</span>(arr_stu[<span class="number">2</span>]);    <span class="comment">// 将 arr_stu中第3个元素  插入到第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_empty()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">is_empty</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 双向链表的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印双向链表中的全部数据</span></span><br><span class="line">    <span class="keyword">int</span> sz = pdlink-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = pdlink-&gt;<span class="built_in">get</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pdlink(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)=[&quot;</span> &lt;&lt; p.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.name &lt;&lt;<span class="string">&quot;]&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int_test</span>();        <span class="comment">// 演示向双向链表操作“int数据”。</span></span><br><span class="line">    <span class="built_in">string_test</span>();    <span class="comment">// 演示向双向链表操作“字符串数据”。</span></span><br><span class="line">    <span class="built_in">object_test</span>();    <span class="comment">// 演示向双向链表操作“对象”。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例说明</strong></p>
<p>在上面的示例中，我将双向链表的&quot;声明&quot;和&quot;实现&quot;都放在头文件中。而编程规范告诫我们：将类的声明和实现分离，在头文件(.h文件或.hpp)中尽量只包含声明，而在实现文件(.cpp文件)中负责实现！<br>
那么为什么要这么做呢？这是因为，在双向链表的实现中，采用了模板；而C++编译器不支持对模板的分离式编译！简单点说，如果在DoubleLink.h中声明，而在DoubleLink.cpp中进行实现的话；当我们在其他类中创建DoubleLink的对象时，会编译出错。</p>
<p><strong>运行结果</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">----int_test----</span><br><span class="line">is_empty()=0</span><br><span class="line">size()=3</span><br><span class="line">pdlink(0)=30</span><br><span class="line">pdlink(1)=20</span><br><span class="line">pdlink(2)=10</span><br><span class="line"></span><br><span class="line">----string_test----</span><br><span class="line">is_empty()=0</span><br><span class="line">size()=3</span><br><span class="line">pdlink(0)=thirty</span><br><span class="line">pdlink(1)=twenty</span><br><span class="line">pdlink(2)=ten</span><br><span class="line"></span><br><span class="line">----object_test----</span><br><span class="line">is_empty()=0</span><br><span class="line">size()=3</span><br><span class="line">pdlink(0)=[30, vic]</span><br><span class="line">pdlink(1)=[20, jody]</span><br><span class="line">pdlink(2)=[10, sky]</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>对链表的理论知识进行简单介绍，给出C++实现，并对实现代码进行了测试。</p>
<blockquote>
<p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3561803.html">https://www.cnblogs.com/skywang12345/p/3561803.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构及实现</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>理解C++中的左值和右值</title>
    <url>/%E7%90%86%E8%A7%A3C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据结构及实现：红黑树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>引言：R-B Tree，又称为“红黑树”，本文的主要内容包括：红黑树的特性，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作。</p>
<span id="more"></span>
<h3 id="红黑树介绍">红黑树介绍</h3>
<p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p><strong>红黑树的特性</strong>:<br>
（1）每个节点或者是黑色，或者是红色。<br>
（2）根节点是黑色。<br>
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>
（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p><strong>注意</strong>：<br>
(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>
(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p>红黑树示意图如下：</p>
<p><img src="https://i.loli.net/2021/04/27/bDfAtceGNF58kiV.jpg" alt="红黑树.jpg"></p>
<h3 id="红黑树的应用">红黑树的应用</h3>
<p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。</p>
<p>例如，<strong>C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的</strong>。</p>
<h3 id="红黑树的时间复杂度和相关证明">红黑树的时间复杂度和相关证明</h3>
<p><strong>红黑树的时间复杂度为: O(lgn)</strong></p>
<p>下面通过“数学归纳法”对红黑树的时间复杂度进行证明。</p>
<p><strong>定理：一棵含有n个节点的红黑树的高度至多为2log(n+1)</strong>.</p>
<p>证明：<br>
“一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的<strong>逆否命题</strong>是 “高度为h的红黑树，它的包含的内节点个数至少为 2<sup>h/2</sup>-1个”。</p>
<p>我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。</p>
<p>从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x’s black height)，记为<strong>bh(x)</strong>。关于bh(x)有两点需要说明：</p>
<p>第1点：根据红黑树的&quot;<strong>特性(5)</strong> ，即<em>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</em>&quot;可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。<strong>这也就意味着，bh(x)的值是唯一的</strong>！<br>
第2点：根据红黑色的&quot;特性(4)，即<em>如果一个节点是红色的，则它的子节点必须是黑色的</em>&quot;可知，从节点x出发达到叶节点&quot;所经历的黑节点数目&quot;&gt;= “所经历的红节点的数目”。假设x是根节点，则可以得出结论&quot;<strong>bh(x) &gt;= h/2</strong>&quot;。进而，我们只需证明 &quot;高度为h的红黑树，它的包含的黑节点个数至少为 2<sup>bh(x)</sup>-1个&quot;即可。</p>
<p>到这里，我们将需要证明的定理已经由**&quot;一棵含有n个节点的红黑树的高度至多为2log(n+1)“<strong>转变成只需要证明</strong>&quot;高度为h的红黑树，它的包含的内节点个数至少为 2<sup>bh(x)</sup>-1个”。**</p>
<p>下面通过&quot;数学归纳法&quot;开始论证高度为h的红黑树，它的包含的内节点个数至少为 2<sup>bh(x)</sup>-1个&quot;。</p>
<p>(01) 当树的高度h=0时，<br>
内节点个数是0，bh(x) 为0，2<sup>bh(x)</sup>-1 也为 0。显然，原命题成立。</p>
<p>(02) 当h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2<sup>bh(x)</sup>-1-1。这个是根据(01)推断出来的！</p>
<p>下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2<sup>bh(x)</sup>-1”。</p>
<p>当树的高度为 h 时，<br>
对于节点x(x为根节点)，其黑高度为bh(x)。<br>
对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br>
根据(02)的已知条件，我们已知 “x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2<sup>bh(x)</sup>-1-1 个”；</p>
<p>所以，节点x所包含的节点至少为 ( 2<sup>bh(x)</sup>-1-1 ) + ( 2<sup>bh(x)</sup>-1-1 ) + 1 = 2<sup>bh(x)</sup>-1。即节点x所包含的节点至少为 2<sup>bh(x)</sup>-1。<br>
因此，原命题成立。</p>
<p>由(01)、(02)得出，“高度为h的红黑树，它的包含的内节点个数至少为 2<sup>bh(x)</sup>-1个”。<br>
因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。</p>
<h3 id="红黑树的基本操作-一-左旋和右旋">红黑树的基本操作(一) 左旋和右旋</h3>
<p>红黑树的基本操作是<strong>添加</strong>、<strong>删除</strong>。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。<br>
旋转包括两种：<strong>左旋</strong> 和 <strong>右旋</strong>。下面分别对它们进行介绍。</p>
]]></content>
      <categories>
        <category>数据结构及实现</category>
      </categories>
  </entry>
  <entry>
    <title>经典算法：Floyd判圈算法</title>
    <url>/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>引言：本文主要介绍一种常用的判圈算法，并给出其推导。</p>
<span id="more"></span>
<h3 id="简述">简述</h3>
<p>Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。</p>
<h3 id="问题">问题</h3>
<p>如何检测一个链表是否有环，如果有，那么如何确定环的起点和环的长度。</p>
<p>1）判断是否有环？<br>
龟兔解法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p>
<p>基于上面的想法，Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果时等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。</p>
<p>2）求环的长度<br>
假设相遇点为B点,让其中一个指针停在B不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p>
<p>3）如何确定环的起点<br>
假设相遇点为B点。方法是将其中一个指针移到链表起点，另一个指针为B点,两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。</p>
<h3 id="证明">证明</h3>
<p>首先假设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m，环的长度为n，相遇的位置与起点与起点位置距离为k。于是有：</p>
<p>i = m + a * n + k</p>
<p>其中a为慢指针走的圈数。</p>
<p>因为快指针的速度是慢指针的2倍，于是又可以得到另一个式子：</p>
<p>2 * i = m + b * n + k</p>
<p>其中b为快指针走的圈数。</p>
<p>两式相减得：</p>
<p>i = ( b - a ) * n</p>
<p>也就是说i是圈长的整数倍。</p>
<p>这是将其中一个节点放在起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点i+m，i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。</p>
]]></content>
      <categories>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>判圈算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构及实现：伸展树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BC%B8%E5%B1%95%E6%A0%91/</url>
    <content><![CDATA[<p>引言：本文介绍伸展树。它和&quot;二叉查找树&quot;和&quot;AVL树&quot;一样，都是特殊的二叉树，本文会先对伸展树的理论知识进行简单介绍，然后给出C++的实现。</p>
<span id="more"></span>
<h3 id="伸展树介绍">伸展树介绍</h3>
<p>伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。</p>
<p>（1）伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。<br>
（2）除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。</p>
<p>假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</p>
<p>相比于&quot;二叉查找树&quot;和&quot;AVL树&quot;，学习伸展树时需要重点关注<strong>伸展树的旋转算法</strong>。</p>
<h3 id="伸展树的C-实现">伸展树的C++实现</h3>
<h4 id="基本定义">基本定义</h4>
<h5 id="节点">节点</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">    SplayTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">    SplayTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SplayTreeNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SplayTreeNode</span>(T value, SplayTreeNode *l, SplayTreeNode *r):</span><br><span class="line">    <span class="built_in">key</span>(value), <span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SplayTreeNode是伸展树节点对应的类。它包括的几个组成元素:<br>
（1）key – 是关键字，是用来对伸展树的节点进行排序的。<br>
（2） left – 是左孩子。<br>
（3） right – 是右孩子。</p>
<h5 id="伸展树">伸展树</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SplayTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SplayTree</span>();</span><br><span class="line">        ~<span class="built_in">SplayTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到伸展树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的伸展树的最小结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的伸展树的最大结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">splay</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到伸展树(tree)中</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除伸展树(tree)中的结点(键值为key)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SplayTree是伸展树对应的类。它包括根节点mRoot和伸展树的函数接口。</p>
<h4 id="旋转">旋转</h4>
<p>旋转是伸展树中需要重点关注的，它的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *   (a)：伸展树中存在&quot;键值为key的节点&quot;。</span></span><br><span class="line"><span class="comment"> *          将&quot;键值为key的节点&quot;旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (b)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &lt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      b-1 &quot;键值为key的节点&quot;的前驱节点存在的话，将&quot;键值为key的节点&quot;的前驱节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      b-2 &quot;键值为key的节点&quot;的前驱节点不存在的话，则意味着，key比树中任何键值都小，那么此时，将最小节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (c)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &gt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      c-1 &quot;键值为key的节点&quot;的后继节点存在的话，将&quot;键值为key的节点&quot;的后继节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      c-2 &quot;键值为key的节点&quot;的后继节点不存在的话，则意味着，key比树中任何键值都大，那么此时，将最大节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">splay</span>(SplayTreeNode&lt;T&gt;* tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; N, *l, *r, *c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    N.left = N.right = <span class="literal">NULL</span>;</span><br><span class="line">    l = r = &amp;N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;left;                           <span class="comment">/* rotate right */</span></span><br><span class="line">                tree-&gt;left = c-&gt;right;</span><br><span class="line">                c-&gt;right = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r-&gt;left = tree;                               <span class="comment">/* link right */</span></span><br><span class="line">            r = tree;</span><br><span class="line">            tree = tree-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key) </span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;right;                          <span class="comment">/* rotate left */</span></span><br><span class="line">                tree-&gt;right = c-&gt;left;</span><br><span class="line">                c-&gt;left = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l-&gt;right = tree;                              <span class="comment">/* link left */</span></span><br><span class="line">            l = tree;</span><br><span class="line">            tree = tree-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l-&gt;right = tree-&gt;left;                                <span class="comment">/* assemble */</span></span><br><span class="line">    r-&gt;left = tree-&gt;right;</span><br><span class="line">    tree-&gt;left = N.right;</span><br><span class="line">    tree-&gt;right = N.left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">splay</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码的作用：将&quot;键值为key的节点&quot;旋转为根节点，并返回根节点。它的处理情况共包括：<br>
<strong>(a)：伸展树中存在&quot;键值为key的节点&quot;。</strong><br>
将&quot;键值为key的节点&quot;旋转为根节点。<br>
<strong>(b)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &lt; tree-&gt;key。</strong><br>
b-1) &quot;键值为key的节点&quot;的前驱节点存在的话，将&quot;键值为key的节点&quot;的前驱节点旋转为根节点。<br>
b-2) &quot;键值为key的节点&quot;的前驱节点存在的话，则意味着，key比树中任何键值都小，那么此时，将最小节点旋转为根节点。<br>
<strong>©：伸展树中不存在&quot;键值为key的节点&quot;，并且key &gt; tree-&gt;key。</strong><br>
c-1) &quot;键值为key的节点&quot;的后继节点存在的话，将&quot;键值为key的节点&quot;的后继节点旋转为根节点。<br>
c-2) &quot;键值为key的节点&quot;的后继节点不存在的话，则意味着，key比树中任何键值都大，那么此时，将最大节点旋转为根节点。</p>
<p>下面列举个例子分别对a进行说明。</p>
<p>在下面的伸展树中查找10，共包括&quot;右旋&quot; --&gt; “右链接” --&gt; &quot;组合&quot;这3步。</p>
<p><img src="https://i.loli.net/2021/04/26/2hazYbWXuyRdmT8.jpg" alt="伸展树.jpg"></p>
<p><strong>(01) 右旋</strong></p>
<p>对应代码中的&quot;rotate right&quot;部分</p>
<p><img src="https://i.loli.net/2021/04/26/ea31Pl8EznhptM5.jpg" alt="伸展树右旋.jpg"></p>
<p><strong>(02) 右链接</strong></p>
<p>对应代码中的&quot;link right&quot;部分</p>
<p><img src="https://i.loli.net/2021/04/26/KI3WvJmXhHCTw8L.jpg" alt="伸展树右链接.jpg"></p>
<p><strong>(03) 组合</strong></p>
<p>对应代码中的&quot;assemble&quot;部分</p>
<p><img src="https://i.loli.net/2021/04/26/dv5ajrPlI87bCM6.jpg" alt="伸展树组合.jpg"></p>
<p>提示：如果在上面的伸展树中查找&quot;70&quot;，则正好与&quot;示例1&quot;对称，而对应的操作则分别是&quot;rotate left&quot;, “link left&quot;和&quot;assemble”。<br>
其它的情况，例如&quot;查找15是b-1的情况，查找5是b-2的情况&quot;等等，这些都比较简单，大家可以自己分析。</p>
<h4 id="插入">插入</h4>
<p>插入代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到伸展树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">insert</span>(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z) &#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key)</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不允许插入相同节点(&quot;</span> &lt;&lt; z-&gt;key &lt;&lt; <span class="string">&quot;)!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> z;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> SplayTreeNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    mRoot = <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">    <span class="comment">// 将节点(key)旋转为根节点</span></span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert(key)是提供给外部的接口，它的作用是新建节点(节点的键值为key)，并将节点插入到伸展树中；然后，将该节点旋转为根节点。<br>
insert(tree, z)是内部接口，它的作用是将节点z插入到tree中。insert(tree, z)在将z插入到tree中时，仅仅只将tree当作是一棵二叉查找树，而且不允许插入相同节点。</p>
<h4 id="删除">删除</h4>
<p>删除代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(节点的键值为key)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 待删除结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">remove</span>(SplayTreeNode&lt;T&gt;* &amp;tree, T key) &#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键值为key的节点，找不到的话直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">search</span>(tree, key) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将key对应的节点旋转为根节点。</span></span><br><span class="line">    tree = <span class="built_in">splay</span>(tree, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将&quot;tree的前驱节点&quot;旋转为根节点</span></span><br><span class="line">        x = <span class="built_in">splay</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 移除tree节点</span></span><br><span class="line">        x-&gt;right = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = tree-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">remove</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove(key)是外部接口，remove(tree, key)是内部接口。<br>
remove(tree, key)的作用是：删除伸展树中键值为key的节点。<br>
它会先在伸展树中查找键值为key的节点。若没有找到的话，则直接返回。若找到的话，则将该节点旋转为根节点，然后再删除该节点。</p>
<p><strong>注意</strong>：关于伸展树的&quot;前序遍历&quot;、“中序遍历”、“后序遍历”、“最大值”、“最小值”、“查找”、“打印”、&quot;销毁&quot;等接口与&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;基本一样，这些操作在&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;中已经介绍过了，这里就不再单独介绍了。当然，后文给出的伸展树的完整源码中，有给出这些API的实现代码。</p>
<h3 id="伸展树的C-实现（完整源码）">伸展树的C++实现（完整源码）</h3>
<p>伸展树的实现文件(SplayTree.h)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SPLAY_TREE_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SPLAY_TREE_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        SplayTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">        SplayTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">SplayTreeNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SplayTreeNode</span>(T value, SplayTreeNode *l, SplayTreeNode *r):</span><br><span class="line">            <span class="built_in">key</span>(value), <span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SplayTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SplayTree</span>();</span><br><span class="line">        ~<span class="built_in">SplayTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到伸展树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的伸展树的最小结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的伸展树的最大结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">splay</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到伸展树(tree)中</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除伸展树(tree)中的结点(键值为key)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTree&lt;T&gt;::<span class="built_in">SplayTree</span>():<span class="built_in">mRoot</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTree&lt;T&gt;::~<span class="built_in">SplayTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">preOrder</span>(SplayTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">preOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">inOrder</span>(SplayTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">inOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">postOrder</span>(SplayTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">postOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">search</span>(SplayTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">search</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(SplayTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小结点：返回tree为根结点的伸展树的最小结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">minimum</span>(SplayTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T SplayTree&lt;T&gt;::<span class="built_in">minimum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大结点：返回tree为根结点的伸展树的最大结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">maximum</span>(SplayTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T SplayTree&lt;T&gt;::<span class="built_in">maximum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *   (a)：伸展树中存在&quot;键值为key的节点&quot;。</span></span><br><span class="line"><span class="comment"> *          将&quot;键值为key的节点&quot;旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (b)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &lt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      b-1 &quot;键值为key的节点&quot;的前驱节点存在的话，将&quot;键值为key的节点&quot;的前驱节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      b-2 &quot;键值为key的节点&quot;的前驱节点存在的话，则意味着，key比树中任何键值都小，那么此时，将最小节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (c)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &gt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      c-1 &quot;键值为key的节点&quot;的后继节点存在的话，将&quot;键值为key的节点&quot;的后继节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      c-2 &quot;键值为key的节点&quot;的后继节点不存在的话，则意味着，key比树中任何键值都大，那么此时，将最大节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">splay</span>(SplayTreeNode&lt;T&gt;* tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; N, *l, *r, *c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    N.left = N.right = <span class="literal">NULL</span>;</span><br><span class="line">    l = r = &amp;N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;left;                           <span class="comment">/* rotate right */</span></span><br><span class="line">                tree-&gt;left = c-&gt;right;</span><br><span class="line">                c-&gt;right = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r-&gt;left = tree;                               <span class="comment">/* link right */</span></span><br><span class="line">            r = tree;</span><br><span class="line">            tree = tree-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;right;                          <span class="comment">/* rotate left */</span></span><br><span class="line">                tree-&gt;right = c-&gt;left;</span><br><span class="line">                c-&gt;left = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l-&gt;right = tree;                              <span class="comment">/* link left */</span></span><br><span class="line">            l = tree;</span><br><span class="line">            tree = tree-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l-&gt;right = tree-&gt;left;                                <span class="comment">/* assemble */</span></span><br><span class="line">    r-&gt;left = tree-&gt;right;</span><br><span class="line">    tree-&gt;left = N.right;</span><br><span class="line">    tree-&gt;right = N.left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">splay</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点插入到伸展树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">insert</span>(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key)</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不允许插入相同节点(&quot;</span> &lt;&lt; z-&gt;key &lt;&lt; <span class="string">&quot;)!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> z;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> SplayTreeNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    mRoot = <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">    <span class="comment">// 将节点(key)旋转为根节点</span></span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(节点的键值为key)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 待删除结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">remove</span>(SplayTreeNode&lt;T&gt;* &amp;tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键值为key的节点，找不到的话直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">search</span>(tree, key) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将key对应的节点旋转为根节点。</span></span><br><span class="line">    tree = <span class="built_in">splay</span>(tree, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将&quot;tree的前驱节点&quot;旋转为根节点</span></span><br><span class="line">        x = <span class="built_in">splay</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 移除tree节点</span></span><br><span class="line">        x-&gt;right = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = tree-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">remove</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁伸展树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">destroy</span>(SplayTreeNode&lt;T&gt;* &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">destroy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值</span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">print</span>(SplayTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>关于&quot;队列的声明和实现都在头文件中&quot;的原因，是因为队列的实现利用了C++模板，而&quot;C++编译器不能支持对模板的分离式编译&quot;！</p>
<h3 id="伸展树的C-测试程序">伸展树的C++测试程序</h3>
<p>伸展树的测试程序(SplayTreeTest.cpp)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 伸展树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2014/02/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SplayTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]= &#123;<span class="number">10</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,ilen;</span><br><span class="line">    SplayTree&lt;<span class="keyword">int</span>&gt;* tree=<span class="keyword">new</span> SplayTree&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 依次添加: &quot;</span>;</span><br><span class="line">    ilen = <span class="built_in">TBL_SIZE</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree-&gt;<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 前序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">preOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 后序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最小值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">minimum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最大值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">maximum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 旋转节点(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)为根节点&quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">splay</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    tree-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伸展树的测试程序运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">== 依次添加: 10 50 40 30 20 60 </span><br><span class="line">== 前序遍历: 60 30 20 10 50 40 </span><br><span class="line">== 中序遍历: 10 20 30 40 50 60 </span><br><span class="line">== 后序遍历: 10 20 40 50 30 60 </span><br><span class="line">== 最小值: 10</span><br><span class="line">== 最大值: 60</span><br><span class="line">== 树的详细信息: </span><br><span class="line">60 is root</span><br><span class="line">30 is 60&#x27;s   left child</span><br><span class="line">20 is 30&#x27;s   left child</span><br><span class="line">10 is 20&#x27;s   left child</span><br><span class="line">50 is 30&#x27;s  right child</span><br><span class="line">40 is 50&#x27;s   left child</span><br><span class="line"></span><br><span class="line">== 旋转节点(30)为根节点</span><br><span class="line">== 树的详细信息: </span><br><span class="line">30 is root</span><br><span class="line">20 is 30&#x27;s   left child</span><br><span class="line">10 is 20&#x27;s   left child</span><br><span class="line">60 is 30&#x27;s  right child</span><br><span class="line">50 is 60&#x27;s   left child</span><br><span class="line">40 is 50&#x27;s   left child</span><br></pre></td></tr></table></figure>
<p>测试程序的主要流程是：新建伸展树，然后向伸展树中依次插入10,50,40,30,20,60。插入完毕这些数据之后，伸展树的节点是60；此时，再旋转节点，使得30成为根节点。<br>
依次插入10,50,40,30,20,60示意图如下：</p>
<p><img src="https://i.loli.net/2021/04/26/f4nuZUd3ToD1sBC.jpg" alt="伸展树插入.jpg"></p>
<p>将30旋转为根节点的示意图如下：</p>
<p><img src="https://i.loli.net/2021/04/26/D2WF7e1A3qjmzU6.jpg" alt="伸展树旋转.jpg"></p>
<h3 id="总结">总结</h3>
<p>伸展树的C++实现代码，并进行了测试。</p>
<blockquote>
<p>本文转载自：<a href="http://www.cnblogs.com/skywang12345/p/3604258.html">http://www.cnblogs.com/skywang12345/p/3604258.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构及实现</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
        <tag>伸展树旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>粗浅理解</title>
    <url>/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>引言：本文主要总结对于机器学习和深度学习领域一些比较片面粗浅的理解，包含的范围比较杂乱，在此做一个记录。</p>
<span id="more"></span>
<h3 id="一、对于CNN和Transformer的对比">一、对于CNN和Transformer的对比</h3>
<p>CNN使用了较强的归纳偏置（inductive biases）:</p>
<ul>
<li>权重共享，图像不同部分以相同方式处理，位置不敏感；</li>
<li>由于卷积算子的性质，卷积的特征图具有局部敏感性,也就是每次卷积操作只会考虑原始数据的一小部分的局部信息。</li>
</ul>
<p>因此，CNN 的归纳偏置缺乏对输入数据本身的整体把握。它很擅长提取局部的有效信息，但是没能提取全局数据之间的长距离特征。</p>
<p>相比之下，基于自注意力机制的Transformer模型最小化了归纳偏置。当在大数据集上进行训练时，这些模型的性能已经可以媲美甚至超过 CNN 。但在小数据集上训练时，它们往往很难学习有意义的表征。可以说，CNN在小数据集上表现较为突出，因为预先强加了归纳偏置，可以让网络一开始就朝着比较正确的方向学习，但当数据量增大时，可能由于这些归纳偏置，导致其达到一个上限，而Transformer没有，所以对数据非常饥渴，但同时上限也很高。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>经典算法：卡尔曼滤波（图解推导）</title>
    <url>/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%EF%BC%88%E5%9B%BE%E8%A7%A3%E6%8E%A8%E5%AF%BC%EF%BC%89/</url>
    <content><![CDATA[<p>引言：本文翻译自国外博主Bzarg在2015年写的一篇卡尔曼滤波的图解。</p>
<span id="more"></span>
<h3 id="背景">背景</h3>
<p>卡尔曼滤波（Kalman filter）是一种高效的自回归滤波器，它能在存在诸多不确定性情况的组合信息中估计动态系统的状态，是一种强大的、通用性极强的工具。它的提出者，鲁道夫.E.卡尔曼，在一次访问NASA埃姆斯研究中心时，发现这种方法能帮助解决阿波罗计划的轨道预测问题，后来NASA在阿波罗飞船的导航系统中确实也用到了这个滤波器。最终，飞船正确驶向月球，完成了人类历史上的第一次登月。</p>
<p><img src="https://i.loli.net/2021/05/22/tmSXqv7sRf9P6FC.jpg" alt="v2-e7fade003119539cd2892c23ff924ca1_720w.jpg"></p>
<h3 id="什么是卡尔曼滤波">什么是卡尔曼滤波</h3>
<p>对于这个滤波器，我们几乎可以下这么一个定论：只要是存在不确定信息的动态系统，卡尔曼滤波就可以对系统下一步要做什么做出有根据的推测。即便有噪声信息干扰，卡尔曼滤波通常也能很好的弄清楚究竟发生了什么，找出现象间不易察觉的相关性。</p>
<p>因此卡尔曼滤波非常适合不断变化的系统，它的优点还有内存占用较小（只需保留前一个状态）、速度快，是实时问题和嵌入式系统的理想选择。</p>
<p>如果你曾经Google过卡尔曼滤波的教程（如今有一点点改善），你会发现相关的算法教程非常可怕，而且也没具体说清楚是什么。事实上，卡尔曼滤波很简单，如果我们以正确的方式看它，理解是很水到渠成的事。</p>
<p>本文会用大量清晰、美观的图片和颜色来解释这个概念，读者只需具备概率论和矩阵的一般基础知识。</p>
<h3 id="我们能用卡尔曼滤波做什么">我们能用卡尔曼滤波做什么</h3>
<p>让我们举个例子：你造了一个可以在树林里四处溜达的小机器人，为了让它实现导航，机器人需要知道自己所处的位置。</p>
<p><img src="https://i.loli.net/2021/05/22/7bj6ryBc4fMaeE9.png" alt="robot_forest-300x160.png"></p>
<p>也就是说，机器人有一个包含位置信息和速度信息的状态$\vec{x}_k$：</p>
<p><img src="https://i.loli.net/2021/05/22/VPt7HL4wMcaEZvf.png" alt="Screenshot from 2021-05-22 18-35-17.png"></p>
<p>注意，在这个例子中，状态是位置和速度，放进其他问题里，它也可以是水箱里的液体体积、汽车引擎温度、触摸板上指尖的位置，或者其他任何数据。</p>
<p>我们的小机器人装有GPS传感器，定位精度10米。虽然一般来说这点精度够用了，但我们希望它的定位误差能再小点，毕竟树林里到处都是土坑和陡坡，如果机器人稍稍偏了那么几米，它就有可能滚落山坡。所以GPS提供的信息还不够充分。</p>
<p><img src="https://i.loli.net/2021/05/22/wp4NDdIZl8EH5sQ.png" alt="robot_ohnoes-300x283.png"></p>
<p>我们也可以<strong>预测</strong>机器人是怎么移动的：它会把指令发送给控制轮子的马达，如果这一刻它始终朝一个方向前进，没有遇到任何障碍物，那么下一刻它可能会继续坚持这个路线。但是机器人对自己的状态不是全知的：它可能会逆风行驶，轮子打滑，滚落颠簸地形……所以车轮转动次数并不能完全代表实际行驶距离，基于这个距离的预测也不完美。</p>
<p>这个问题下，GPS为我们提供了一些关于状态的信息，但那是间接的、不准确的；我们的预测提供了关于机器人轨迹的信息，但那也是间接的、不准确的。</p>
<p>但以上就是我们能够获得的全部信息，在它们的基础上，我们是否能给出一个完整预测，让它的准确度比机器人搜集的单次预测汇总更高？用了卡尔曼滤波，这个问题可以迎刃而解。</p>
<h3 id="卡尔曼滤波眼里的机器人问题">卡尔曼滤波眼里的机器人问题</h3>
<p>还是上面这个问题，我们有一个状态，它和速度、位置有关：</p>
<p><img src="https://i.loli.net/2021/05/22/akiCweMZIXhRJus.jpg" alt="v2-a1a901c6aad3d87b47b148a3e5cdddbe_720w.jpg"></p>
<p>我们不知道它们的实际值是多少，但掌握着一些速度和位置的可能组合，其中某些组合的可能性更高：</p>
<p><img src="https://i.loli.net/2021/05/22/QIOpYyKaEqeDZki.png" alt="gauss_0.png"></p>
<p>卡尔曼滤波假设两个变量（在我们的例子里是位置和速度）都应该是<strong>随机的</strong>，而且符合<strong>高斯分布</strong>。每个变量都有一个<strong>均值</strong> $\mu$，它是随机分布的中心；有一个方差$\sigma^2$ ，它衡量组合的不确定性。</p>
<p><img src="https://i.loli.net/2021/05/22/XOQhw7EG1nlbMzq.png" alt="gauss_1.png"></p>
<p>在上图中，位置和速度是<strong>不相关</strong>的，这意味着我们不能从一个变量推测另一个变量。</p>
<p>那么如果位置和速度相关呢？如下图所示，机器人前往特定位置的可能性取决于它拥有的速度。</p>
<p><img src="https://i.loli.net/2021/05/22/Ugzas51T2e83mHJ.png" alt="gauss_3.png"></p>
<p>这不难理解，如果基于旧位置估计新位置，我们会产生这两个结论：如果速度很快，机器人可能移动得更远，所以得到的位置会更远；如果速度很慢，机器人就走不了那么远。</p>
<p>这种关系对目标跟踪来说非常重要，因为它提供了更多信息：一个可以衡量可能性的标准。这就是卡尔曼滤波的目标：从不确定信息中挤出尽可能多的信息！</p>
<p>为了捕获这种相关性，我们用的是协方差矩阵。简而言之，矩阵的每个值是第 $i$ 个变量和第 $j$个变量之间的相关程度（由于矩阵是对称的，$i$ 和$j$的位置可以随便交换）。我们用$\varSigma$表示协方差矩阵，在这个例子中，就是$\varSigma_{ij}$。</p>
<p><img src="https://i.loli.net/2021/05/22/N4HQ1Jrq86LEuCm.png" alt="gauss_2.png"></p>
<h3 id="用矩阵描述问题">用矩阵描述问题</h3>
<p>为了把以上关于状态的信息建模为高斯分布（图中色块），我们还需要$k$时的两个信息：最佳估计$\mathbf{\hat{x}_k}$ （均值，也就是$\mu$)，协方差矩阵$\mathbf{P_k}$ 。（虽然还是用了位置和速度两个变量，但只要和问题相关，卡尔曼滤波可以包含任意数量的变量）</p>
<p><img src="https://i.loli.net/2021/05/22/mp4zoHRAkQCcEnu.jpg" alt="v2-2ac6f7823c6e340805cce06b61c8fa16_720w.jpg"></p>
<p>接下来，我们要通过查看当前状态（k-1时）来预测下一个状态（k时）。这里我们查看的状态不是真值，但预测函数无视真假，可以给出新分布：</p>
<p><img src="https://i.loli.net/2021/05/22/vn2s18qwYNje3Ql.jpg" alt="gauss_7.jpg"></p>
<p>我们可以用矩阵$\mathbf{F_k}$表示这个预测步骤：</p>
<p><img src="https://i.loli.net/2021/05/22/hibCd4yzZr8EwVx.jpg" alt="gauss_8.jpg"></p>
<p>它从原始预测中取每一点，并将其移动到新的预测位置。如果原始预测是正确的，系统就会移动到新位置。</p>
<p>这是怎么做到的？为什么我们可以用矩阵来预测机器人下一刻的位置和速度？下面是个简单公式：</p>
<p><img src="https://i.loli.net/2021/05/22/bZgBprOUPf8WqQM.jpg" alt="v2-03ed134b88639dbfe347012511440a3a_720w.jpg"></p>
<p>换成矩阵形式：</p>
<p><img src="https://i.loli.net/2021/05/22/ilCmqGR1awOcWpg.jpg" alt="v2-2916712c805c703b37fce364549dadf6_720w.jpg"></p>
<p>这是一个预测矩阵，它能给出机器人的下一个状态，但目前我们还不知道协方差矩阵的更新方法。这也是我们要引出下面这个等式的原因：如果我们将分布中的每个点乘以矩阵$\color{firebrick}{\mathbf{A}}$，那么它的协方差矩阵会发生什么变化</p>
<p><img src="https://i.loli.net/2021/05/22/92dpmA3cJ5TCvNa.jpg" alt="v2-69a02c2142ed47d086a9a948cb8b17b1_720w.jpg"></p>
<p>把这个式子和上面的最佳估计$\mathbf{\hat{x}_k}$结合，可得：</p>
<p><img src="https://i.loli.net/2021/05/22/etgk3Inhlm8E1Wd.jpg" alt="v2-dbf13375a23f07e1040adf38ea186aa7_720w.jpg"></p>
<h3 id="外部影响">外部影响</h3>
<p>但是，除了速度和位置，外因也会对系统造成影响。比如模拟火车运动，除了列车自驾系统，列车操作员可能会手动调速。在我们的机器人示例中，导航软件也可以发出停止指令。对于这些信息，我们把它作为一个向量$\color{darkorange}{\vec{\mathbf{u}_k}}$，纳入预测系统作为修正。</p>
<p>假设油门设置和控制命令是已知的，我们知道火车的预期加速度$\color{darkorange}{a}$。根据运动学基本定理，我们可得：</p>
<p><img src="https://i.loli.net/2021/05/22/M6neCKhrPYOIWzV.jpg" alt="v2-e0cd414e3b6d4ef4f8a57c8b156a5103_720w.jpg"></p>
<p>把它转成矩阵形式：</p>
<p><img src="https://i.loli.net/2021/05/22/WC5EIrhRmOxU6ya.jpg" alt="v2-64e50bf118c8039f6228b5c817490601_720w.jpg"></p>
<p>$\mathbf{B}_k$是控制矩阵，$\color{darkorange}{\vec{\mathbf{u}_k}}$是控制向量。如果外部环境异常简单，我们可以忽略这部分内容，但是如果添加了外部影响后，模型的准确率还是上不去，这又是为什么呢？</p>
<h3 id="外部不确定性">外部不确定性</h3>
<p>当一个国家只按照自己的步子发展时，它会自生自灭。当一个国家开始依赖外部力量发展时，只要这些外部力量是已知的，我们也能预测它的存亡。</p>
<p>但是，如果存在我们不知道的力量呢？当我们监控无人机时，它可能会受到风的影响；当我们跟踪轮式机器人时，它的轮胎可能会打滑，或者粗糙地面会降低它的移速。这些因素是难以掌握的，如果出现其中的任意一种情况，预测结果就难以保障。</p>
<p>这要求我们在每个预测步骤后再加上一些新的不确定性，来模拟和“世界”相关的所有不确定性：</p>
<p><img src="https://i.loli.net/2021/05/22/fKRH5ZGvQzUXis3.jpg" alt="gauss_9.jpg"></p>
<p>如上图所示，加上外部不确定性后，$\color{royalblue}{\mathbf{\hat{x}}_{k-1}}$的每个预测状态都可能会移动到另一点，也就是蓝色的高斯分布会移动到紫色高斯分布的位置，并且具有协方差$\color{mediumaquamarine}{\mathbf{Q}_k}$。换句话说，我们把这些不确定影响视为协方差$\color{mediumaquamarine}{\mathbf{Q}_k}$ 的噪声。</p>
<p><img src="https://i.loli.net/2021/05/22/Y5AvPyXsC8JaFKg.jpg" alt="gauss_10a.jpg"></p>
<p>这个紫色的高斯分布拥有和原分布相同的均值，但协方差不同。</p>
<p><img src="https://i.loli.net/2021/05/22/KXNsh5GRSY1xpbE.jpg" alt="gauss_10b.jpg"></p>
<p>我们在原式上加入${\color{mediumaquamarine}{\mathbf{Q}_k}}$，得到预测步骤的完整表达式：</p>
<p><img src="https://i.loli.net/2021/05/22/72BFutEgcpAq5jl.jpg" alt="v2-2c8b709435f6c99ef9b00bba18d32b09_720w.jpg"></p>
<p>简而言之，这里：</p>
<p><font color='deeppink'>新的最佳估计</font>是基于<font color='royalblue'>原最佳估计</font>和<font color='darkorange'>已知外部影响</font>校正后得到的预测。</p>
<p><font color='deeppink'>新的不确定性</font>是基于<font color='royalblue'>原不确定性</font>和<font color='mediumaquamarine'>外部环境的不确定性</font>得到的预测。</p>
<p>现在，得到最终的预测结果，我们把传感器数据加入其中，会发生什么呢？</p>
<h3 id="通过测量值来修正估计值">通过测量值来修正估计值</h3>
<p>我们可能有好几个传感器，它们一起提供有关系统状态的信息。传感器的作用不是我们关心的重点，它可以读取位置，可以读取速度，重点是，它能告诉我们关于状态的间接信息——它是状态下产生的一组读数。</p>
<p><img src="https://i.loli.net/2021/05/22/aWxnoL2UKdQv3cS.jpg" alt="gauss_12.jpg"></p>
<p>请注意，读数的规模和状态的规模不一定相同，所以我们把传感器读数转换矩阵设为$\mathbf{H}_k$。</p>
<p><img src="https://i.loli.net/2021/05/22/IkaUXst49c13HEC.jpg" alt="gauss_13.jpg"></p>
<p>把这些分布转换为一般形式：</p>
<p><img src="https://i.loli.net/2021/05/22/kDbOIEhpj8fLwga.jpg" alt="v2-531d486ddd0875207e79b16d19006ca5_720w.jpg"></p>
<p>卡尔曼滤波的一大优点是擅长处理传感器噪声。换句话说，由于种种因素，传感器记录的信息其实是不准的，一个状态事实上可以产生多种读数。</p>
<p><img src="https://i.loli.net/2021/05/22/hRPIA6ZkDC4WVTu.jpg" alt="gauss_14.jpg"></p>
<p><img src="https://i.loli.net/2021/05/22/5ylrfT3eAtiqEn9.jpg" alt="gauss_11.jpg"></p>
<p>我们将这种不确定性（即传感器噪声）的协方差设为$\color{mediumaquamarine}{\mathbf{R}_k}$，读数的分布均值设为$\color{yellowgreen}{\vec{\mathbf{z}_k}}$。</p>
<p>现在我们得到了两块高斯分布，一块围绕预测的均值，另一块围绕传感器读数。</p>
<p><img src="https://i.loli.net/2021/05/22/elyvYbRBks9FVZh.jpg" alt="gauss_4.jpg"></p>
<p>如果要生成靠谱预测，模型必须调和这两个信息。也就是说，对于任何可能的读数$(z_1,z_2)$，这两种方法预测的状态都有可能是准的，也都有可能是不准的。重点是我们怎么找到这两个准确率。</p>
<p>最简单的方法是两者相乘：</p>
<p><img src="https://i.loli.net/2021/05/22/UjPb1LfCnmrQkGF.png" alt="gauss_6a.png"></p>
<p>两块高斯分布相乘后，我们可以得到它们的重叠部分，这也是会出现最佳估计的区域。换个角度看，它看起来也符合高斯分布：</p>
<p><img src="https://i.loli.net/2021/05/22/zEl6UjiPLBDmGfQ.png" alt="gauss_6.png"></p>
<p>事实证明，当你把两个高斯分布和它们各自的均值和协方差矩阵相乘时，你会得到一个拥有独立均值和协方差矩阵的新高斯分布。最后剩下的问题就不难解决了：我们必须有一个公式来从旧的参数中获取这些新参数！</p>
<h3 id="结合高斯">结合高斯</h3>
<blockquote>
<p>关于两个高斯分布的乘积仍为高斯分布的证明见：</p>
</blockquote>
<p>让我们从一维看起，设方差为$\sigma^2$，均值为$\mu$，一个标准一维高斯钟形曲线方程如下所示：</p>
<p><img src="https://i.loli.net/2021/05/22/9U1MAkrv7jpEYw4.jpg" alt="v2-97fd17b2ea76d5452a22725f19f99580_720w.jpg"></p>
<p>那么两条高斯曲线相乘呢，下面的蓝色曲线代表两个高斯分布的（未归一化）交集：</p>
<p><img src="https://i.loli.net/2021/05/22/Ll3wR16UnqFoJtO.png" alt="gauss_joint.png"></p>
<p><img src="https://i.loli.net/2021/05/22/vjf9RsMGbIQE23N.jpg" alt="v2-44fae648700cd28c6ed7c82e91c864a9_720w.jpg"></p>
<p>把这个式子按照一维方程进行扩展，并进行归一化使其概率和为1，可得：</p>
<p><img src="https://i.loli.net/2021/05/22/aiEYnxhTKLQsRec.jpg" alt="v2-f3119ec5da2279746e27b0e2e31ccfb9_720w.jpg"></p>
<p>如果有些太复杂，我们用k简化一下：</p>
<p><img src="https://i.loli.net/2021/05/22/ZwMnGEljsW3FSXq.jpg" alt="v2-2881114c10fc274482b013e408df9ce9_720w.jpg"></p>
<p>以上是一维的内容，如果是多维空间，把这个式子转成矩阵格式：</p>
<p><img src="https://i.loli.net/2021/05/22/2k5ZD19KwQ4cbgY.jpg" alt="v2-1c02a4b31a146aba44c5082079df1e8c_720w.jpg"></p>
<p>这个矩阵 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 就是我们说的<strong>卡尔曼增益</strong>，easy！</p>
<h3 id="把他们结合在一起">把他们结合在一起</h3>
<p>截至目前，我们有用矩阵$(\color{fuchsia}{\mu_0}, \color{deeppink}{\Sigma_0}) = (\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k}, \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T})$预测的分布，有用传感器读数$(\color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\Sigma_1}) = (\color{yellowgreen}{\vec{\mathbf{z}_k}}, \color{mediumaquamarine}{\mathbf{R}_k})$预测的分布。把它们代入上节的矩阵等式中：</p>
<p><img src="https://i.loli.net/2021/05/22/ur956PgedMq47oV.jpg" alt="v2-9cb02f4cb340f4bee98bf8fdef80867b_720w.jpg"></p>
<p>相应的，卡尔曼增益就是：</p>
<p><img src="https://i.loli.net/2021/05/22/aZlki8CpGLf7PJb.jpg" alt="v2-c2a3f0e191354e598e09d4fdd59b8d25_720w.jpg"></p>
<p>考虑到$\color{purple}{\mathbf{K}}$里还包含着一个$\mathbf{H}_k$，我们再精简一下上式：</p>
<p><img src="https://i.loli.net/2021/05/22/2lc56dFy3fGb1Ne.jpg" alt="v2-47b92e3442751ff8266b4d18e30bda2a_720w.jpg"></p>
<p>最后，$\color{royalblue}{\mathbf{\hat{x}}_k’}$是我们最终的最佳估计值，我们可以把它和$\color{royalblue}{\mathbf{P}_k’}$继续放进去做另一轮预测：</p>
<p><img src="https://i.loli.net/2021/05/22/hZrmD1IuW75wR9i.png" alt="kalflow.png"></p>
<blockquote>
<p>参考：<a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits">http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits</a></p>
</blockquote>
]]></content>
      <categories>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>卡尔曼滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构及实现：AVL树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9AAVL%E6%A0%91/</url>
    <content><![CDATA[<p>引言：对AVL树的理论知识进行简单介绍，给出C++实现，并对实现代码进行了测试。</p>
<span id="more"></span>
<h3 id="AVL树简介">AVL树简介</h3>
<p>AVL树是根据它的发明者G.M. <strong>A</strong>delson-<strong>V</strong>elsky和E.M. <strong>L</strong>andis命名的。它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于&quot;二叉查找树&quot;，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。</p>
<p><img src="https://i.loli.net/2021/04/24/3H6BGNtnWRrJqhm.jpg" alt="AVL树和非AVL.jpg"></p>
<p>上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都&lt;=1；而右边的不是AVL树，因为7的两颗子树的高度相差为2(以2为根节点的树的高度是3，而以8为根节点的树的高度是1)。</p>
<p>AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理。学AVL树，重点的地方也就是它的<strong>旋转算法</strong>；在下文的介绍中，来对它进行详细介绍。</p>
<h3 id="AVL树的C-实现">AVL树的C++实现</h3>
<h4 id="节点">节点</h4>
<h5 id="AVL树节点">AVL树节点</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="keyword">int</span> height;         <span class="comment">// 高度</span></span><br><span class="line">    AVLTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">    AVLTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVLTreeNode</span>(T value, AVLTreeNode *l, AVLTreeNode *r):</span><br><span class="line">    	<span class="built_in">key</span>(value), <span class="built_in">height</span>(<span class="number">0</span>),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>AVLTreeNode是AVL树的节点类，它包括的几个组成对象:<br>
（1） key – 是关键字，是用来对AVL树的节点进行排序的。<br>
（2） left – 是左孩子。<br>
（3） right – 是右孩子。<br>
（4） height – 是高度。</p>
<h5 id="AVL树">AVL树</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AVLTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLTree</span>();</span><br><span class="line">    ~<span class="built_in">AVLTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">    <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">    <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(key为节点键值)插入到AVL树中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 获取树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL：左左对应的情况(左单旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR：右右对应的情况(右单旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR：左右对应的情况(左双旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL：右左对应的情况(右双旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(z)插入到AVL树(tree)中</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除AVL树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AVLTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>AVLTree是AVL树对应的类。它包含AVL树的根节点mRoot和AVL树的基本操作接口。需要说明的是：AVLTree中重载了许多函数。重载的目的是区分内部接口和外部接口，例如insert()函数而言，insert(tree, key)是内部接口，而insert(key)是外部接口。</p>
<h5 id="树的高度">树的高度</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取树的高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>(AVLTreeNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于高度，有的地方将&quot;空二叉树的高度是-1&quot;，而本文采用<a href="http://zh.wikipedia.org/zh-cn/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">维基百科</a>上的定义：树的高度为最大层次。即空的二叉树的高度是0，非空树的高度等于它的最大层次(根的层次为1，根的子节点为第2层，依次类推)。</p>
<h5 id="比较大小">比较大小</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 比较两个值的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">max</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="旋转">旋转</h4>
<p>如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。这种失去平衡的可以概括为4种姿态：LL(左左)，LR(左右)，RR(右右)和RL(右左)。下面给出它们的示意图：</p>
<p><img src="https://i.loli.net/2021/04/24/lHQVfiFGx97Ipo6.jpg" alt="AVL树旋转.jpg"></p>
<p>上图中的4棵树都是&quot;失去平衡的AVL树&quot;，从左往右的情况依次是：LL、LR、RL、RR。除了上面的情况之外，还有其它的失去平衡的AVL树，如下图：</p>
<p><img src="https://i.loli.net/2021/04/24/19mD7jypfn85HYc.jpg" alt="AVL树旋转2.jpg"></p>
<p>上面的两张图都是为了便于理解，而列举的关于&quot;失去平衡的AVL树&quot;的例子。总的来说，AVL树失去平衡时的情况一定是LL、LR、RL、RR这4种之一，它们都由各自的定义：</p>
<p>（1）<strong>LL</strong>：LeftLeft，也称为&quot;左左&quot;。插入或删除一个节点后，根节点的左子树的左子树还有非空子节点，导致&quot;根的左子树的高度&quot;比&quot;根的右子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面LL情况中，由于&quot;根节点(8)的左子树(4)的左子树(2)还有非空子节点&quot;，而&quot;根节点(8)的右子树(12)没有子节点&quot;；导致&quot;根节点(8)的左子树(4)高度&quot;比&quot;根节点(8)的右子树(12)&quot;高2。</p>
<p>（2）<strong>LR</strong>：LeftRight，也称为&quot;左右&quot;。插入或删除一个节点后，根节点的左子树的右子树还有非空子节点，导致&quot;根的左子树的高度&quot;比&quot;根的右子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面LR情况中，由于&quot;根节点(8)的左子树(4)的左子树(6)还有非空子节点&quot;，而&quot;根节点(8)的右子树(12)没有子节点&quot;；导致&quot;根节点(8)的左子树(4)高度&quot;比&quot;根节点(8)的右子树(12)&quot;高2。</p>
<p>（3）<strong>RL</strong>：RightLeft，称为&quot;右左&quot;。插入或删除一个节点后，根节点的右子树的左子树还有非空子节点，导致&quot;根的右子树的高度&quot;比&quot;根的左子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面RL情况中，由于&quot;根节点(8)的右子树(12)的左子树(10)还有非空子节点&quot;，而&quot;根节点(8)的左子树(4)没有子节点&quot;；导致&quot;根节点(8)的右子树(12)高度&quot;比&quot;根节点(8)的左子树(4)&quot;高2。</p>
<p>（4）<strong>RR</strong>：RightRight，称为&quot;右右&quot;。插入或删除一个节点后，根节点的右子树的右子树还有非空子节点，导致&quot;根的右子树的高度&quot;比&quot;根的左子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面RR情况中，由于&quot;根节点(8)的右子树(12)的右子树(14)还有非空子节点&quot;，而&quot;根节点(8)的左子树(4)没有子节点&quot;；导致&quot;根节点(8)的右子树(12)高度&quot;比&quot;根节点(8)的左子树(4)&quot;高2。</p>
<p>前面说过，如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。AVL失去平衡之后，可以通过旋转使其恢复平衡，下面分别介绍&quot;LL(左左)，LR(左右)，RR(右右)和RL(右左)&quot;这4种情况对应的旋转方法。</p>
<h5 id="LL的旋转">LL的旋转</h5>
<p>LL失去平衡的情况，可以通过一次旋转让AVL树恢复平衡。如下图：</p>
<p><img src="https://i.loli.net/2021/04/24/WOTV612YwnvicGX.jpg" alt="LL旋转.jpg"></p>
<p>图中左边是旋转之前的树，右边是旋转之后的树。从中可以发现，旋转之后的树又变成了AVL树，而且该旋转只需要一次即可完成。对于LL旋转，你可以这样理解为：LL旋转是围绕&quot;失去平衡的AVL根节点&quot;进行的，也就是节点k2；而且由于是LL情况，即左左情况，就用手抓着&quot;左孩子，即k1&quot;使劲摇。将k1变成根节点，k2变成k1的右子树，“k1的右子树&quot;变成&quot;k2的左子树”。</p>
<p>LL的旋转代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LL：左左对应的情况(左单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftLeftRotation</span>(AVLTreeNode&lt;T&gt;* k2) &#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k1;</span><br><span class="line"></span><br><span class="line">    k1 = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), k2-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RR的旋转">RR的旋转</h5>
<p>理解了LL之后，RR就相当容易理解了。RR是与LL对称的情况！RR恢复平衡的旋转方法如下：</p>
<p><img src="https://i.loli.net/2021/04/24/sjUJzw1ieL7OYSo.jpg" alt="RR旋转.jpg"></p>
<p>图中左边是旋转之前的树，右边是旋转之后的树。RR旋转也只需要一次即可完成。</p>
<p>RR的旋转代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RR：右右对应的情况(右单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightRightRotation</span>(AVLTreeNode&lt;T&gt;* k1) &#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k2;</span><br><span class="line"></span><br><span class="line">    k2 = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1;</span><br><span class="line"></span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;right), k1-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LR的旋转">LR的旋转</h5>
<p>LR失去平衡的情况，需要经过两次旋转才能让AVL树恢复平衡。如下图：</p>
<p><img src="https://i.loli.net/2021/04/24/V6OaYJpzRbCTdvn.jpg" alt="LR旋转.jpg"></p>
<p>第一次旋转是围绕&quot;k1&quot;进行的&quot;RR旋转&quot;，第二次是围绕&quot;k3&quot;进行的&quot;LL旋转&quot;。</p>
<p>LR的旋转代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LR：左右对应的情况(左双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftRightRotation</span>(AVLTreeNode&lt;T&gt;* k3) &#123;</span><br><span class="line">    k3-&gt;left = <span class="built_in">rightRightRotation</span>(k3-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">leftLeftRotation</span>(k3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RL的旋转">RL的旋转</h5>
<p>RL是与LR的对称情况！RL恢复平衡的旋转方法如下：</p>
<p><img src="https://i.loli.net/2021/04/24/6ExdKpOLtgzm7bY.jpg" alt="RL旋转.jpg"></p>
<p>第一次旋转是围绕&quot;k3&quot;进行的&quot;LL旋转&quot;，第二次是围绕&quot;k1&quot;进行的&quot;RR旋转&quot;。</p>
<p>RL的旋转代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RL：右左对应的情况(右双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightLeftRotation</span>(AVLTreeNode&lt;T&gt;* k1) &#123;</span><br><span class="line">    k1-&gt;right = <span class="built_in">leftLeftRotation</span>(k1-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rightRightRotation</span>(k1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入">插入</h4>
<p>插入节点的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">insert</span>(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新建节点</span></span><br><span class="line">        tree = <span class="keyword">new</span> AVLTreeNode&lt;T&gt;(key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR: create avltree node failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的左子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">insert</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的右子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">insert</span>(tree-&gt;right, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key)</span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//key == tree-&gt;key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;添加失败：不允许添加相同的节点！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(tree-&gt;left), <span class="built_in">height</span>(tree-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">insert</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">insert</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除">删除</h4>
<p>删除节点的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     z 待删除的结点</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">remove</span>(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z) &#123;</span><br><span class="line">    <span class="comment">// 根为空 或者 没有要删除的节点，直接返回NULL。</span></span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span> || z==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z-&gt;key &lt; tree-&gt;key)        <span class="comment">// 待删除的节点在&quot;tree的左子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *r =  tree-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(r-&gt;left) &gt; <span class="built_in">height</span>(r-&gt;right))</span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; tree-&gt;key)<span class="comment">// 待删除的节点在&quot;tree的右子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *l =  tree-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(l-&gt;right) &gt; <span class="built_in">height</span>(l-&gt;left))</span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// tree是对应要删除的节点。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// tree的左右孩子都非空</span></span><br><span class="line">        <span class="keyword">if</span> ((tree-&gt;left!=<span class="literal">NULL</span>) &amp;&amp; (tree-&gt;right!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) &gt; <span class="built_in">height</span>(tree-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树比右子树高；</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的左子树中的最大节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最大节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最大节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的左子树中最大节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的左子树中最大节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* max = <span class="built_in">maximum</span>(tree-&gt;left);</span><br><span class="line">                tree-&gt;key = max-&gt;key;</span><br><span class="line">                tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的右子树中的最小节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最小节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最小节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的右子树中最小节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的右子树中最小节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* min = <span class="built_in">maximum</span>(tree-&gt;right);</span><br><span class="line">                tree-&gt;key = min-&gt;key;</span><br><span class="line">                tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt;* tmp = tree;</span><br><span class="line">            tree = (tree-&gt;left!=<span class="literal">NULL</span>) ? tree-&gt;left : tree-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">remove</span>(T key) &#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* z; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        mRoot = <span class="built_in">remove</span>(mRoot, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：关于AVL树的&quot;前序遍历&quot;、“中序遍历”、“后序遍历”、“最大值”、“最小值”、“查找”、“打印”、&quot;销毁&quot;等接口与&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;基本一样，这些操作在&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;中已经介绍过了，这里就不再单独介绍了。当然，后文给出的AVL树的完整源码中，有给出这些API的实现代码。</p>
<h3 id="AVL树的C-实现（完整源码）">AVL树的C++实现（完整源码）</h3>
<p>AVL树的C++实现文件(AVRTree.h)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _AVL_TREE_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AVL_TREE_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        <span class="keyword">int</span> height;         <span class="comment">// 高度</span></span><br><span class="line">        AVLTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">        AVLTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVLTreeNode</span>(T value, AVLTreeNode *l, AVLTreeNode *r):</span><br><span class="line">            <span class="built_in">key</span>(value), <span class="built_in">height</span>(<span class="number">0</span>),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        AVLTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AVLTree</span>();</span><br><span class="line">        ~<span class="built_in">AVLTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 获取树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到AVL树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 获取树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> </span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LL：左左对应的情况(左单旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k2)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RR：右右对应的情况(右单旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LR：左右对应的情况(左双旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k3)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RL：右左对应的情况(右双旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到AVL树(tree)中</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除AVL树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AVLTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTree&lt;T&gt;::<span class="built_in">AVLTree</span>():<span class="built_in">mRoot</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTree&lt;T&gt;::~<span class="built_in">AVLTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取树的高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>(AVLTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 比较两个值的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">max</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">preOrder</span>(AVLTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">preOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">inOrder</span>(AVLTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">inOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">postOrder</span>(AVLTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">postOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">search</span>(AVLTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">search</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(AVLTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">minimum</span>(AVLTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T AVLTree&lt;T&gt;::<span class="built_in">minimum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">maximum</span>(AVLTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T AVLTree&lt;T&gt;::<span class="built_in">maximum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LL：左左对应的情况(左单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftLeftRotation</span>(AVLTreeNode&lt;T&gt;* k2)</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k1;</span><br><span class="line"></span><br><span class="line">    k1 = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), k2-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RR：右右对应的情况(右单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightRightRotation</span>(AVLTreeNode&lt;T&gt;* k1)</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k2;</span><br><span class="line"></span><br><span class="line">    k2 = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1;</span><br><span class="line"></span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;right), k1-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LR：左右对应的情况(左双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftRightRotation</span>(AVLTreeNode&lt;T&gt;* k3)</span><br><span class="line">&#123;</span><br><span class="line">    k3-&gt;left = <span class="built_in">rightRightRotation</span>(k3-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">leftLeftRotation</span>(k3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RL：右左对应的情况(右双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightLeftRotation</span>(AVLTreeNode&lt;T&gt;* k1)</span><br><span class="line">&#123;</span><br><span class="line">    k1-&gt;right = <span class="built_in">leftLeftRotation</span>(k1-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rightRightRotation</span>(k1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">insert</span>(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新建节点</span></span><br><span class="line">        tree = <span class="keyword">new</span> AVLTreeNode&lt;T&gt;(key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR: create avltree node failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的左子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">insert</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的右子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">insert</span>(tree-&gt;right, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key)</span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//key == tree-&gt;key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;添加失败：不允许添加相同的节点！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(tree-&gt;left), <span class="built_in">height</span>(tree-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">insert</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     z 待删除的结点</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">remove</span>(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根为空 或者 没有要删除的节点，直接返回NULL。</span></span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span> || z==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z-&gt;key &lt; tree-&gt;key)        <span class="comment">// 待删除的节点在&quot;tree的左子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *r =  tree-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(r-&gt;left) &gt; <span class="built_in">height</span>(r-&gt;right))</span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; tree-&gt;key)<span class="comment">// 待删除的节点在&quot;tree的右子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *l =  tree-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(l-&gt;right) &gt; <span class="built_in">height</span>(l-&gt;left))</span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// tree是对应要删除的节点。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// tree的左右孩子都非空</span></span><br><span class="line">        <span class="keyword">if</span> ((tree-&gt;left!=<span class="literal">NULL</span>) &amp;&amp; (tree-&gt;right!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) &gt; <span class="built_in">height</span>(tree-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树比右子树高；</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的左子树中的最大节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最大节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最大节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的左子树中最大节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的左子树中最大节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* max = <span class="built_in">maximum</span>(tree-&gt;left);</span><br><span class="line">                tree-&gt;key = max-&gt;key;</span><br><span class="line">                tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的右子树中的最小节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最小节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最小节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的右子树中最小节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的右子树中最小节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* min = <span class="built_in">maximum</span>(tree-&gt;right);</span><br><span class="line">                tree-&gt;key = min-&gt;key;</span><br><span class="line">                tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt;* tmp = tree;</span><br><span class="line">            tree = (tree-&gt;left!=<span class="literal">NULL</span>) ? tree-&gt;left : tree-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        mRoot = <span class="built_in">remove</span>(mRoot, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁AVL树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">destroy</span>(AVLTreeNode&lt;T&gt;* &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">destroy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值</span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">print</span>(AVLTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="AVL树的C-测试程序">AVL树的C++测试程序</h3>
<p>AVL树的测试程序(AVLTreeTest.cpp)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C 语言: AVL树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AVLTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]= &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,ilen;</span><br><span class="line">    AVLTree&lt;<span class="keyword">int</span>&gt;* tree=<span class="keyword">new</span> AVLTree&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 依次添加: &quot;</span>;</span><br><span class="line">    ilen = <span class="built_in">TBL_SIZE</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree-&gt;<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 前序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">preOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 后序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 高度: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">height</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最小值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">minimum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最大值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">maximum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    i = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 删除根节点: &quot;</span> &lt;&lt; i;</span><br><span class="line">    tree-&gt;<span class="built_in">remove</span>(i);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 高度: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">height</span>() ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span> ;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    tree-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试程序中，首先新建一棵AVL树，然后依次添加&quot;3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9&quot; 到AVL树中；添加完毕之后，再将8从AVL树中删除。AVL树的添加和删除过程如下图：</p>
<p>（1）添加3，2</p>
<p>添加3,2都不会破坏AVL树的平衡性。</p>
<p><img src="https://i.loli.net/2021/04/24/aEdgWLZP8Ap75rG.jpg" alt="AVL树添加.jpg"></p>
<p>（2）添加1</p>
<p>添加1之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/7ri9ZjB8Yvn6mtR.jpg" alt="AVL树添加1.jpg"></p>
<p>（3）添加4</p>
<p>添加4不会破坏AVL树的平衡性。</p>
<p><img src="https://i.loli.net/2021/04/24/9nFBqGp26DamJoZ.jpg" alt="AVL树添加4.jpg"></p>
<p>（4）添加5</p>
<p>添加5之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/LXYtNRobH67m5f2.jpg" alt="AVL树添加5.jpg"></p>
<p>（5）添加6</p>
<p>添加6之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/eCARwU14Ls6aJnW.jpg" alt="AVL树添加6.jpg"></p>
<p>（6）添加7</p>
<p>添加7之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/PGHOciX8SsCLQNT.jpg" alt="AVL树添加7.jpg"></p>
<p>（7）添加16</p>
<p>添加16不会破坏AVL树的平衡性。</p>
<p><img src="https://i.loli.net/2021/04/24/wvUnltTVyJGCAiH.jpg" alt="AVL树添加16.jpg"></p>
<p>（8）添加15</p>
<p>添加15之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/HWtKz1arZUpCyBV.jpg" alt="AVL树添加15.jpg"></p>
<p>（9）添加14</p>
<p>添加14之后，AVL树失去平衡(RL)，此时需要对AVL树进行旋转(RL旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/WUSHAE6aF38oxem.jpg" alt="添加14.jpg"></p>
<p>（10）添加13</p>
<p>添加13之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/gxRGLJrBm3czlVi.jpg" alt="添加13.jpg"></p>
<p>（11）添加12</p>
<p>添加12之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/O2VKjyRtSAg7CnW.jpg" alt="添加12.jpg"></p>
<p>（12）添加11</p>
<p>添加11之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/M8GOBHCqQdbS1h4.jpg" alt="添加11.jpg"></p>
<p>（13）添加10</p>
<p>添加10之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/Kd5xqlpBXH6mZsY.jpg" alt="添加10.jpg"></p>
<p>（14）添加8</p>
<p>添加8不会破坏AVL树的平衡性。</p>
<p><img src="https://i.loli.net/2021/04/24/Cxj8VIoKGtmBfTQ.jpg" alt="添加8.jpg"></p>
<p>（15）添加9</p>
<p>但是添加9之后，AVL树失去平衡(LR)，此时需要对AVL树进行旋转(LR旋转)。旋转过程如下：</p>
<p><img src="https://i.loli.net/2021/04/24/9IZhmeOAgvF7fQk.jpg" alt="添加9.jpg"></p>
<p>添加完所有数据之后，得到的AVL树如下：</p>
<p><img src="https://i.loli.net/2021/04/24/clPHkEVin4NtKuT.jpg" alt="添加完成.jpg"></p>
<p>接着，删除节点8.删除节点8并不会造成AVL树的不平衡，所以不需要旋转，操作示意图如下：</p>
<p><img src="https://i.loli.net/2021/04/24/O1FhPXeyRWk2Kn4.jpg" alt="删除8.jpg"></p>
<p>程序运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">== 依次添加: 3 2 1 4 5 6 7 16 15 14 13 12 11 10 8 9 </span><br><span class="line">== 前序遍历: 7 4 2 1 3 6 5 13 11 9 8 10 12 15 14 16 </span><br><span class="line">== 中序遍历: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 </span><br><span class="line">== 后序遍历: 1 3 2 5 6 4 8 10 9 12 11 14 16 15 13 7 </span><br><span class="line">== 高度: 5</span><br><span class="line">== 最小值: 1</span><br><span class="line">== 最大值: 16</span><br><span class="line">== 树的详细信息: </span><br><span class="line">is root</span><br><span class="line">is  7&#x27;s   left child</span><br><span class="line">is  4&#x27;s   left child</span><br><span class="line">is  2&#x27;s   left child</span><br><span class="line">is  2&#x27;s  right child</span><br><span class="line">is  4&#x27;s  right child</span><br><span class="line">is  6&#x27;s   left child</span><br><span class="line">is  7&#x27;s  right child</span><br><span class="line">is 13&#x27;s   left child</span><br><span class="line">is 11&#x27;s   left child</span><br><span class="line">is  9&#x27;s   left child</span><br><span class="line">is  9&#x27;s  right child</span><br><span class="line">is 11&#x27;s  right child</span><br><span class="line">is 13&#x27;s  right child</span><br><span class="line">is 15&#x27;s   left child</span><br><span class="line">is 15&#x27;s  right child</span><br><span class="line"></span><br><span class="line">== 删除根节点: 8</span><br><span class="line">== 高度: 5</span><br><span class="line">== 中序遍历: 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 </span><br><span class="line">== 树的详细信息: </span><br><span class="line">is root</span><br><span class="line">is  7&#x27;s   left child</span><br><span class="line">is  4&#x27;s   left child</span><br><span class="line">is  2&#x27;s   left child</span><br><span class="line">is  2&#x27;s  right child</span><br><span class="line">is  4&#x27;s  right child</span><br><span class="line">is  6&#x27;s   left child</span><br><span class="line">is  7&#x27;s  right child</span><br><span class="line">is 13&#x27;s   left child</span><br><span class="line">is 11&#x27;s   left child</span><br><span class="line">is  9&#x27;s  right child</span><br><span class="line">is 11&#x27;s  right child</span><br><span class="line">is 13&#x27;s  right child</span><br><span class="line">is 15&#x27;s   left child</span><br><span class="line">is 15&#x27;s  right child</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>对AVL树的理论知识进行简单介绍，给出C++实现，并对实现代码进行了测试。</p>
<blockquote>
<p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3577360.html">https://www.cnblogs.com/skywang12345/p/3577360.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构及实现</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
        <tag>AVL树旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>经典算法：基于行程的连通域标记算法</title>
    <url>/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%A8%8B%E7%9A%84%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>引言：本文介绍一种用于二值图像或者占空图的聚类算法，并给出c++实现。</p>
<span id="more"></span>
<h3 id="介绍">介绍</h3>
<p>Two-Pass算法是一种基于行程的二值图像连通域标记算法，matlab中连通区域标记函数bwlabel中使用的就是该算法，其算法流程如下：</p>
<blockquote>
<p>1，逐行扫描图像，我们把每一行中连续的白色像素组成一个序列称为一个团(run)，并记下它的起点start、它的终点end以及它所在的行号。</p>
<p>2，对于除了第一行外的所有行里的团，如果它与前一行中的所有团都没有重合区域，则给它一个新的标号；如果它仅与上一行中一个团有重合区域，则将上一行的那个团的标号赋给它；如果它与上一行的2个以上的团有重叠区域，则给当前团赋一个相连团的最小标号，并将上一行的这几个团的标记写入等价对，说明它们属于一类。</p>
<p>3，将等价对转换为等价序列，每一个序列需要给一相同的标号，因为它们都是等价的。从1开始，给每个等价序列一个标号。</p>
<p>4，遍历开始团的标记，查找等价序列，给予它们新的标记。</p>
<p>5，将每个团的标号填入标记图像中。</p>
<p>6，结束。</p>
</blockquote>
<h3 id="实现">实现</h3>
<p>下面给出其c++实现，主要分四步进行：</p>
<p>第一步：查找所有团并记录，需要记录团所在的行号、团开始的位置、结束的位置，当然还有一个表征团总数的变量。需要注意的就是团开始位置和结束位置在行首和行末的情况要单独拿出来考虑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillRunVectors</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bimage, <span class="keyword">int</span>&amp; NumberOfRuns, std::vector&lt;<span class="keyword">int</span>&gt;&amp; stRun, std::vector&lt;<span class="keyword">int</span>&gt;&amp; enRun, std::vector&lt;<span class="keyword">int</span>&gt;&amp; rowRun, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rows, <span class="keyword">const</span> <span class="keyword">int</span>&amp; cols, std::vector&lt;<span class="keyword">int</span>&gt;&amp; label_map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; rowData = bimage[i];</span><br><span class="line">        <span class="keyword">if</span> (rowData[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            NumberOfRuns++;</span><br><span class="line">            stRun.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">            rowRun.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            label_map[i * cols] = NumberOfRuns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_idx = i * cols + j;</span><br><span class="line">            <span class="keyword">if</span> (rowData[j<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; rowData[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                NumberOfRuns++;</span><br><span class="line">                stRun.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                rowRun.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                label_map[cur_idx] = NumberOfRuns;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowData[j<span class="number">-1</span>] == <span class="number">1</span> &amp;&amp; rowData[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                enRun.<span class="built_in">emplace_back</span>(j<span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowData[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                label_map[cur_idx] = NumberOfRuns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowData[cols - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            enRun.<span class="built_in">emplace_back</span>(cols - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：遍历所有的团，完成团的标记与等价对列表的生成。这里判断团是否相邻的关键条件是：一个团的开始位置小于另一个团的结束位置，且结束位置大于另一个团的开始位置。 这里的equivalences 用于存储等价对，offset：0对应四连通，1对应八连通。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stRun, vector&lt;<span class="keyword">int</span>&gt;&amp; enRun, vector&lt;<span class="keyword">int</span>&gt;&amp; rowRun, <span class="keyword">int</span> NumberOfRuns, vector&lt;<span class="keyword">int</span>&gt;&amp; runLabels, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; equivalences, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idxLabel = <span class="number">1</span>;    <span class="comment">// 标记编号</span></span><br><span class="line">    <span class="keyword">int</span> curRowIdx = <span class="number">0</span>;    <span class="comment">// 当前所在行   </span></span><br><span class="line">    <span class="keyword">int</span> firstRunOnCur = <span class="number">0</span>;    <span class="comment">// 当前行的第一个团索引</span></span><br><span class="line">    <span class="keyword">int</span> firstRunOnPre = <span class="number">0</span>;    <span class="comment">// 前一行的第一个团索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRunOnPre = <span class="number">-1</span>;    <span class="comment">// 前一行的最后一个团索引</span></span><br><span class="line">    <span class="comment">// 初始化每个团的标签都为0</span></span><br><span class="line">    runLabels.<span class="built_in">assign</span>(NumberOfRuns, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfRuns; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rowRun[i] != curRowIdx) &#123;</span><br><span class="line">            <span class="comment">// 换行后更新状态变量</span></span><br><span class="line">            curRowIdx = rowRun[i];</span><br><span class="line">            firstRunOnPre = firstRunOnCur;</span><br><span class="line">            lastRunOnPre = i - <span class="number">1</span>;</span><br><span class="line">            firstRunOnCur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相邻行不存在团</span></span><br><span class="line">        <span class="keyword">if</span>（curRowIdx != rowRun[lastRunOnPre] + <span class="number">1</span>） &#123;</span><br><span class="line">            runLabels[i] = idxLabel++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对前一行进行遍历，检查是否有相邻的团</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = firstRunOnPre; j &lt;= lastRunOnPre; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stRun[i] &lt;= enRun[j] + offset &amp;&amp; enRun[i] &gt;= stRun[j] - offset) &#123;</span><br><span class="line">                <span class="comment">// 之前没有被标记过，即j是上一行第一个与当前团相邻的</span></span><br><span class="line">                <span class="keyword">if</span> (runLabels[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    runLabels[i] = runLabels[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLabels[i] != runLabels[j]) &#123;</span><br><span class="line">                    equalLabels.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_pair</span>(runLabels[i], runLabels[j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有与前一列如何run重合</span></span><br><span class="line">        <span class="keyword">if</span> (runLabels[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            runLabels[i] = idxLabel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步：将等价对处理成等价序列，比如有如下等价对：(1,2),(1,6),(3,7),(9-3),(8,1),(8,10),(11,5),(11,8),(11,12),(11,13),(11,14),(15,11)，得到的最终序列是：</p>
<p>list1：1-2-5-6-8-10-11-12-13-14-15</p>
<p>list2：3-7-9</p>
<p>list3：4</p>
<p>这里还是采用DFS思想，c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSameLabel</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; runLabels, std::vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; equivalence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLabel = *std::<span class="built_in">max_element</span>(runLabels.<span class="built_in">begin</span>(), runLabels.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 等价标签矩阵，值为true表示这两个标签等价</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">eqTab</span>(maxLabel, std::vector&lt;<span class="keyword">bool</span>&gt;(maxLabel, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 将等价对信息转移到矩阵上</span></span><br><span class="line">    std::vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator vecPairIt = equivalence.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (vecPairIt != equivalence.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        eqTab[vecPairIt-&gt;first - <span class="number">1</span>][vecPairIt-&gt;second - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        eqTab[vecPairIt-&gt;second - <span class="number">1</span>][vecPairIt-&gt;first - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        vecPairIt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标签映射，会将上一步团的标号映射到序列的标号，也是这一步的关键结果。</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">labelFlag</span><span class="params">(maxLabel, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 等价标签队列</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; tempList;</span><br><span class="line">    <span class="comment">// 当前使用的标签</span></span><br><span class="line">    <span class="keyword">int</span> curLabel = <span class="number">1</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxLabel; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果该标签已被映射，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (labelFlag[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        labelFlag[i - <span class="number">1</span>] = curLabel;</span><br><span class="line">        tempList.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="comment">// 在所有标签中寻找与当前标签等价的标签(这里可以换成栈操作，和floodfill类似) </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tempList.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= maxLabel; ++k) &#123;</span><br><span class="line">                <span class="comment">// 等价且未访问</span></span><br><span class="line">                <span class="keyword">if</span> (eqTab[tempList[j] - <span class="number">1</span>][k - <span class="number">1</span>] &amp;&amp; labelFlag[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                   labelFlag[k - <span class="number">1</span>] = curLabel;</span><br><span class="line">                   tempList.<span class="built_in">emplace_back</span>(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curLabel++;</span><br><span class="line">        tempList.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据映射修改标签</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = runLabels.<span class="built_in">begin</span>(); itr != runLabels.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        *itr = labelFlag[*itr - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步：填充二值图中每个栅格的标签。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillLabel</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; runLabels, std::vector&lt;<span class="keyword">int</span>&gt;&amp; label_map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; label_map.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (label_map[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        label_map[i] = runLabels[label_map[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>该算法本质上和floodFill算法是一样的，区别在于floodFill是对每个栅格进行深度优先搜索，而这个是对团进行深度优先搜索。另外，在算法的第三步在对等价对进行合并时，可以用并查集进行优化，也可以用稀疏矩阵与Dulmage-Mendelsohn分解算法用来消除等价对（matlab中的做法），比较复杂。</p>
]]></content>
      <categories>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>聚类</tag>
        <tag>连通域标记</tag>
      </tags>
  </entry>
  <entry>
    <title>经典算法：拉默-道格拉斯-普克算法</title>
    <url>/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>引言：本文主要介绍RDP算法。道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。</p>
<span id="more"></span>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li>连接曲线首尾两点A、B形成一条直线AB；<br>
2. 计算曲线上离该直线段距离最大的点C，计算其与AB的距离d；</li>
<li>比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则以该直线作为曲线的近似，该段曲线处理完毕。</li>
<li>如果距离大于阈值，则用点C将曲线分为两段AC和BC，并分别对两段曲线进行步骤[1~3]的处理。</li>
<li>当所有曲线都处理完毕后，依次连接各个分割点形成折线，作为原曲线的近似。</li>
</ol>
<h3 id="实现">实现</h3>
<h4 id="实现一">实现一</h4>
<p>下面采用 C++实现，是一个DFS深搜的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; in_pts, </span></span></span><br><span class="line"><span class="function"><span class="params">         std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">float</span> epsilon = <span class="number">0.1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = in_pts.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">mask</span><span class="params">(size, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    std::pair&lt;int, int&gt; pts_pair(0, size-1);</span><br><span class="line">    std::stack&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(pts_pair);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur_pair = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">float</span> dmax = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur_pair.first + <span class="number">1</span>; i &lt; cur_pair.second; ++i) &#123;</span><br><span class="line">            <span class="keyword">float</span> d = <span class="built_in">getPerpendicularDistance</span>(in_pts[cur_pair.first], in_pts[cur_pair.second], in_pts[i]);</span><br><span class="line">            <span class="keyword">if</span> (d &gt; dmax) &#123;</span><br><span class="line">                dmax = d;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dmax &gt; epsilon) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cur_pair.first, i));</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, cur_pair.second));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mask[cur_pair.first] = <span class="literal">true</span>;</span><br><span class="line">            mask[cur_pair.second] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(size);</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i]) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getPerpendicularDistance()函数是求点到线的距离函数，有两种方法，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：利用点到直线的距离公式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, maxDist = <span class="number">0</span>;</span><br><span class="line">    A = lineEnd.y - lineStart.y;</span><br><span class="line">    B = lineStart.x - lineEnd.x;</span><br><span class="line">    C = lineEnd.x * lineStart.y - lineStart.x * lineEnd.y;</span><br><span class="line">    maxDist = <span class="built_in">fabs</span>((A * pt.x + B * pt.y + C) / <span class="built_in">sqrt</span>(A * A + B *B));</span><br><span class="line">    <span class="keyword">return</span> maxDist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：利用向量运算</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = lineEnd.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> dy = lineEnd.y - lineStart.y;</span><br><span class="line">    <span class="keyword">float</span> mag = std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(dx, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(dy, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (mag &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        dx /= mag;</span><br><span class="line">        dy /= mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> pvx = pt.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> pvy = pt.y - lineStart.y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> pvdot = dx * pvx + dy * pvy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> dsx = pvdot * dx;</span><br><span class="line">    <span class="keyword">float</span> dsy = pvdot * dy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> ax = pvx - dsx;</span><br><span class="line">    <span class="keyword">float</span> ay = pvy - dsy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(ax, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(ay, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现二">实现二</h4>
<p>有时需要对polygon（闭合）的点数进行限制，抽取出固定数量的点，这种情况下，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifiedRDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt; &amp;in_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> n_pts = <span class="number">64</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>()) &lt;= n_pts) &#123;</span><br><span class="line">        out_pts = in_pts;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SimData</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l_idx;</span><br><span class="line">        <span class="keyword">int</span> r_idx;</span><br><span class="line">        <span class="keyword">float</span> epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">std::vector&lt;SimData&gt; <span class="title">mask</span><span class="params">(in_pts.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;sim_data = mask[i];</span><br><span class="line">        sim_data.l_idx = i - <span class="number">1</span>;</span><br><span class="line">        sim_data.r_idx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            sim_data.l_idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i) == <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            sim_data.r_idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sim_data.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[i], in_pts[sim_data.l_idx], in_pts[sim_data.r_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> comp = [](<span class="keyword">const</span> SimData &amp;i, <span class="keyword">const</span> SimData &amp;j) &#123;</span><br><span class="line">        <span class="keyword">return</span> i.epsilon &lt; j.epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (cc &gt; n_pts) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = std::<span class="built_in">min_element</span>(mask.<span class="built_in">begin</span>(), mask.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(std::<span class="built_in">distance</span>(mask.<span class="built_in">begin</span>(), res));</span><br><span class="line">        <span class="comment">// 找到距离最小的点，标记并把其距离置为无穷大</span></span><br><span class="line">        maks[idx].flag = <span class="literal">false</span>;</span><br><span class="line">        mask[idx].epsilon = std::numeric_limits&lt;<span class="keyword">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        cc--;</span><br><span class="line">        <span class="comment">// 更新该点的左右邻居</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;l_mask = mask[res-&gt;l_idx];</span><br><span class="line">        l_mask.r_idx = res-&gt;r_idx;</span><br><span class="line">        l_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;l_idx], in_pts[l_mask.l_idx], in_pts[l_mask.r_idx]);</span><br><span class="line">        <span class="keyword">auto</span> &amp;r_mask = mask[res-&gt;r_idx];</span><br><span class="line">        r_mask.l_idx = res-&gt;l_idx;</span><br><span class="line">        r_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;r_idx], in_pts[r_mask.l_idx], in_pts[r_mask.l_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i].flag) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>本文主要总结了RDP算法的dfs实现，其原始版本是递归实现的，至于那个版本的实现更快，还需要进一步论述，但是在工程代码中，不推荐使用递归；点到直线的距离计算效率，也需要benchmark进行测试比较。</p>
]]></content>
      <categories>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>几何算法</tag>
        <tag>拉默-道格拉斯-普克算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：单例模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>引言：本文主要介绍设计模式中的单例模式，并给出C++实现。</p>
<span id="more"></span>
<h3 id="介绍">介绍</h3>
<p>单例模式也称为单件模式、单子模式，可能是使用最广泛的设计模式。其意图是**保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。**有很多地方需要这样的功能模块，如系统的日志输出，操作系统只能有一个任务管理器，一台PC连一个键盘，工程中的通用配置类等。</p>
<h3 id="实现">实现</h3>
<h4 id="实现一">实现一</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先检查对象是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(); <span class="comment">//私有构造函数，不允许使用者自己生成对象</span></span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance; <span class="comment">//静态成员变量 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用户访问唯一实例的方法只有getInstance()成员函数。如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的。getInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的 。这是一种防弹设计——所有getInstance()之后的调用都返回相同实例的指针。</p>
<p>这种实现方法有以下几个特点：</p>
<ul>
<li>它有一个指向唯一实例的静态指针m_instance，并且是私有的；</li>
<li>它有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；</li>
<li>它的构造函数是私有的，这样就不能从别处创建该类的实例。</li>
</ul>
<p>但是这种实现方法存在两个问题：一是m_instance指向的空间是动态分配的，需要显式进行释放；二是这种方法不是线程安全的。对于第一个问题，可能有人会说，直接在析构函数中进行delete就可以释放了啊，但是这样会存在问题，因为**在类的析构函数中delete类自身实例的指针，delete又会调用析构函数，这样就会出现循环调用的问题，会造成栈内存溢出，因此编译器不允许这么做。**下面我们针对这两个问题一一进行分析</p>
<h4 id="实现二">实现二</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_instance;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>   //它的唯一工作就是在析构函数中删除<span class="title">CSingleton</span>的实例</span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGarbo</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Singleton::m_instance)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;  <span class="comment">//定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个妥善的方法是让这个类自己知道在合适的时候把自己删除，或者说把删除自己的操作挂在操作系统中的某个合适的点上，使其在恰当的时候被自动执行。我们知道，程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如上面的代码中的CGarbo类（Garbo意为垃圾工人），类CGarbo被定义为Singleton的私有内嵌类，以防该类被在其他地方滥用。<br>
程序运行结束时，系统会调用Singleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。<br>
使用这种方法释放单例对象有以下特征：</p>
<ul>
<li>在单例类内部定义专有的嵌套类；</li>
<li>在单例类内定义私有的专门用于释放的静态成员；</li>
<li>利用程序在结束时析构全局变量的特性，选择最终的释放时机；</li>
<li>使用单例的代码不需要任何操作，不必关心对象的释放。</li>
</ul>
<h4 id="实现三">实现三</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现二中添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如上，使用<strong>局部静态变量</strong>，非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。但使用此种方法也会出现问题，当如下方法使用单例时问题来了：</p>
<p><code>Singleton singleton = Singleton :: getInstance();</code></p>
<p>这么做就出现了一个类拷贝的问题，这就违背了单例的特性。产生这个问题原因在于：编译器会为类生成一个默认的拷贝构造函数，来支持类的拷贝。最后没有办法，我们要禁止类拷贝和类赋值，禁止程序员用这种方式来使用单例，所以可以让getInstance()返回一个指针，代码变成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以显式禁用类的拷贝构造函数和赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="实现四">实现四</h4>
<p>我们从头到尾都还没考虑线程安全问题，但是如果使用实现三的方法，就避免了线程安全，这是因为：<strong>在c++ 11新标准中，静态局部变量是线程安全的</strong>。所以最终的单例模式实现版本为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式（C++）</category>
      </categories>
      <tags>
        <tag>静态局部变量</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>详解C++拷贝构造函数和赋值运算符</title>
    <url>/%E8%AF%A6%E8%A7%A3C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>引言：本文主要介绍了拷贝构造函数和赋值运算符的区别，以及在什么时候调用拷贝构造函数、什么情况下调用赋值运算符；同时较为详细的说明了拷贝构造函数必须以引用的方式传递参数。</p>
<span id="more"></span>
<h3 id="1-拷贝构造函数和拷贝赋值运算符">1.拷贝构造函数和拷贝赋值运算符</h3>
<p>在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但用户可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示无法调用该函数，它是已删除的函数。</p>
<h3 id="2-何时调用">2.何时调用</h3>
<p>拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值<strong>生成一个新的对象的实例</strong>，而赋值运算符是将对象的值复制给一个<strong>已经存在的实例</strong>。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是<strong>创建一个新的对象实例</strong>；赋值运算符是执行某种运算，将一个对象的值复制给另一个<strong>已经存在的对象</strong>。<strong>调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。</strong></p>
<p><strong>调用拷贝构造函数主要有以下场景：</strong></p>
<ul>
<li>对象作为函数的参数，以值传递的方式传给函数；</li>
<li>对象作为函数的返回值，以值的方式从函数返回；</li>
<li>使用一个对象给另一个对象初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Assign operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do1</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">do2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    Person p1 = p;			<span class="comment">// 第一种情况</span></span><br><span class="line">    Person p2;</span><br><span class="line">    p2 = p; 				<span class="comment">// 第二种情况</span></span><br><span class="line">    <span class="built_in">do1</span>(p2); 				<span class="comment">// 第三种情况</span></span><br><span class="line">    p2 = <span class="built_in">do2</span>(); 			<span class="comment">// 第四种情况</span></span><br><span class="line">    Person p3 = <span class="built_in">do2</span>();		<span class="comment">// 第五种情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个类Person，显式的定义了拷贝构造函数和赋值运算符。然后定义了两个函数：do1以值传递的方式将对象作为函数的参数传入函数；do2以值的方式返回Person对象。执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种情况： Copy Constructor</span><br><span class="line">第二种情况： Assign operator</span><br><span class="line">第三种情况： Copy Constructor</span><br><span class="line">第四种情况： Copy Constructor</span><br><span class="line">           Assign operator</span><br><span class="line">第五种情况： Copy Constructor</span><br></pre></td></tr></table></figure>
<p>分析如下：</p>
<p>第一种情况：使用已经存在的对象p创建新对象p1，产生了新对象，所以调用拷贝构造函数；</p>
<p>第二种情况：将对象p的值复制给已经存在的对象p2，为一个已经存在的对象赋值，所以调用赋值运算符；</p>
<p>第三种情况：以值传递的方式将对象p2传入函数内，所以是调用拷贝构造函数创建一个函数do1可用的实参；</p>
<p>第四种情况：函数do2以值的方式返回一个对象，由于这是一个局部对象，声明周期在函数内，所以返回的是一个它的拷贝，具体就是在返回时调用拷贝构造函数创建一个临时对象作为返回值；返回后调用赋值运算符将该临时对象复制给已经存在的对象p2；所以先调用拷贝构造函数，再调用赋值运算符；</p>
<p>第五种情况：按理来说应该先调用一次拷贝构造函数创建临时对象，再调用拷贝构造函数用临时对象创建新对象p3，调用两次拷贝构造函数，但是这实际上只调用了一次拷贝构造函数，这是因为直接在函数返回时调用拷贝构造函数创建了对象p3，因为编译器认为返回临时对象这一步是多余的，直接把p3当做了“临时对象”。</p>
<h3 id="3-拷贝构造函数必须以引用的方式传递参数">3.拷贝构造函数必须以引用的方式传递参数</h3>
<p>这一点要特别注意，即拷贝构造函数的形参必须是引用或者常引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p)</span><br></pre></td></tr></table></figure>
<p>而不能是值或者指针，下面分别对以值的方式传递参数和以指针的方式传递参数进行分析。</p>
<p>1.以值的方式传递参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person p)</span><br></pre></td></tr></table></figure>
<p>看起来好像和传引用的方式相比只是减少了一次内存拷贝，其实实际上不是这样的。这种情况编译器会报错，原因是<strong>在以值的方式传递参数的时候，会调用拷贝构造函数生成函数的实参，但是拷贝构造函数的参数是值的方式，将会继续调用拷贝构造函数，这样就会无限递归的调用下去，直到函数的栈溢出</strong>，所以值的方式传递参数是编译器绝对不允许的。</p>
<p>上面这句话可能一下子不太容易理解，没关系，下面我们详细的进行分析。</p>
<p>在进行值传递参数的时候，会调用拷贝构造函数对实参(假设实参为p)进行一次拷贝，假设新生成的对象叫做tmp，即<code>Person tmp = p</code>，tmp是一个新对象，根据上面的分析，我们知道在进行这个操作的时候，也会调用拷贝构造函数，但是拷贝构造函数的参数是值啊，值传递参数又会调用拷贝构造函数进行拷贝，生成新对象又会调用拷贝构造函数…，这样就会无限循环下去。</p>
<p>2.以指针的方式传递参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person* p)</span><br></pre></td></tr></table></figure>
<p>恩，这种方式的确不会报错，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A* test) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = test-&gt;a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(&amp;a)</span></span>;</span><br><span class="line">    b.<span class="built_in">printA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in constructor</span><br><span class="line">in copy constructor</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>确实是调用了拷贝构造函数，但是<code>A(A* test)</code>真的是拷贝构造函数吗？答案是否定的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(A* test) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = test-&gt;a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(&amp;a)</span></span>;</span><br><span class="line">    A c = a;</span><br><span class="line">    b.<span class="built_in">printA</span>();</span><br><span class="line">    c.<span class="built_in">printA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in constructor</span><br><span class="line">in copy constructor</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>发现<code>in copy constructor</code>只打印了一次，也就是说<code>A c = a;</code>并没有调用<code>A(A* test)</code>，那调用的拷贝构造函数是哪个呢？毫无疑问，是默认拷贝构造函数，默认拷贝构造函数还存在，说明<code>A(A* test)</code>并不是拷贝构造函数。</p>
<h3 id="4-总结">4.总结</h3>
<p>1.区分调用拷贝构造函数还是拷贝赋值运算符的依据是看是否生成了新对象，生成，拷贝构造函数，不生成，赋值运算符；<br>
2.调用拷贝构造函数的三种情况：值传递，值方式返回局部对象，使用一个已有对象初始化一个新对象；<br>
3.拷贝构造函数必须以引用的方式传递参数，因为值方式会造成栈区溢出，编译器不允许；指针方式根本不是拷贝构造函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>拷贝构造函数</tag>
        <tag>拷贝复制运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>详解roi-pooling和roi-align</title>
    <url>/%E8%AF%A6%E8%A7%A3roi-pooling%E5%92%8Croi-align/</url>
    <content><![CDATA[<p>引言：roi pooling和roi align是二阶段方法中常用的操作，本文总结二者的具体操作和不同。</p>
<span id="more"></span>
<h3 id="概述">概述</h3>
<p>这两个都是用在rpn之后的。具体来说，从feature map上经过RPN得到一系列的proposals，大概2k个，这些bbox大小不等，如何将这些bbox的特征进行统一表示就变成了一个问题。即需要找一个办法从大小不等的框中提取特征使输出结果是等长的。最开始目标检测模型Faster RCNN中用了一个简单粗暴的办法，叫ROI Pooling。该方式在语义分割这种精细程度高的任务中，不够精准，由此发展来了ROI Align。今天就总结下两者的思想。</p>
<h3 id="ROI-Pooling">ROI Pooling</h3>
<p><img src="https://i.loli.net/2021/04/29/NDle8s1MuZ3PLoy.jpg" alt="v2-d59199c554ac7ccfbd2038317aef74f2_720w.jpg"></p>
<p>假如现在有一个8x8的feature map，现在希望得到2x2的输出，有一个bbox坐标为[0,3,7,8]。这个bbox的w=7，h=5，如果要等分成四块是做不到的，因此在ROI Pooling中会进行取整。就有了上图看到的h被分割为2,3，w被分割成3,4。这样之后在每一块(称为bin)中做max pooling，可以得到下图的结果。</p>
<p><img src="https://i.loli.net/2021/04/29/4GFZSEMVO7Uq1ot.jpg" alt="v2-7b39628bb13db683b6de701f5b4169f8_720w.jpg"></p>
<p>这样就可以将任意大小bbox转成2x2表示的feature。ROI Pooling需要取整，这样的取整操作进行了两次，一次是得到bbox在feature map上的坐标时。例如：原图上的bbox大小为665x665，经backbone后，spatial scale=1/32。因此bbox也相应应该缩小为665/32=20.78，但是这并不是一个真实的pixel所在的位置，因此这一步会取为20。0.78的差距反馈到原图就是0.78x32=25个像素的差距。如果是大目标这25的差距可能看不出来，但对于小目标而言差距就比较巨大了。</p>
<p><img src="https://i.loli.net/2021/04/29/HoVqSw6Y1EvWysp.jpg" alt="v2-6f3dc5f450e6c936869595eaf66a0f4d_720w.jpg"></p>
<h3 id="ROI-Align">ROI Align</h3>
<p>因此有人提出不需要进行取整操作，如果计算得到小数，也就是没有落到真实的pixel上，那么就用最近的pixel对这一点虚拟pixel进行双线性插值，得到这个“pixel”的值。具体做法如下图所示：</p>
<p><img src="https://i.loli.net/2021/04/29/gQnhUMLuG3ZVr28.jpg" alt="v2-03d820b27ffca39854f0febf0ef9e37b_r.jpg"></p>
<ol>
<li>将bbox区域按输出要求的size进行等分，很可能等分后各顶点落不到真实的像素点上</li>
<li>没关系，在每个bin中再取固定的4个点(作者实验后发现取4效果较好)，也就是图二右侧的蓝色点</li>
<li>针对每一个蓝点，距离它最近的4个真实像素点的值加权(双线性插值)，求得这个蓝点的值</li>
<li>一个bin内会算出4个新值，在这些新值中取max，作为这个bin的输出值</li>
<li>最后就能得到2x2的输出</li>
</ol>
<blockquote>
<p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/73138740">https://zhuanlan.zhihu.com/p/73138740</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>roi-pooling</tag>
        <tag>roi-align</tag>
      </tags>
  </entry>
  <entry>
    <title>经典算法：简化的漫水填充算法</title>
    <url>/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AE%80%E5%8C%96%E7%9A%84%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>引言：本文介绍简化的漫水填充算法，用于二值图像聚类或者点云栅格聚类，并给出了c++实现。</p>
<span id="more"></span>
<h3 id="介绍">介绍</h3>
<p>floodFill，又叫seedfill，译作漫水填充算法，或者泛洪算法，其在opencv中进行了实现，参考<a href="https://github.com/opencv/opencv/blob/master/modules/imgproc/src/floodfill.cpp">这里</a>。</p>
<p>漫水填充法是一种用特定的颜色填充联通区域，通过设置可连通像素的上下限以及连通方式来达到不同的填充效果的方法。漫水填充经常被用来标记或分离图像的一部分以便对其进行进一步处理或分析，简而言之，漫水填充就是查找和种子点联通的颜色相同或者相近的点，ps的魔棒工具就是以该算法为基础的。</p>
<p>对于点云栅格化后的二值占空图，也可以采用该算法查找出与种子栅格联通的栅格，遍历所有种子点（非空点），就可以得到不同的簇。</p>
<h3 id="实现">实现</h3>
<p>下面给出该算法对二值图进行聚类的c++实现，其实质是一个DFS，优先地寻找一个完整连通域，在找的同时把他们都标记一下，找完一个完整连通域， 再去找下一个连通域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cols = <span class="number">2048</span>, rows = <span class="number">1024</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">seed_map</span><span class="params">(cols * rows, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 遍历点云初始化seed_map，有点为1，无点为0</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; label_map;</span><br><span class="line">label_map.<span class="built_in">resize</span>(cols * rows, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> tot_num_obj = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = row * cols + col;</span><br><span class="line">        <span class="keyword">if</span> (seed_map[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;    <span class="comment">// 跳过空栅格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (label_map[idx] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;    <span class="comment">// 跳过已经被标记的栅格</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::stack&lt;Eigen::Vector2i&gt; neighbor_grids;</span><br><span class="line">        Eigen::Vector2i tmp_grid;</span><br><span class="line">        tmp_grid &lt;&lt; col, row;</span><br><span class="line">        neighbor_grids.<span class="built_in">push</span>(tmp_grid);</span><br><span class="line">        tot_num_obj++;</span><br><span class="line">        label_map[idx] = tot_num_obj;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!neighbor_grids.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Eigen::Vector2i cur_grid = neighbor_grids.<span class="built_in">top</span>();</span><br><span class="line">            neighbor_grids.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_grid.x - <span class="number">1</span>; i &lt;= cur_grid.x + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= cols) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = cur_grid.y - <span class="number">1</span>; j &lt;= cur_grid.y + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt;= rows) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> tmp_idx = j * cols + i;</span><br><span class="line">                    <span class="keyword">if</span> (seed_map[tmp_idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (label_map[tmp_idx] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    label_map[tmp_idx] = tot_num_obj;</span><br><span class="line">                    tmp_grid &lt;&lt; i, j;</span><br><span class="line">                    neighbor_grids.<span class="built_in">push</span>(tmp_grid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这样就对二值占空图的每个栅格进行了标记，得到了多个簇。</p>
]]></content>
      <categories>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>聚类</tag>
        <tag>floodfill</tag>
      </tags>
  </entry>
</search>
