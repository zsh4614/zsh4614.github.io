---
title: 经典算法：Floyd判圈算法
notshow: false
tags:
  - 判圈算法
categories:
  - 经典算法
abbrlink: fe9f58f0
date: 2022-01-15 17:21:19
---
引言：本文主要介绍一种常用的判圈算法，并给出其推导。

<!--more-->

### 简述

Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。

### 问题
如何检测一个链表是否有环，如果有，那么如何确定环的起点和环的长度。

1）判断是否有环？
龟兔解法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。

基于上面的想法，Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果时等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。

2）求环的长度
假设相遇点为B点,让其中一个指针停在B不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。

3）如何确定环的起点
假设相遇点为B点。方法是将其中一个指针移到链表起点，另一个指针为B点,两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。

### 证明
首先假设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m，环的长度为n，相遇的位置与起点与起点位置距离为k。于是有：

i = m + a * n + k

其中a为慢指针走的圈数。

因为快指针的速度是慢指针的2倍，于是又可以得到另一个式子：

2 * i = m + b * n + k

其中b为快指针走的圈数。

两式相减得：

i = ( b - a ) * n

也就是说i是圈长的整数倍。

这是将其中一个节点放在起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点i+m，i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。




