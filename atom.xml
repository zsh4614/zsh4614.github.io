<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到我的主页!</title>
  
  
  <link href="https://zsh4614.cn/atom.xml" rel="self"/>
  
  <link href="https://zsh4614.cn/"/>
  <updated>2022-02-14T13:33:14.993Z</updated>
  <id>https://zsh4614.cn/</id>
  
  <author>
    <name>zsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode第一百零四题：二叉树的最大深度</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-02-09T11:01:48.000Z</published>
    <updated>2022-02-14T13:33:14.993Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode第一百零一题：对称二叉树</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-02-09T10:23:54.000Z</published>
    <updated>2022-02-14T13:33:14.993Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一百零一题，判断一颗二叉树是不是对称二叉树，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/02/09/PZ82L4cjJNe5vqE.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/02/09/CW9zMkq8h3xZGYD.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>树中节点数目在范围 <code>[1, 1000]</code> 内</p></li><li><p><code>-100 &lt;= Node.val &lt;= 100</code></p></li></ul><h3 id="分析">分析</h3><p>这道题比较容易想到的一个思路就是递归，判断两个结点，左右儿子结点是否分别相等，这样递归下去；二叉树将递归改成迭代，首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><h3 id="实现">实现</h3><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* lhs, TreeNode* rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs &amp;&amp; !rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lhs || !rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lhs-&gt;val == rhs-&gt;val &amp;&amp; <span class="built_in">check</span>(lhs-&gt;left, rhs-&gt;right) &amp;&amp; <span class="built_in">check</span>(lhs-&gt;right, rhs-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p><strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* lhs, TreeNode* rhs)</span> </span>&#123;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(lhs);</span><br><span class="line">    queue.<span class="built_in">push</span>(rhs);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> l = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> r = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> ((!l || !r) || l-&gt;val != r-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        queue.<span class="built_in">push</span>(l-&gt;left);</span><br><span class="line">        queue.<span class="built_in">push</span>(r-&gt;right);</span><br><span class="line">        queue.<span class="built_in">push</span>(l-&gt;right);</span><br><span class="line">        queue.<span class="built_in">push</span>(r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一百零一题，判断一颗二叉树是不是对称二叉树，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="队列" scheme="https://zsh4614.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>PaperReading之数据对DL的影响</title>
    <link href="https://zsh4614.cn/PaperReading%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AF%B9DL%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>https://zsh4614.cn/PaperReading%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AF%B9DL%E7%9A%84%E5%BD%B1%E5%93%8D/</id>
    <published>2022-02-07T02:08:03.000Z</published>
    <updated>2022-02-14T13:33:14.994Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍ICCV2017论文《Revisiting Unreasonable Effectiveness of Data in Deep Learning Era》。</p><span id="more"></span><h3 id="综述">综述</h3><p>这篇论文主要介绍了作者在数据集大小对深度学习性能的影响，得出了一些结论。</p><h3 id="结论">结论</h3><p>结论一：增大数据集有助于提升表征学习的性能，也就是类似于CNN这种自动提取特征的学习受益于数据集的增大，而且数据集的规模可以战胜标签噪声，作者在JFT-300数据集上的实验证明了这一点，虽然数据集的标签中仍然有20%的噪声，但是增大数据集依然获得了预想中的性能提升。</p><p>结论二：任务表现与<strong>数据量级</strong>呈线性关系，即与数据量呈对数关系，对于JFT-300这么大的数据量，也没有出现平顶效应。</p><p>结论三：模型容量也很重要，在大规模数据量下，模型容量越大，也就是层数越多，收益越大。</p><p>结论四：数据量增加会带来更好的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍ICCV2017论文《Revisiting Unreasonable Effectiveness of Data in Deep Learning Era》。&lt;/p&gt;</summary>
    
    
    
    <category term="PaperReading" scheme="https://zsh4614.cn/categories/PaperReading/"/>
    
    
    <category term="data" scheme="https://zsh4614.cn/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>PaperReading之Vision Transformer(ViT)</title>
    <link href="https://zsh4614.cn/PaperReading-Vision-Transformer-ViT/"/>
    <id>https://zsh4614.cn/PaperReading-Vision-Transformer-ViT/</id>
    <published>2022-01-30T03:44:55.000Z</published>
    <updated>2022-02-14T13:33:14.993Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍ICLR2021论文《AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE》。</p><span id="more"></span><h3 id="概述">概述</h3><p>这篇文章，也就是大名鼎鼎的ViT，是把在NLP领域中炙手可热的transformer引入CV领域的开篇之作，也是经典的挖坑之作，值得精读。</p><h3 id="综述">综述</h3><p>作者开篇介绍了CNN在视觉领域的统治地位，启发于transformer在NLP领域的卓越表现，有人将自注意力机制嵌入CNN中，也有人用自注意力完全取代卷积，但是这些都经过了个性化的修改，目前还没有对应的加速算子。作者自己完全把transformer搬过来，不作任何修改，而是修改输入，他们把图像分成一个一个的patch平铺开，然后经过一个linear embedding，这样来模仿一个token，作为transformer的输入，并用监督方式训练了图像分类任务。</p><p>作者在小数据集上训练效果较差，他们认为主要是transformer没有了CNN的归纳偏置：局部相关性和平移等变性。这里的归纳偏置（inductive biases）其实就是人类的先验，在CNN的设计中很多地方体现了这种先验，比如卷积核，就是认为图像具有局部性，离得越近的像素相关性越强。transformer没有利用这种性质，所以在小数据集上学习不够充分，所以效果不好。</p><p>最后在大数据集ImageNet-21k和JFT-300M上预训练之后，然后在许多数据集上finetune都取得了超越CNN的效果。</p><h3 id="相关工作">相关工作</h3><p>先介绍了transformer在NLP领域的成果，GPT，BERT等。但是在CV领域自注意力复杂度与图像尺寸的平方成正比，计算量非常大，之前有人采用了只在局部进行自注意力的方法，也有采用稀疏自注意力的方法，也有在一个block内部采用自注意力的方法，虽然效果不错，但是这些方法的工程实现非常复杂，而且硬件加速很不友好。然后介绍了一篇与自己的工作非常相似的文章，但是那篇文章只是在尺寸较小的图像上进行了实验，不适用大尺寸图像，而且作者对预训练进行了更加深入的论证。</p><h3 id="方法">方法</h3><p>作者说他们的方法基本上没有对原始的transformer进行改动，可以拿过来开箱即用。</p><p><img src="https://s2.loli.net/2022/01/30/Rz271Qcp4aEMfBT.png" alt="image.png"></p><p>这张图画的非常好，可以从这张图清晰的看出作者的整个设计思路。先将图像分成一个个patch，这样每个patch的通道数量就是PxPx3，这里的P是每个patch的边长，然后把这个patch经过一个linear embedding层也就是一个全连接层，这样通道数量就变成了D。经过上述操作之后，每个输入就变成了一个1D的token，和NLP中的输入类似。</p><p>参照BERT的做法，额外增加了一个可学习的类别token，用来作最终的分类，因为transformer的自注意力是全局的，所以这个类别token具有全局信息，这样是合理的，消融实验证明采用全局平均池化的方式代替这个额外的类别token效果也是差不多的，但是还是那一点，为了保持一致。</p><p>因为transformer不想卷积一样具有位置信息，所以在输入上额外增加了一个位置编码，这里作者采用的是一个1D的位置编码，消融实验证明用2D位置编码效果并没有什么提升。</p><p>transformer编码器采用的是多头自注意力+MLP，而且每个块之前都用了LayerNorm，同时采用了残差连接的方式，MLP采用的是GELU激活函数。</p><p>在这里，作者又详细说明了他们所设计的网络结构并没有太多图像相关的归纳偏置，只有MLP是局部和平移等变的，像自注意力是全局的，而且每个patch被平铺开，并没有携带2D信息，所以这些patch的空间相关性需要从头学习。</p><p>基于上述问题，作者给出了一种变体实现方法，就是不把原始图像打成patch，而是用一个普通的CNN，最后得到的特征图和处理成patch是一样大小的，然后在经过一个linear embedding丢给transformer，后面其他操作是一样的，这样就携带了空间信息。</p><p>最后作者提到预训练时在更大的图像上效果会更好，保持patch尺寸不变，这样patch数量就会增加，之前的位置编码可能会没用，这里作者采用的是直接插值的方式，但是这其实是一种临时的解决策略，因为当尺寸变得很大时，这种直接插值的方式会掉点。这里的分辨率调整和抽图像块是ViT唯一使用到的2D信息的归纳偏置。</p><h3 id="实验">实验</h3><p>作者在三个数据上进行了预训练：分别是ImageNet-1K，ImageNet-221K和JFT，数量分别是130万，1400万和3亿，并且在许多流行的数据集上进行了评测。他们的模型一共有三种变体：Base，Large和Huge，主要是层数，D，MLP尺寸，多头自注意力的头数不同。然后从表现和训练成本进行了对比说明，表现效果略好，但是训练相较于其他的要快不少。</p><p><img src="https://s2.loli.net/2022/01/30/zl42HWZNvSYnj6b.png" alt="image.png"></p><p>这张图可以说是这篇文章的精髓了，当在较小的数据集上训练时，transformer的效果明显不如CNN，当在数据量适中的数据集上训练时，效果基本上就和CNN持平了，当在更大的数据集上训练时，效果就会优于CNN，而且没有收敛的迹象。</p><p>之后进行了可视化分析，linear embedding类似与CNN，提取到的都是类似于Gabor滤波器提取到的特征，比如颜色纹理等，位置编码用1D位置编码，却已经学到了2D的特征，这也就解释了为什么用1D就够了。</p><p><img src="https://s2.loli.net/2022/01/30/9etDSmUHnabWCuV.png" alt="image.png"></p><p>最后，作者着重说明了自监督训练，这也是transformer能这么火的原因，作者采用masked patch方法进行自监督，效果并没有达到预期。</p><h3 id="结论">结论</h3><p>作者对自己的工作作了总结，并指明了几个可以进一步研究的方向，比如下游任务如检测分割等，比如自监督预训练，又比如架构和目标函数等等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍ICLR2021论文《AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE》。&lt;/p&gt;</summary>
    
    
    
    <category term="PaperReading" scheme="https://zsh4614.cn/categories/PaperReading/"/>
    
    
    <category term="transformer" scheme="https://zsh4614.cn/tags/transformer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百四十四题：二叉树的前序遍历</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-01-29T15:11:23.000Z</published>
    <updated>2022-01-29T15:19:49.980Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百四十四题，对二叉树进行前序遍历，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你二叉树的根节点 root ，返回它节点值的前序遍历。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/29/3uCdQJNIDKjmpqR.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例4</strong></p><p><img src="https://s2.loli.net/2022/01/29/26xpMiUJCXz8jHa.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例5</strong></p><p><img src="https://s2.loli.net/2022/01/29/h4D5web1dx8ozZC.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 [0, 100] 内</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><h3 id="分析">分析</h3><p>本题可以用迭代和递归方法解决，和中序遍历类似。</p><h3 id="实现">实现</h3><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*&amp; root)&gt; func = [&amp;](TreeNode*&amp; root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">func</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">func</span>(root-&gt;right);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func</span>(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">**迭代**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="疑问">疑问</h3><p>为什么那个匿名函数的参数写成const不行？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百四十四题，对二叉树进行前序遍历，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉树遍历" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第九十四题：二叉树的中序遍历</title>
    <link href="https://zsh4614.cn/Leetcode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://zsh4614.cn/Leetcode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-01-29T13:48:59.000Z</published>
    <updated>2022-01-29T14:27:31.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第九十四题，对二叉树进行中序遍历，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给定一个二叉树的根节点 root ，返回它的中序遍历。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/29/Eevz7hcCw6OlT2L.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例4</strong></p><p><img src="https://s2.loli.net/2022/01/29/qLzo6GYlsIHgOwE.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例5</strong></p><p><img src="https://s2.loli.net/2022/01/29/TFpeRnoCJvZEOH2.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 [0, 100] 内</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><h3 id="分析">分析</h3><p>中序遍历先访问左儿子，最后访问右儿子，对于子树也是如此。递归方法很容易想到，代码也很简单；迭代的话就是自己维护一个stack，先将根结点入栈，然后将左儿子入栈，再将左儿子的左儿子入栈，如此，直到没有左儿子，然后将栈顶结点出栈，将其值加入结果，然后对其右儿子执行上述操作，直到栈为空且所有结点都遍历过。</p><h3 id="代码">代码</h3><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">inorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            root = stack.<span class="built_in">top</span>()</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><p>以上两种方法时间复杂度和空间复杂度都是O(n)，还有一种空间复杂度为O(1)的方法，Morris方法，之后再讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第九十四题，对二叉树进行中序遍历，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉树遍历" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>C++11之constexpr和const的区别</title>
    <link href="https://zsh4614.cn/C-11%E4%B9%8Bconstexpr%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://zsh4614.cn/C-11%E4%B9%8Bconstexpr%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-26T15:12:06.000Z</published>
    <updated>2022-01-26T15:22:42.493Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍C++11的新关键字constexpr和const的区别。</p><span id="more"></span><h3 id="背景">背景</h3><p>我们知道，constexpr 是 C++ 11 标准新添加的关键字，在此之前（C++ 98/03标准）只有 const 关键字，其在实际使用中经常会表现出两种不同的语义。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误，x是只读的变量</span></span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">dis_1</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">dis_2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，dis_1() 和 dis_2() 函数中都包含一个 const int x，但 dis_1() 函数中的 x 无法完成初始化 array 容器的任务，而 dis_2() 函数中的 x 却可以。</p><p>这是因为，dis_1() 函数中的“const int x”只是想强调 x 是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器；而 dis_2() 函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5 的常量，所以可以用来初始化 array 容器。</p><h3 id="区别">区别</h3><p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即<strong>凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</strong></p><p>有读者可能会问，“只读”不就意味着其不能被修改吗？答案是否定的，“只读”和“不允许被修改”之间并没有必然的联系，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; con_b = a;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>可以看到，程序中用 const 修饰了 con_b 变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p><p>在大部分实际场景中，const 和 constexpr 是可以混用的，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>它们是完全等价的，都可以在程序的编译阶段计算出结果。但在某些场景中，必须明确使用 constexpr，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">sqr1</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">sqr2</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr1(10)&gt; mylist1;<span class="comment">//可以，因为sqr1时constexpr函数</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr2(10)&gt; mylist1;<span class="comment">//不可以，因为sqr2不是constexpr函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，因为 sqr2() 函数的返回值仅有 const 修饰，而没有用更明确的 constexpr 修饰，导致其无法用于初始化 array 容器（只有常量才能初始化 array 容器）。</p><p>总的来说在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。</p><blockquote><p>转载自：<a href="http://c.biancheng.net/view/7807.html">http://c.biancheng.net/view/7807.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍C++11的新关键字constexpr和const的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="const" scheme="https://zsh4614.cn/tags/const/"/>
    
    <category term="constexpr" scheme="https://zsh4614.cn/tags/constexpr/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百四十六题：LRU缓存</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%E9%A2%98%EF%BC%9ALRU%E7%BC%93%E5%AD%98/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%E9%A2%98%EF%BC%9ALRU%E7%BC%93%E5%AD%98/</id>
    <published>2022-01-24T15:24:38.000Z</published>
    <updated>2022-01-24T15:47:05.583Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百四十六题，设计一个LRU缓存，并给出c++实现</p><span id="more"></span><h3 id="题目">题目</h3><p>请你设计并实现一个满足<code>LRU (最近最少使用) 缓存</code>约束的数据结构。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li><li>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</li></ul><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 10000</li><li>0 &lt;= value &lt;= 105</li><li>最多调用 2 * 105 次 get 和 put</li></ul><h3 id="分析">分析</h3><p>LRU缓存用哈希表+双向链表实现，双向链表一般都会用到虚拟的头结点和尾结点，用来防止处理边界，在c++中，unordered_map是用哈希表实现的，list是用双向链表实现的，所以如果不用自己实现底层的话，直接用这两个容器就行，双向链表的实现比较简单，而哈希映射的实现就复杂了，所以这里只给出双向链表自己实现的写法。</p><h3 id="实现">实现</h3><p><strong>双向链表+哈希</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoubleLinkedListNode</span>() : <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DoubleLinkedListNode</span>(<span class="keyword">int</span> key_, <span class="keyword">int</span> val_) : <span class="built_in">key</span>(key_), <span class="built_in">val</span>(val_), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DoubleLinkedListNode</span>(<span class="keyword">int</span> key_, <span class="keyword">int</span> val_, DoubleLinkedListNode* pre_, DoubleLinkedListNode* next_) : <span class="built_in">key</span>(key_), <span class="built_in">val</span>(val_), <span class="built_in">pre</span>(pre_), <span class="built_in">next</span>(next_) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    DoubleLinkedListNode* pre;</span><br><span class="line">    DoubleLinkedListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">m_capacity</span>(capacity), <span class="built_in">m_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DoubleLinkedListNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DoubleLinkedListNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashmap.<span class="built_in">find</span>(key) == hashmap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将查找到的结点放到第一个位置</span></span><br><span class="line">            hashmap[key]-&gt;pre-&gt;next = hashmap[key]-&gt;next;</span><br><span class="line">            hashmap[key]-&gt;next-&gt;pre = hashmap[key]-&gt;pre;</span><br><span class="line">            hashmap[key]-&gt;pre = head;</span><br><span class="line">            hashmap[key]-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;pre = hashmap[key];</span><br><span class="line">            head-&gt;next = hashmap[key];</span><br><span class="line">            <span class="keyword">return</span> hashmap[key]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashmap.<span class="built_in">find</span>(key) == hashmap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 不存在，则添加到双链表的第一个位置</span></span><br><span class="line">            hashmap[key] = <span class="keyword">new</span> <span class="built_in">DoubleLinkedListNode</span>(key, value);</span><br><span class="line">            hashmap[key]-&gt;pre = head;</span><br><span class="line">            hashmap[key]-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;pre = hashmap[key];</span><br><span class="line">            head-&gt;next = hashmap[key];</span><br><span class="line">            <span class="comment">// 如果超过长度，则删除最后一个节点，同时删除哈希表中的值</span></span><br><span class="line">            <span class="keyword">if</span> ((++m_size) &gt; m_capacity) &#123;</span><br><span class="line">                DoubleLinkedListNode* last = tail-&gt;pre;</span><br><span class="line">                tail-&gt;pre-&gt;pre-&gt;next = tail;</span><br><span class="line">                tail-&gt;pre = tail-&gt;pre-&gt;pre;</span><br><span class="line">                m_size--;</span><br><span class="line">                hashmap.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在, 更新值，并移动到第一个位置</span></span><br><span class="line">            hashmap[key]-&gt;val = value;</span><br><span class="line">            hashmap[key]-&gt;pre-&gt;next = hashmap[key]-&gt;next;</span><br><span class="line">            hashmap[key]-&gt;next-&gt;pre = hashmap[key]-&gt;pre;</span><br><span class="line">            hashmap[key]-&gt;pre = head;</span><br><span class="line">            hashmap[key]-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;pre = hashmap[key];</span><br><span class="line">            head-&gt;next = hashmap[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, DoubleLinkedListNode*&gt; hashmap;</span><br><span class="line">    DoubleLinkedListNode* head;</span><br><span class="line">    DoubleLinkedListNode* tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：删除某个结点的时候，一定要同步删除哈希表中对应的元素，而这个元素，也就是键，必须通过双向链表中要删除的结点获取，所以双向链表中不能只存储值。</p><p><strong>list+unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">cap</span>(capacity) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(key) == map.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> key_value = *map[key];</span><br><span class="line">        cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        cache.<span class="built_in">push_front</span>(key_value);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> key_value.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(key) == map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">size</span>() == cap) &#123;</span><br><span class="line">                map.<span class="built_in">erase</span>(cache.<span class="built_in">back</span>().first);</span><br><span class="line">                cache.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：list容器有一个特别的地方就是它的size()接口的时间复杂度并不是像其他容器一样复杂度为1，而是O(n)，n是list的长度，这样设计有其他的考量，具体可以参考<a href="https://blog.csdn.net/zhwenx3/article/details/89163574">这里</a>。</p><h3 id="拓展">拓展</h3><p>缓存是一种广义的概念，在计算机存储层次结构中，低一层的存储器都可以看做是高一层的缓存。比如Cache是内存的缓存，内存是硬盘的缓存，硬盘是网络的缓存等等。</p><p>缓存可以有效地解决存储器性能与容量的这对矛盾，但绝非看上去那么简单。如果缓存算法设计不当，非但不能提高访问速度，反而会使系统变得更慢。</p><p>从本质上来说，缓存之所以有效是因为程序和数据的局部性（locality）。程序会按固定的顺序执行，数据会存放在连续的内存空间并反复读写。这些特点使得我们可以缓存那些经常用到的数据，从而提高读写速度。</p><p>缓存的大小是固定的，它应该只保存最常被访问的那些数据。然而未来不可预知，我们只能从过去的访问序列做预测，于是就有了各种各样的缓存替换策略。</p><p>我们以内存访问为例解释缓存的工作原理。假设缓存的大小固定，初始状态为空。每发生一次读内存操作，首先查找待读取的数据是否存在于缓存中，若是，则缓存命中，返回数据；若否，则缓存未命中，从内存中读取数据，并把该数据添加到缓存中。向缓存添加数据时，如果缓存已满，则需要删除访问时间最早的那条数据，这种更新缓存的方法就叫做LRU。</p><p>实现LRU时，我们需要关注它的读性能和写性能，理想的LRU应该可以在O(1)的时间内读取一条数据或更新一条数据，也就是说读写的时间复杂度都是O(1)。</p><p>此时很容易想到使用HashMap，根据数据的键访问数据可以达到O(1)的速度。但是更新缓存的速度却无法达到O(1)，因为需要确定哪一条数据的访问时间最早，这需要遍历所有缓存才能找到。</p><p>因此，我们需要一种既按访问时间排序，又能在常数时间内随机访问的数据结构。</p><p>这可以通过HashMap+双向链表实现。HashMap保证通过key访问数据的时间为O(1)，双向链表则按照访问时间的顺序依次穿过每个数据。之所以选择双向链表而不是单链表，是为了可以从中间任意结点修改链表结构，而不必从头结点开始遍历。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百四十六题，设计一个LRU缓存，并给出c++实现&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双向链表" scheme="https://zsh4614.cn/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
    <category term="list" scheme="https://zsh4614.cn/tags/list/"/>
    
    <category term="缓存" scheme="https://zsh4614.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第十九题：删除链表的倒数第 N 个结点</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E5%8D%81%E4%B9%9D%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E5%8D%81%E4%B9%9D%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2022-01-22T16:42:00.000Z</published>
    <updated>2022-01-23T17:17:40.696Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第十九题，删除链表的倒数第N个结点，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/24/Nyuo2cVLTt3iQ8z.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 sz</li><li>1 &lt;= sz &lt;= 30</li><li>0 &lt;= Node.val &lt;= 100</li><li>1 &lt;= n &lt;= sz</li></ul><h3 id="分析">分析</h3><p>因为只有遍历才能求链表的长度，所以最常想到的方法就是遍历链表求长度l，删除倒数第n个结点，也就知道了删除正数第几个结点，这种方法效率较低，这里就不实现了；第二种方法就是用双指针，让第一个指针始终领先第二个指针n个结点，这样当第一个结点在链表尾结点上时，第二个结点正好在倒数第n个结点的前一个结点；第三种方法是使用stack实现。</p><h3 id="实现">实现</h3><p><strong>双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">      ListNode* first = head;</span><br><span class="line">      ListNode* second = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    ListNode* ans = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：用到node-&gt;next  一定要保证node不为空结点，避免为空的一个好方法是使用哨兵结点。</p><p><strong>stack</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* work = head;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(dummy);</span><br><span class="line">    <span class="keyword">while</span> (work) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(work);</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="built_in">top</span>()-&gt;next = stack.<span class="built_in">top</span>()-&gt;next-&gt;next;</span><br><span class="line">    ListNode* res = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第十九题，删除链表的倒数第N个结点，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="stack" scheme="https://zsh4614.cn/tags/stack/"/>
    
    <category term="双指针" scheme="https://zsh4614.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第二百三十四题：回文链表</title>
    <link href="https://zsh4614.cn/Leetcode%E7%AC%AC%E4%BA%8C%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/Leetcode%E7%AC%AC%E4%BA%8C%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-21T15:53:46.000Z</published>
    <updated>2022-01-21T16:13:24.418Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第二百三十四题，判断一个链表是否是回文链表，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/21/ZG1w5Au2j8v9KsT.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/21/DcblhSoI8WV9QMg.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>链表中节点数目在范围[1, 10^5] 内</li><li>0 &lt;= Node.val &lt;= 9</li></ul><h3 id="分析">分析</h3><p>常规思路是用一个容器把结点全部按顺序存起来，然后遍历链表一一比对，但是消耗空间比较大，另一种容易想到的思路是反转链表，然后遍历判断每个结点是否相等，但是反转之后原链表就丢失了，所以不能这么做；正确思路应该是反转链表的后半部分，和前半部分的结点一一比对，如何找到中间的结点呢？用快慢指针！</p><h3 id="实现">实现</h3><p><strong>容器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">uint8_t</span>&gt; vec;</span><br><span class="line">    ListNode* work = head;</span><br><span class="line">    <span class="keyword">while</span>(work) &#123;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(work-&gt;val);</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> itr = vec.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (itr != vec.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        itr--;</span><br><span class="line">        <span class="keyword">if</span> ((*itr) != head-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p><strong>双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!(head-&gt;next)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> reverse = [](ListNode* head)&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* rev = <span class="built_in">reverse</span>(slow);</span><br><span class="line">            <span class="keyword">while</span> (rev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rev-&gt;val != head-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rev = rev-&gt;next;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* rev = <span class="built_in">reverse</span>(slow-&gt;next);</span><br><span class="line">            <span class="keyword">while</span> (rev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rev-&gt;val != head-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rev = rev-&gt;next;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第二百三十四题，判断一个链表是否是回文链表，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://zsh4614.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++中的栈对象和堆对象</title>
    <link href="https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A0%86%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A0%86%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-01-21T07:18:26.000Z</published>
    <updated>2022-01-21T16:10:33.766Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍两种建立类对象的方式，在栈上和堆上建立，以及对它们的理解。</p><span id="more"></span><h3 id="背景">背景</h3><p>在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。</p><ul><li><p><strong>静态建立类对象：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。</strong></p></li><li><p><strong>动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。</strong></p></li></ul><h3 id="区别">区别</h3><p>初始化两种方法：</p><p>第一种初始化方法：ClassName object(初始化参数)；</p><p>第二种初始化方法：ClassName* object=new ClassName(初始化参数);</p><p>两种初始化方法的区别：</p><p>第一种初始化方法：在stack栈里面分配空间，自动释放。</p><p>第二种初始化方法：在heap堆里面分配空间，要手动释放。</p><h3 id="选择">选择</h3><p>栈对象的优势是在适当的时候自动生成，又在适当的时候<strong>自动销毁</strong>，不需要程序员操心；而且<strong>栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用 operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了</strong>。但是要注意的是，通常<strong>栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配</strong>。特别要注意<strong>递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误</strong>。</p><p>堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，<strong>相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。</strong></p><h3 id="限制">限制</h3><p>如何限制类对象只能在堆或者栈上建立呢？下面分别进行讨论。</p><p><strong>1、只能在堆上分配类对象，就是不能静态建立类对象，即不能直接调用类的构造函数。</strong></p><p>容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operatornew()函数只用于分配内存，无法提供构造功能。因此，<strong>这种方法不可以。</strong></p><p>当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，<strong>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了</strong>。代码如下：（这种方法不好）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>试着使用<code>A a</code>;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。<strong>类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。</strong></p><p>上述方法的缺点：</p><ul><li><p><strong>无法解决继承问题</strong>。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。<strong>将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。</strong></p></li><li><p><strong>类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。</strong>（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。</p></li></ul><p>为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于<strong>单例模式</strong>：（这种方法比较可取）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> A* <span class="title">create</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>这样，调用create()函数在堆上创建类A对象，调用destory()函数释放内存。</p><p><strong>2、只能在栈上分配类对象</strong></p><p>只有使用new运算符，对象才会建立在堆上，因此，**只要禁用new运算符就可以实现类对象只能建立在栈上。**虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，<strong>将operator new()设为私有即可禁止对象被new在堆上</strong>。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><blockquote><p>转载自：<a href="http://blog.csdn.net/sdnu111111111/article/details/38707923">http://blog.csdn.net/sdnu111111111/article/details/38707923</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍两种建立类对象的方式，在栈上和堆上建立，以及对它们的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="堆" scheme="https://zsh4614.cn/tags/%E5%A0%86/"/>
    
    <category term="栈" scheme="https://zsh4614.cn/tags/%E6%A0%88/"/>
    
    <category term="new" scheme="https://zsh4614.cn/tags/new/"/>
    
    <category term="delete" scheme="https://zsh4614.cn/tags/delete/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第二百零六题：反转链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E7%99%BE%E9%9B%B6%E5%85%AD%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E7%99%BE%E9%9B%B6%E5%85%AD%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-20T14:32:30.000Z</published>
    <updated>2022-01-21T16:12:22.478Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第二百零六题，将一个链表进行反转。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/20/h8WBedLgsJ6qRYw.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/20/8IV4ybzfQXGHJxi.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>链表中节点的数目范围是 [0, 5000]</li><li>-5000 &lt;= Node.val &lt;= 5000</li></ul><h3 id="分析">分析</h3><p><strong>要深刻理解链表的结构，每个结点在存储上并不连续，他们之间的关系就是指针的指向，所以反转一个链表就是将每个结点的指针域由指向后一个结点变成指向前一个结点即可</strong>；另一种思路是递归，这种思路比较好想到，但是实现起来需要一定的功底；工程中应尽量避免递归，基本上所有的递归都能改成用stack和dfs实现，这个也不例外，而且stack是先进后出，很适合这种反转操作。</p><h3 id="实现">实现</h3><p><strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head; </span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* end = head-&gt;next;</span><br><span class="line">    ListNode* new_head = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    end-&gt;next = head;</span><br><span class="line">    end-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p>注意：在递归的写法中，前面两个判断条件可以写成同一个，都返回head；另外<code>head == nullptr</code>可以写成<code>!head</code>；需要注意递归方法的时间复杂度。</p><p><strong>stack</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* res = stack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ListNode* top = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            top-&gt;next = stack.<span class="built_in">top</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            top-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第二百零六题，将一个链表进行反转。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://zsh4614.cn/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="stack" scheme="https://zsh4614.cn/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百六十题：相交链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%85%AD%E5%8D%81%E9%A2%98%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%85%AD%E5%8D%81%E9%A2%98%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-17T15:01:11.000Z</published>
    <updated>2022-01-17T16:12:48.798Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百六十题，判断两个链表是否相交，并找出相交的结点。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://s2.loli.net/2022/01/17/xf6UjXkD2TeWI3F.png" alt="image.png"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h3 id="示例">示例</h3><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/17/deKrCEjBOtQgmWI.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/17/pec9sSCqiohBu5r.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><img src="https://s2.loli.net/2022/01/17/hEXnDypY7I56LfO.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>listA 中节点数目为 m</li><li>listB 中节点数目为 n</li><li>1 &lt;= m, n &lt;= 3 * 104</li><li>1 &lt;= Node.val &lt;= 105</li><li>0 &lt;= skipA &lt;= m</li><li>0 &lt;= skipB &lt;= n</li><li>如果 listA 和 listB 没有交点，intersectVal 为 0</li><li>如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</li></ul><h3 id="分析">分析</h3><p>如果只是判断两个链表是否相交，那么就很简单了，只需要判断最后一个结点是否是同一个结点。但是本题要返回相交的那个结点，一个最直接的思路是使用哈希表，先将一个链表的每个结点地址存储起来，然后在遍历第二个链表的时候去查表，这样时间复杂度是O(m+n)，空间复杂度为O(m)。另一种常用的思路是用双指针，同时遍历两个链表，当遍历到尾结点的时候，指向另一个链表的头结点，这样如果有相交的话，那么一定会指到同一个结点上；如果不相交的话，那么最后他们一定同时指向nullptr。</p><h3 id="实现">实现</h3><p><strong>方法一：哈希</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; hashset;</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        hashset.<span class="built_in">emplace</span>(headA);</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.<span class="built_in">find</span>(headB) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">    ListNode* workA &#x3D; headA;</span><br><span class="line">    ListNode* workB &#x3D; headB;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        </span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            return workB;</span><br><span class="line">        &#125;</span><br><span class="line">        workA &#x3D; workA-&gt;next;</span><br><span class="line">        workB &#x3D; workB-&gt;next;</span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workA &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workA &#x3D; headB;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workB &#x3D; headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的思路，看一下大神写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA &#x3D;&#x3D; nullptr || headB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA &#x3D; headA, *pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NB!!!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百六十题，判断两个链表是否相交，并找出相交的结点。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://zsh4614.cn/categories/Leetcode/"/>
    
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百四十二题：环形链表二</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/</id>
    <published>2022-01-16T08:40:10.000Z</published>
    <updated>2022-01-16T10:01:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一百四十二题，判断一个链表是否有环，有环的话找到入环的结点，用佛洛依德判圈算法实现。</p><span id="more"></span><h3 id="题目：">题目：</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改链表。</p><h3 id="示例">示例</h3><p><strong>示例一</strong></p><p><img src="https://s2.loli.net/2022/01/16/p4XMYle9k8yqxwm.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例二</strong></p><p><img src="https://s2.loli.net/2022/01/16/v8whclNoCksYBQT.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例三</strong></p><p><img src="https://s2.loli.net/2022/01/16/2PmvFTZqnyrhkap.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 [0, 10^4] 内</li><li>-10^5 &lt;= Node.val &lt;= 10^5</li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><h3 id="分析">分析</h3><p>本题可使用佛洛依德判圈算法求解。</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* slow = dummy1;</span><br><span class="line">    ListNode* dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* fast = dummy2;</span><br><span class="line">    slow-&gt;next = head;</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow-&gt;next) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里虚拟了一个dummy结点，这样可以将头结点当作一般结点看待，否则可能需要判断头结点为空的情况，这样做就不用单独判断了。另外<strong>新开辟的无用内存，在返回前一定要释放，否则会内存泄漏</strong>，这里的slow和fast相当于工作结点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一百四十二题，判断一个链表是否有环，有环的话找到入环的结点，用佛洛依德判圈算法实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：Floyd判圈算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-15T09:21:19.000Z</published>
    <updated>2022-01-16T08:28:07.984Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍一种常用的判圈算法，并给出其推导。</p><span id="more"></span><h3 id="简述">简述</h3><p>Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。</p><h3 id="问题">问题</h3><p>如何检测一个链表是否有环，如果有，那么如何确定环的起点和环的长度。</p><p>1）判断是否有环？<br>龟兔解法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p><p>基于上面的想法，Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果时等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。</p><p>2）求环的长度<br>假设相遇点为B点,让其中一个指针停在B不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p><p>3）如何确定环的起点<br>假设相遇点为B点。方法是将其中一个指针移到链表起点，另一个指针为B点,两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。</p><h3 id="证明">证明</h3><p>首先假设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m，环的长度为n，相遇的位置与起点与起点位置距离为k。于是有：</p><p>i = m + a * n + k</p><p>其中a为慢指针走的圈数。</p><p>因为快指针的速度是慢指针的2倍，于是又可以得到另一个式子：</p><p>2 * i = m + b * n + k</p><p>其中b为快指针走的圈数。</p><p>两式相减得：</p><p>i = ( b - a ) * n</p><p>也就是说i是圈长的整数倍。</p><p>这是将其中一个节点放在起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点i+m，i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍一种常用的判圈算法，并给出其推导。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++之STL无序关联式容器unordered_map</title>
    <link href="https://zsh4614.cn/C-%E4%B9%8BSTL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8unordered-map/"/>
    <id>https://zsh4614.cn/C-%E4%B9%8BSTL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8unordered-map/</id>
    <published>2022-01-15T08:55:38.000Z</published>
    <updated>2022-01-15T09:19:39.450Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。</p><span id="more"></span><h3 id="引言">引言</h3><p>关联式容器，常被称为“无序容器”、“哈希容器”或者“无序关联容器”。注意，无序容器是 C++ 11 标准才正式引入到 STL 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><p>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p><ul><li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li><li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li></ul><p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p><p><img src="https://s2.loli.net/2022/01/15/NcwjdSUL5kMvG1o.png" alt="image.png"></p><h3 id="创建">创建</h3><p>unordered_map 容器模板的定义如下所示：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="STL" scheme="https://zsh4614.cn/tags/STL/"/>
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="unordered_map" scheme="https://zsh4614.cn/tags/unordered-map/"/>
    
  </entry>
  
  <entry>
    <title>C++之STL关联式容器map</title>
    <link href="https://zsh4614.cn/C-%E4%B9%8BSTL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8map/"/>
    <id>https://zsh4614.cn/C-%E4%B9%8BSTL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8map/</id>
    <published>2022-01-11T15:09:31.000Z</published>
    <updated>2022-01-15T08:33:07.464Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。</p><span id="more"></span><h3 id="pair">pair</h3><p>关联式容器存储的是“键值对”形式的数据，考虑到“键值对”并不是普通类型数据，C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素&lt;first, second&gt;。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</p><p>注意，pair 类模板定义在<utility>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span>) 默认构造函数，即创建空的 pair 对象</span><br><span class="line"><span class="built_in">pair</span>();</span><br><span class="line">#<span class="number">2</span>) 直接使用 <span class="number">2</span> 个元素初始化成 pair 对象</span><br><span class="line"><span class="built_in">pair</span> (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line">#<span class="number">3</span>) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span><br><span class="line">template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</span><br></pre></td></tr></table></figure><p>在 C++ 11 标准中，在引入右值引用的基础上，pair 类模板中又增添了如下 2 个构造函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">4</span>) 移动构造函数</span><br><span class="line">template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</span><br><span class="line">#<span class="number">5</span>) 使用右值引用参数，创建 pair 对象</span><br><span class="line">template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</span><br></pre></td></tr></table></figure><p>下面程序演示了以上几种创建 pair 对象的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;string, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair2</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair3</span>(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair4</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair5</span>(<span class="built_in">string</span>(<span class="string">&quot;Python教程&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序在创建 pair4 对象时，调用了 make_pair() 函数，它也是 <utility> 头文件提供的，其功能是生成一个 pair 对象。因此，当我们将 make_pair() 函数的返回值（<strong>是一个临时对象</strong>）作为参数传递给 pair() 构造函数时，<strong>其调用的是移动构造函数，而不是拷贝构造函数。</strong></p><p>在上面程序的基础上，C++ 11 还允许我们手动为 pair1 对象赋值，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair1.first &#x3D; &quot;Java教程&quot;;</span><br><span class="line">pair1.second &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;;</span><br><span class="line">cout &lt;&lt; &quot;new pair1: &quot; &lt;&lt; pair1.first &lt;&lt; &quot; &quot; &lt;&lt; pair1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>同时，上面程序中 pair4 对象的创建过程，还可以写入如下形式，它们是完全等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;string, string&gt; pair4 &#x3D; make_pair(&quot;C++教程&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;);</span><br><span class="line">cout &lt;&lt; &quot;pair4: &quot; &lt;&lt; pair4.first &lt;&lt; &quot; &quot; &lt;&lt; pair4.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><utility>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;=、&gt;、&gt;=、==、!= 这 6 的运算符，其运算规则是：<strong>对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。</strong></p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair1</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair2</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair3</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pair != pair2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pair2 != pair3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair !&#x3D; pair2</span><br><span class="line">pair2 !&#x3D; pair3</span><br></pre></td></tr></table></figure><p>最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，<strong>其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair1</span>(<span class="string">&quot;pair&quot;</span>, <span class="number">10</span>);                   </span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair2</span>(<span class="string">&quot;pair2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.<span class="built_in">swap</span>(pair2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建map容器">创建map容器</h3><p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、使用结构体或类自定义的类型。</p><p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用std::less<T>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如std::greater<T>），也可以自定义排序规则。</p><p>另外需要注意的是，使用 map 容器存储的各个键值对，**键的值既不能重复也不能被修改。<strong>换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着</strong>只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。**前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 <strong>pair&lt;const K, T&gt;</strong> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p><p>map 容器的模板定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">T</span>,                                       // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,                     <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;pair&lt;<span class="keyword">const</span> Key,T&gt; &gt;    <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p><p>map 容器的模板类中包含多种构造函数，因此创建 map 容器的方式也有多种，下面就几种常用的创建 map 容器的方法，做一一讲解。</p><ol><li>通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap;</span><br></pre></td></tr></table></figure><p>通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此<strong>创建空 map 容器是比较常用的。</strong></p><ol start="2"><li>当然在创建 map 容器的同时，也可以进行初始化，比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>由此，myMap 容器在初始状态下，就包含有 2 个键值对。</p><p>再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>),std::<span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>)&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>除此之外，在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(myMap);</span><br></pre></td></tr></table></figure><p>由此，通过调用 map 容器的<strong>拷贝（复制）构造函数</strong>，即可成功创建一个和 myMap 完全一样的 newMap 容器。</p><p>C++ 11 标准中，还为 map 容器增添了移动构造函数。<strong>当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数</strong>。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建一个会返回临时 map 对象的函数</span><br><span class="line">std::map&lt;std::string,int&gt; disMap() &#123;</span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt;tempMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(<span class="built_in">disMap</span>());</span><br></pre></td></tr></table></figure><p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p><ol start="4"><li><strong>map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。例如：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(++myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>这里，通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {“STL教程”,20} 键值对的容器。</p><ol start="5"><li>当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。<strong>默认情况下，map 容器调用 std::less<T> 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。</strong></li></ol><p>因此，如下 2 行创建 map 容器的方式，其实是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>, std::less&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>, std::greater&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="成员方法">成员方法</h3><p>下表列出了 map 容器提供的常用成员方法以及各自的功能。<br><img src="https://s2.loli.net/2022/01/11/TzhsVNtg2ewymAX.png" alt="image.png"></p><p>C++ STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较。</p><p>下面程序以 begin()/end() 组合为例，演示了如何遍历 map 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;      &#x2F;&#x2F; pair</span><br><span class="line">#include &lt;string&gt;       &#x2F;&#x2F; string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建并初始化 map 容器</span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;&#125;,&#123;&quot;C语言教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;&#125; &#125;;</span><br><span class="line">    &#x2F;&#x2F;调用 begin()&#x2F;end() 组合，遍历 map 容器</span><br><span class="line">    for (auto iter &#x3D; myMap.begin(); iter !&#x3D; myMap.end(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向<strong>迭代器</strong>；反之，其功能和 end() 方法相同。<strong>因为返回的是迭代器，因此最常用的是判断容器中有没有这个键值对：if (iter != map.end()){}</strong></p><p>同时，map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p><ul><li>lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；</li><li>upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；</li></ul><p>下面程序演示了它们的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//找到第一个键的值不小于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</p><p>equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p><p>显然，equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>  <span class="comment">//pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;std::map&lt;string, string&gt;::iterator, std::map&lt;string, string&gt;::iterator&gt; myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    <span class="comment">//通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，<strong>其返回的范围内最多也只有 1 个键值对。</strong></p><h3 id="获取键对应值">获取键对应值</h3><p>我们知道，map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p><p>注意，<strong>使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</strong></p><p>庆幸的是，map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。</p><ol><li>map 类模板中对[ ]运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。</li></ol><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    string cValue = myMap[<span class="string">&quot;C语言教程&quot;</span>];</span><br><span class="line">    cout &lt;&lt; cValue &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在第 11 行代码中，通过指定键的值为 “C语言教程”，借助重载的 [ ] 运算符，就可以在 myMap 容器中直接找到该键对应的值。</p><p><strong>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。</strong></p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap;</span><br><span class="line">    <span class="keyword">int</span> cValue = myMap[<span class="string">&quot;C语言教程&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，对于空的 myMap 容器来说，其内部没有以 “C语言教程” 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个&lt;“C语言教程”,0&gt;键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）</p><p>实际上，[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap;</span><br><span class="line">    myMap[<span class="string">&quot;STL教程&quot;</span>]=<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Python教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;STL教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，程序中第 9 行代码已经为 map 容器添加了一个以 “STL教程” 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。</strong></p><ol start="2"><li>除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不<strong>同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。</strong></li></ol><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;      &#x2F;&#x2F; map</span><br><span class="line">#include &lt;string&gt;   &#x2F;&#x2F; string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建并初始化 map 容器</span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;&#125;,</span><br><span class="line">                                             &#123;&quot;C语言教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;&#125;,</span><br><span class="line">                                             &#123;&quot;Java教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;&#125; &#125;;</span><br><span class="line">    cout &lt;&lt; myMap.at(&quot;C语言教程&quot;) &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;下面一行代码会引发 out_of_range 异常</span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; myMap.at(&quot;Python教程&quot;) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序第 12 行代码处，通过 myMap 容器调用  at() 成员方法，可以成功找到键为 “C语言教程” 的键值对，并返回该键对应的值；而第 14 行代码，由于当前 myMap 容器中没有以 “Python教程” 为键的键值对，会导致 at() 成员方法查找失败，并抛出 out_of_range 异常。</p><p>除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    map&lt; std::string, std::string &gt;::iterator myIter = myMap.<span class="built_in">find</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; myIter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; myIter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，此程序中如果 find() 查找失败，会导致第 13 行代码运行出错。因为当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。</p><p>如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。</p><p>本节所介绍的几种方法中，仅从“在 map 容器存储的键值对中，获取指定键对应的值”的角度出发，<strong>更推荐使用 at() 成员方法，因为该方法既简单又安全。</strong></p><h3 id="insert-方法">insert()方法</h3><p>map 类模板中提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p><p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，<strong>如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</strong></p><p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p><ol><li>无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、引用传递一个键值对</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">//2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line">    pair&lt;iterator,bool&gt; insert (P&amp;&amp; val);</span><br></pre></td></tr></table></figure><p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li><li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li></ul><p>以上 2 种语法格式的区别在于传递参数的方式不同，即无论是局部定义的键值对变量还是全局定义的键值对变量，都采用普通引用传递的方式；而对于临时的键值对变量，则以右值引用的方式传参。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    std::pair&lt;std::map&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(STL);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret.iter &#x3D; &lt;&#123;STL教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&#125;, 1&gt;</span><br><span class="line">ret.iter &#x3D; &lt;&#123;C语言教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&#125;, 1&gt;</span><br><span class="line">ret.iter &#x3D; &lt;&#123;STL教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&#125;, 0&gt;</span><br></pre></td></tr></table></figure><p>从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：</p><ul><li>对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量</li><li>对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 “STL教程” 的键值对和值为 0 的 bool 变量。</li></ul><p>另外，在程序中的第 21 行代码，<strong>还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 pair 类模板的构造函数</span></span><br><span class="line">ret = mymap.<span class="built_in">insert</span>(pair&lt;string,string&gt;&#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;);</span><br><span class="line"><span class="comment">//调用 make_pair() 函数</span></span><br><span class="line">ret = mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li>除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p><ul><li>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</li><li>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.<span class="built_in">insert</span>(it, STL);</span><br><span class="line">    cout &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.<span class="built_in">insert</span>(it, std::pair&lt;string, string&gt;(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.<span class="built_in">insert</span>(it, std::pair&lt;string, string&gt;(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</strong></p><ol start="3"><li>insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是迭代器，它们的组合&lt;first,last&gt;可以表示某 map 容器中的指定区域。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    std::map&lt;string, string&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.<span class="built_in">insert</span>(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，vali 都表示的是键值对变量。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加 3 个键值对</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                   &#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;,</span><br><span class="line">                   &#123; <span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，除了 insert() 方法，<strong>map 类模板还提供 emplace() 和 emplace_hint() 方法，它们也可以完成向 map 容器中插入键值对的操作，且效率还会比insert() 方法高</strong>。关于这 2 个方法，会在下一节做详细介绍。</p><h3 id="operator-和insert-效率对比">operator[]和insert()效率对比</h3><p>map 容器模板类中提供有 operator[ ] 和 insert() 这 2 个成员方法，而值得一提的是，这 2 个方法具有相同的功能，它们既可以实现向 map 容器中添加新的键值对元素，也可以实现更新（修改）map 容器已存储键值对的值。</p><p>显然，map 模板类中 operator[ ] 和 insert() 的功能发生了重叠，这就产生了一个问题，谁的执行效率更高呢？</p><p><strong>结论：当实现“向 map 容器中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。</strong></p><p>首先解释一下，为什么实现向 map 容器中添加新键值对元素，insert() 方法的执行效率比 operator[ ] 更高？回顾程序一中，如下语句完成了向空 mymap 容器添加新的键值对元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap[<span class="string">&quot;STL教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br></pre></td></tr></table></figure><p>此行代码中，mymap[“STL教程”] 实际上是 mymap.operator<a href="%E2%80%9CSTL%E6%95%99%E7%A8%8B%E2%80%9D"> </a> 的缩写（底层调用的 operator[ ] 方法），该方法会返回一个指向 “STL教程” 对应的 value 值的引用。</p><p>但需要注意的是，由于此时 mymap 容器是空的，并没有 “STL教程” 对应的 value 值。这种情况下，operator[ ] 方法会默认构造一个 string 对象，并将其作为 “STL教程” 对应的 value 值，然后返回一个指向此 string 对象的引用。在此基础上，代码还会将 “<a href="http://c.biancheng.net.java/">http://c.biancheng.net.java/</a>” 赋值给这个 string 对象。</p><p>也就是说，上面这行代码的执行流程，可以等效为如下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;string, string&gt; mstr;</span><br><span class="line"><span class="comment">//创建要添加的默认键值对元素</span></span><br><span class="line">pair&lt;mstr::iterator, <span class="keyword">bool</span>&gt;res = mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="built_in">string</span>()));</span><br><span class="line"><span class="comment">//将新键值对的值赋值为指定的值</span></span><br><span class="line">res.first-&gt;second = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以看到，使用 operator[ ] 添加新键值对元素的流程是，先构造一个有默认值的键值对，然后再为其 value 赋值。</p><p>那么，为什么不直接构造一个要添加的键值对元素呢，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br></pre></td></tr></table></figure><p>此行代码和上面程序的执行效果完全相同，但它省略了创建临时 string 对象的过程以及析构该对象的过程，同时还省略了调用 string 类重载的赋值运算符。由于可见，同样是完成向 map 容器添加新键值对，insert() 方法比 operator[ ] 的执行效率更高</p><p>仍以程序一中的代码为例，如下分别是 operator[ ] 和 insert() 实现更新 mymap 容器中指定键对应的值的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;operator[]</span><br><span class="line">mymap[&quot;STL教程&quot;] &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;;</span><br><span class="line">&#x2F;&#x2F;insert()</span><br><span class="line">std::pair&lt;string, string&gt; STL &#x3D; &#123; &quot;Java教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot; &#125;;</span><br><span class="line">mymap.insert(STL).first-&gt;second &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;;</span><br></pre></td></tr></table></figure><p>仅仅从语法形式本身来考虑，或许已经促使很多读者选择 operator[ ] 了。接下来，我们再从执行效率的角度对比以上 2 种实现方式。</p><p>从上面代码可以看到，insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构）。</p><p>而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。</p><h3 id="emplace-和emplace-hint-方法">emplace()和emplace_hint()方法</h3><p>和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：<br>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；<br>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</p><p>下面程序演示 emplace() 方法的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//插入键值对</span></span><br><span class="line">    pair&lt;map&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入新键值对</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//失败插入的样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p><p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p><ul><li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li><li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li></ul><p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p><h3 id="插入效率">插入效率</h3><p>上一节在学习 C++STL map 容器的 emplace() 和 emplace_hint() 的基本用法时，还遗留了一个问题，即为什么 emplace() 和 emplace_hint() 的执行效率会比 insert() 高？</p><p>原因很简单，它们向 map 容器插入键值对时，底层的实现方式不同：</p><ul><li>使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；</li><li>使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。</li></ul><p>也就是说，向 map 容器中插入键值对时，emplace() 和 emplace_hint() 方法都省略了移动键值对的过程，因此执行效率更高。下面程序提供了有利的证明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, testDemo&gt;mymap;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="built_in">testDemo</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace</span>( <span class="string">&quot;http://c.biancheng.net/stl/:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_hint():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert():</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace():</span><br><span class="line">调用构造函数</span><br><span class="line">emplace_hint():</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure><p>分析一下这个程序。首先，我们创建了一个存储 &lt;string,tempDemo&gt; 类型键值对的空 map 容器，接下来分别用 insert()、emplace() 和 emplace_hint() 方法向该 map 容器中插入相同的键值对。</p><p>从输出结果可以看出，在使用 insert() 方法向 map 容器插入键值对时，整个插入过程调用了 1 次 tempDemo 类的构造函数，同时还调用了 2 次移动构造函数。实际上，程序第 28 行代码底层的执行过程，可以分解为以下 3 步：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造类对象</span></span><br><span class="line">testDemo val = <span class="built_in">testDemo</span>(<span class="number">1</span>); <span class="comment">//调用 1 次构造函数</span></span><br><span class="line"><span class="comment">//构造键值对</span></span><br><span class="line"><span class="keyword">auto</span> pai = <span class="built_in">make_pair</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, val); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"><span class="comment">//完成插入操作</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(pai); <span class="comment">//调用 1 次移动构造函数</span></span><br></pre></td></tr></table></figure><p>而完成同样的插入操作，emplace() 和 emplace_hint() 方法都只调用了 1 次构造函数，这足以证明，这 2 个方法是在 map 容器内部直接构造的键值对。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="STL" scheme="https://zsh4614.cn/tags/STL/"/>
    
    <category term="map" scheme="https://zsh4614.cn/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>C++之STL关联式容器set</title>
    <link href="https://zsh4614.cn/C-STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set/"/>
    <id>https://zsh4614.cn/C-STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set/</id>
    <published>2022-01-10T15:01:04.000Z</published>
    <updated>2022-01-10T16:40:50.027Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器set，包括其接口，用法和注意事项。</p><span id="more"></span><h3 id="综述">综述</h3><p>set本质上也是一种关联式容器，只是在存储键值对时，要求键值必须相等。举个例子，如下有 2 组键值对数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;&#39;a&#39;, 1&gt;, &lt;&#39;b&#39;, 2&gt;, &lt;&#39;c&#39;, 3&gt;&#125;</span><br><span class="line">&#123;&lt;&#39;a&#39;, &#39;a&#39;&gt;, &lt;&#39;b&#39;, &#39;b&#39;&gt;, &lt;&#39;c&#39;, &#39;c&#39;&gt;&#125;</span><br></pre></td></tr></table></figure><p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而<strong>无法存储第一组键值对</strong>。</p><p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,‘b’,‘c’} ，该容器即可成功将它们存储起来。</p><p>set容器会自行根据键的大小对存储的键值对进行排序。另外，使用 set 容器存储的<strong>各个元素的值必须各不相同</strong>。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。<strong>切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</strong></p><p>set 容器的类模板定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;T&gt;,        <span class="comment">// 指定 set 容器内部的排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;T&gt;      <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure><p>注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。</p><h3 id="创建">创建</h3><p>常见的创建 set 容器的方法，大致有以下 5 种。</p><ol><li>调用默认构造函数，创建空的 set 容器。比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure><p>由此就创建好了一个 set 容器，该容器采用默认的std::less<T>规则，会对存储的 string 类型元素做升序排序。注意，<strong>由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</strong></p><ol start="2"><li>除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123;<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure><p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p><p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> myset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure><p>注意，<strong>由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数</strong></p><ol start="4"><li>在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(++myset.begin(), myset.end())</span></span>;</span><br></pre></td></tr></table></figure><p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>以上几种方式创建的 set 容器，都采用了默认的std::less<T>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset&#123;</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>通过选用 std::greater<string> 降序规则，myset 容器中元素的存储顺序为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;</span><br></pre></td></tr></table></figure><h3 id="成员方法">成员方法</h3><p>下表列出了 set 容器提供的常用成员方法以及各自的功能。</p><p><img src="https://s2.loli.net/2022/01/10/ldfXza6AqFe25Np.png" alt="image.png"></p><h3 id="迭代器">迭代器</h3><p>和其他容器不同，set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，<strong>要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</strong></p><p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。</p><p>注意，set成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，set成员方法返回的迭代器，<strong>无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值</strong>。</p><p>下面程序以 begin()/end() 为例，演示了如何使用图 2 中相关迭代器遍历 set 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p><p><strong>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</strong></p><p>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</p><h3 id="insert-方法">insert()方法</h3><p>为满足不同场景的需要，C++ 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">//右值引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);</span><br></pre></td></tr></table></figure><p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式。</p><p><strong>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</strong></p><ul><li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li><li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;set&lt;string&gt;::iterator, <span class="keyword">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter-&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F; bool &#x3D; 1</span><br><span class="line">iter-&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F; bool &#x3D; 1</span><br></pre></td></tr></table></figure><p>通过观察输出结果不难看出，程序中两次借助 insert() 方法向 set 容器中添加元素，都成功了。</p><ol start="2"><li>insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</li><li>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">end</span>(),<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size &#x3D;1</span><br><span class="line">myset size &#x3D;2</span><br></pre></td></tr></table></figure><p>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，<strong>insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</strong></p><ol start="3"><li>insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。</li></ol><p>insert() 方法的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">  void insert (InputIterator first, InputIterator last);</span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//创建一个同类型的空 set 容器</span></span><br><span class="line">    std::set&lt;std::string&gt; otherset;</span><br><span class="line">    <span class="comment">//利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.<span class="built_in">insert</span>(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;</span><br></pre></td></tr></table></figure><p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p><ol start="4"><li>采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert ( &#123;E1, E2,...,En&#125; );</span><br></pre></td></tr></table></figure><p>其中，Ei 表示新添加的元素。</p><p>值的一提的是，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为<strong>implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高</strong>。</p><h3 id="emplace-和emplace-hint-方法">emplace()和emplace_hint()方法</h3><p>emplace() 和 emplace_hint() 是 C++ 11 标准加入到 set 类模板中的，相比具有同样功能的 insert() 方法，完成同样的任务，emplace() 和 emplace_hint() 的效率会更高。</p><p>emplace() 方法的语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>其中，参数 (Args&amp;&amp;… args) 指的是，只需要传入构建新元素所需的数据即可，该方法可以自行利用这些数据构建出要添加的元素。**比如，若 set 容器中存储的元素类型为自定义的结构体或者类，则在使用 emplace() 方法向容器中添加新元素时，构造新结构体变量（或者类对象）需要多少个数据，就需要为该方法传入相应个数的数据。<br>**</p><p>另外，该方法的返回值类型为 pair 类型，其包含 2 个元素，一个迭代器和一个 bool 值：</p><ul><li>当该方法将目标元素成功添加到 set 容器中时，其返回的迭代器指向新插入的元素，同时 bool 值为 true；</li><li>当添加失败时，则表明原 set 容器中已存在相同值的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时 bool 值为 false。</li></ul><p>下面程序演示 emplace() 方法的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;set&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret = myset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&quot;</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size &#x3D; 1</span><br><span class="line">ret.iter &#x3D; &lt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;, 1&gt;</span><br></pre></td></tr></table></figure><p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p><p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>和 emplace() 方法相比，有以下 2 点不同：</p><ul><li>该方法需要额外传入一个迭代器，用来指明新元素添加到 set 容器的具体位置（<strong>新元素会添加到该迭代器指向元素的前面</strong>）；</li><li>返回值是一个迭代器，而不再是 pair 对象。当成功添加元素时，返回的迭代器指向新添加的元素；反之，如果添加失败，则迭代器就指向 set 容器和要添加元素的值相同的元素。</li></ul><p>下面程序演示 emplace_hint() 方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//在 set 容器的指定位置添加键值对</span></span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">emplace_hint</span>(myset.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size &#x3D; 1</span><br><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;</span><br></pre></td></tr></table></figure><p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法中指定了添加新元素的位置，但 set 容器为了保持数据的有序状态，可能会移动其位置。</p><p>以上内容讲解了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的。</p><h3 id="erase-和clear-方法">erase()和clear()方法</h3><p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p><p>set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，<strong>表示成功删除的元素个数</strong>；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中<strong>删除元素之后的第一个元素</strong>。</p><p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p><p>如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>显然，该方法不需要传入任何参数，也没有任何返回值。</p><p>疑问：<br>1.既然const的迭代器和非const的迭代器都不能修改值，那有什么区别？<br>2.右值引用<br>3.为什么emplace没有返回值也能调用成功，是所有函数都这样吗？<br>4.emplace效率高的原因？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++的STL中的关联式容器set，包括其接口，用法和注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="set" scheme="https://zsh4614.cn/tags/set/"/>
    
    <category term="STL" scheme="https://zsh4614.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一四一题：环形链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E5%9B%9B%E4%B8%80%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E5%9B%9B%E4%B8%80%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-09T15:19:12.000Z</published>
    <updated>2022-01-10T14:58:13.569Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍leetcode第一四一题，判断一个链表是否有环，并给出其实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><h3 id="示例">示例</h3><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/09/TPnu4a8cX2GUMkJ.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/09/QzmCcjGbatMUu1E.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><img src="https://s2.loli.net/2022/01/09/QncUVqxFeY8jEyl.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 [0, 10^4]</li><li>10^5 &lt;= Node.val &lt;= 10^5</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><h3 id="分析">分析</h3><p>本题目最容易想到的是遍历链表，在遍历的过程中把每个结点存储起来，同时查询存储的里面是否有当前结点，如果有，那么说明是个环，如果遍历完没有，说明没有环；但是链表判圈有更加适合的判圈算法——<strong>佛洛依德判圈算法</strong>。</p><h3 id="实现">实现</h3><h4 id="实现一（哈希）">实现一（哈希）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; hashset;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.<span class="built_in">find</span>(head) != hashset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashset.<span class="built_in">emplace</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h4 id="实现二（判圈算法）">实现二（判圈算法）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    slow-&gt;next = head;</span><br><span class="line">    ListNode *fast = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>注意开始的状态，要把slow和fast定义为不同的指针，否则直接就输出true了，总而言之，一定要保证特殊情况下，尤其是开始状态的正确性</strong></p><h3 id="拓展">拓展</h3><p>1.<a href="">哈希容器（无序关联式容器）</a></p><p>2.<a href="">佛洛依德判圈算法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍leetcode第一四一题，判断一个链表是否有环，并给出其实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第二十一题：合并两个有序链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-09T15:12:40.000Z</published>
    <updated>2022-01-09T15:16:32.080Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第二十一题，合并两个有序链表，用迭代和递归两种方法实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="示例">示例</h3><p><img src="https://s2.loli.net/2022/01/09/L8AQHIcVbtk1ZUe.png" alt="image.png"></p><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;= s.length &lt;= 5 * 104</li><li>s由英文字母、数字、符号和空格组成</li></ul><h3 id="分析">分析</h3><p>该题目常规思路就是迭代两个链表的结点，比较大小，小的往后面移动一个结点，然后再比较大小，如此迭代下去，直到一个链表指针域为空，然后把另一个链表接上即可；另一种思路是递归，这种方法比较巧妙</p><p><img src="https://s2.loli.net/2022/01/09/BrE9Dsg1YaKXQvc.png" alt="image.png"></p><p>但是需要考虑其中一个为空的情况，作为迭代的出口。</p><h3 id="实现">实现</h3><h4 id="方法一-迭代">方法一(迭代)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode *work = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *dummy = work;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* &amp;tmp = list1-&gt;val &lt; list2-&gt;val ? list1 : list2;</span><br><span class="line">        work-&gt;next = tmp;</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    work-&gt;next = (list1 == <span class="literal">nullptr</span>) ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-递归">方法二(递归)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">        list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>链表中常用到dummy结点，用来解决头结点问题，这样可以使得头结点和一般结点没有什么区别，注意灵活应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第二十一题，合并两个有序链表，用迭代和递归两种方法实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://zsh4614.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
