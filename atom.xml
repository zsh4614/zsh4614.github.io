<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到我的主页!</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-24T05:34:56.320Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人主页</title>
    <link href="http://example.com/2021/04/24/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    <id>http://example.com/2021/04/24/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</id>
    <published>2021-04-24T05:23:22.000Z</published>
    <updated>2021-04-24T05:34:56.320Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="54f60cc61998a1be98f8a07bdf2a77c9d2814a74678e445719cf2ebfd6c03c51">518e54c91656481a908483089544e9165d5d3967b07fc15a6a03d2b43aa7874a07b7ad9973e03ffb04e093a7e4f51cd1a0d7eefaba3ff3ae23ee18e70f504d445e25643067bd41745f781595f666d10a0bb2348c890c7bb510da1604b342d0cb53f621b8622fd1dfc0875d772f114618fc9acc2feac2d3fd4c52ad023ede8bf8aea6169152d090235ecf3d93aafcc9a8090e4fd32a560c637199c40cd3b511afee5ccbf6619ad2e8bd7ba45feb855ed6158b6beffa62dac690ed11a4f966ea0a25a680f827c5fe72ba26adc6464a70c76aa10bc19c8c69aa604cc1f310e6526831fc9bb898cc8307df1c306455462714</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">您好, 请单击此处输入本文密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">引言：收藏一些优秀的个人主页及其介绍。</summary>
    
    
    
    <category term="外部资源" scheme="http://example.com/categories/%E5%A4%96%E9%83%A8%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构及实现：二叉查找树</title>
    <link href="http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2021-04-21T15:27:59.000Z</published>
    <updated>2021-04-22T16:42:47.762Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：二叉查找树的C++实现代码，并进行了测试。</p><span id="more"></span><h3 id="二叉查找树简介">二叉查找树简介</h3><p>二叉查找树(Binary Search Tree)，又被称为二叉搜索树。它是特殊的二叉树：对于二叉树，假设x为二叉树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。那么，这棵树就是二叉查找树。如下图所示：</p><p><img src="https://i.loli.net/2021/04/20/Ddq61aksuTCjpWK.jpg" alt="二叉查找树.jpg"></p><p>在二叉查找树中：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）任意节点的左、右子树也分别为二叉查找树；<br>（4）没有key值相等的节点。</p><h3 id="二叉查找树的C-实现">二叉查找树的C++实现</h3><h4 id="节点和二叉查找树的定义">节点和二叉查找树的定义</h4><h5 id="二叉查找树节点">二叉查找树节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T key;<span class="comment">// 关键字（键值）</span></span><br><span class="line">    BSTNode* left; <span class="comment">// 左孩子</span></span><br><span class="line">    BSTNode* right;<span class="comment">// 右孩子</span></span><br><span class="line">    BSTNode* parent;<span class="comment">// 父节点</span></span><br><span class="line">    <span class="built_in">BSTNode</span>(T value, BSTNode *p, BSTNode *l, BSTNode *r):</span><br><span class="line">    <span class="built_in">key</span>(value),<span class="built_in">parent</span>(p),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BSTNode是二叉查找树的节点，它包含二叉查找树的几个基本信息：</p><p>（1）key – 它是关键字，是用来对二叉查找树的节点进行排序的；<br>（2）left – 它指向当前节点的左孩子；<br>（3）right – 它指向当前节点的右孩子；<br>（4）parent – 它指向当前节点的父结点。</p><h5 id="二叉树操作">二叉树操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BSTNode&lt;T&gt;* mRoot;    <span class="comment">// 根结点</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTree</span>();</span><br><span class="line">    ~<span class="built_in">BSTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (递归实现)查找二叉树中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找二叉树中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回最小结点的键值</span></span><br><span class="line">    <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">    <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(z)插入到二叉树(tree)中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除二叉树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BSTree是二叉树。它包含二叉查找树的根节点和二叉查找树的操作。二叉查找树的操作中有许多重载函数，例如insert()函数，其中一个是内部接口，另一个是提供给外部的接口。</p><h4 id="遍历">遍历</h4><p>这里讲解前序遍历、中序遍历、后序遍历3种方式。</p><h5 id="前序遍历">前序遍历</h5><p>若二叉树非空，则执行以下操作：</p><p>（1）访问根结点；<br>（2）先序遍历左子树；<br>（3）先序遍历右子树。</p><p>前序遍历代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历">中序遍历</h5><p>若二叉树非空，则执行以下操作：</p><p>（1）中序遍历左子树；<br>（2）访问根结点；<br>（3）中序遍历右子树。</p><p>中序遍历代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历">后序遍历</h5><p>若二叉树非空，则执行以下操作：</p><p>（1）后序遍历左子树；<br>（2）后序遍历右子树；<br>（3）访问根结点。</p><p>后序遍历代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看下面这颗树的各种遍历方式：</p><p><img src="https://i.loli.net/2021/04/22/yiEtOTcJC1bw8Wu.jpg" alt="二叉树遍历.jpg"></p><p>对于上面的二叉树而言，<br>（1）前序遍历结果： 3 1 2 5 4 6<br>（2）中序遍历结果： 1 2 3 4 5 6<br>（3）后序遍历结果： 2 1 4 6 5 3</p><h4 id="查找">查找</h4><p>递归版本的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大值和最小值">最大值和最小值</h4><p>查找最大值的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">maximum</span>(BSTNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">maximum</span>() &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最小值的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">minimum</span>(BSTNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">minimum</span>() &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前驱和后继">前驱和后继</h4><p>节点的前驱：是该节点的左子树中的最大节点。<br>节点的后继：是该节点的右子树中的最小节点。</p><p>查找前驱节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">predecessor</span>(BSTNode&lt;T&gt; *x) &#123;</span><br><span class="line">    <span class="comment">// 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maximum</span>(x-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;left)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找后继节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">successor</span>(BSTNode&lt;T&gt; *x) &#123;</span><br><span class="line">    <span class="comment">// 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(x-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;right)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入">插入</h4><p>插入节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)  &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(T key) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><p>删除节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">remove</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *x=<span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *y=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == <span class="literal">NULL</span>) || (z-&gt;right == <span class="literal">NULL</span>) )</span><br><span class="line">        y = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = <span class="built_in">successor</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = y-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        tree = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left)</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z) </span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">remove</span>(T key) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z, *node; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> ( (node = <span class="built_in">remove</span>(mRoot, z)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印">打印</h4><p>打印二叉查找树的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值 </span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction) &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁">销毁</h4><p>销毁二叉查找树的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>(BSTNode&lt;T&gt;* &amp;tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">    tree=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>() &#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树的C-实现（完整源码）">二叉查找树的C++实现（完整源码）</h3><p>二叉查找树的C++实现文件(BSTree.h)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BINARY_SEARCH_TREE_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BINARY_SEARCH_TREE_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T key;            <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode *parent;<span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">BSTNode</span>(T value, BSTNode *p, BSTNode *l, BSTNode *r):</span><br><span class="line">            <span class="built_in">key</span>(value),<span class="built_in">parent</span>(),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        BSTNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BSTree</span>();</span><br><span class="line">        ~<span class="built_in">BSTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;二叉树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;二叉树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line">        <span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到二叉树(tree)中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除二叉树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTree&lt;T&gt;::<span class="built_in">BSTree</span>():<span class="built_in">mRoot</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTree&lt;T&gt;::~<span class="built_in">BSTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">minimum</span>(BSTNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">minimum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">maximum</span>(BSTNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">maximum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">successor</span>(BSTNode&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(x-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;right))</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">predecessor</span>(BSTNode&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maximum</span>(x-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;left))</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">remove</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *x=<span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *y=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == <span class="literal">NULL</span>) || (z-&gt;right == <span class="literal">NULL</span>) )</span><br><span class="line">        y = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = <span class="built_in">successor</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = y-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        tree = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left)</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z)</span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z, *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> ( (node = <span class="built_in">remove</span>(mRoot, z)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>(BSTNode&lt;T&gt;* &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">    tree=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值</span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>关于二叉查找树的C++实现有两点需要补充说明的:<br>第1点：采用了STL模板。因此，二叉查找树支持任意数据类型。<br><strong>第2点：将二叉查找树的&quot;声明&quot;和&quot;实现&quot;都位于BSTree.h中。这是因为，在二叉查找树的实现采用了模板；而C++编译器不支持对模板的分离式编译！</strong></p><h3 id="二叉查找树的C-测试程序">二叉查找树的C++测试程序</h3><p>二叉查找树的C++测试程序(BSTreeTest.cpp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BSTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]= &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ilen;</span><br><span class="line">    BSTree&lt;<span class="keyword">int</span>&gt;* tree=<span class="keyword">new</span> BSTree&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 依次添加: &quot;</span>;</span><br><span class="line">    ilen = <span class="built_in">TBL_SIZE</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree-&gt;<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 前序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">preOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 后序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最小值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">minimum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最大值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">maximum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 删除根节点: &quot;</span> &lt;&lt; arr[<span class="number">3</span>];</span><br><span class="line">    tree-&gt;<span class="built_in">remove</span>(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    tree-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">== 依次添加: <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line">== 前序遍历: <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line">== 中序遍历: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line">== 后序遍历: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line">== 最小值: <span class="number">1</span></span><br><span class="line">== 最大值: <span class="number">6</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"> <span class="number">1</span> is root</span><br><span class="line"> <span class="number">5</span> is  <span class="number">1&#x27;</span>s  right child</span><br><span class="line"> <span class="number">4</span> is  <span class="number">5&#x27;</span>s   left child</span><br><span class="line"> <span class="number">3</span> is  <span class="number">4&#x27;</span>s   left child</span><br><span class="line"> <span class="number">2</span> is  <span class="number">3&#x27;</span>s   left child</span><br><span class="line"> <span class="number">6</span> is  <span class="number">5&#x27;</span>s  right child</span><br><span class="line">== 删除根节点: <span class="number">3</span></span><br><span class="line">== 中序遍历: <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>下面对测试程序的流程进行分析！</p><p>（1）新建&quot;二叉查找树&quot;root。</p><p>（2）向二叉查找树中依次插入1,5,4,3,2,6 。如下图所示：</p><p><img src="https://i.loli.net/2021/04/23/FEi64SOw2lDA5Ye.jpg" alt="二叉树插入.jpg"></p><p>（3）遍历和查找，插入1,5,4,3,2,6之后，得到的二叉查找树如下：</p><p><img src="https://i.loli.net/2021/04/23/6TpIrWFCBYcxJKw.jpg" alt="二叉树插入结果.jpg"></p><p>​前序遍历结果: <strong>1 5 4 3 2 6</strong><br>​中序遍历结果: <strong>1 2 3 4 5 6</strong><br>​后序遍历结果: <strong>2 3 4 6 5 1</strong><br>​最小值是1，而最大值是6。</p><p>（4）删除节点3。如下图所示：</p><p><img src="https://i.loli.net/2021/04/23/8tqzVLSWJUEb4rX.jpg" alt="二叉树删除节点.jpg"></p><p>（5）重新遍历该二叉查找树。<br>​中序遍历结果: <strong>1 2 4 5 6</strong></p><h3 id="总结">总结</h3><p>二叉查找树的C++实现代码，并进行了测试。</p><blockquote><p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3576373.html">https://www.cnblogs.com/skywang12345/p/3576373.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：二叉查找树的C++实现代码，并进行了测试。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="二叉查找树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
    <category term="前序遍历" scheme="http://example.com/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    <category term="前驱节点和后继节点" scheme="http://example.com/tags/%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9%E5%92%8C%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/"/>
    
    <category term="递归和迭代" scheme="http://example.com/tags/%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及实现：二叉树</title>
    <link href="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-04-19T15:32:34.000Z</published>
    <updated>2021-04-22T16:42:26.862Z</updated>
    
    <content type="html"><![CDATA[<p>引言：整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。</p><span id="more"></span><h3 id="1-树的定义">1.树的定义</h3><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p><p><img src="https://i.loli.net/2021/04/19/jiL6wsCPZEWlOA3.jpg" alt="二叉树.jpg"></p><p>把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><p>(1) 每个节点有零个或多个子节点；<br>(2)没有父节点的节点称为根节点；<br>(3)每一个非根节点有且只有一个父节点；<br>(4) 除了根节点外，每个子节点可以分为多个不相交的子树。</p><h3 id="2-树的基本术语">2.树的基本术语</h3><p>若一个结点有子树，那么该结点称为子树根的&quot;双亲&quot;，子树的根是该结点的&quot;孩子&quot;。有相同双亲的结点互为&quot;兄弟&quot;。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。</p><p><strong>结点的度</strong>：结点拥有的子树的数目。<br><strong>叶子</strong>：度为零的结点。<br><strong>分支结点</strong>：度不为零的结点。<br><strong>树的度</strong>：树中结点的最大的度。<br><strong>层次</strong>：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br><strong>树的高度</strong>：树中结点的最大层次。<br><strong>无序树</strong>：如果树中结点的各子树之间的次序是不重要的，可以交换位置。<br><strong>有序树</strong>：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。<br><strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</p><h3 id="3-二叉树的定义">3.二叉树的定义</h3><p>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</p><p><img src="https://i.loli.net/2021/04/19/hUJdVmo3Ln9H4GD.jpg" alt="二叉树2.jpg"></p><h3 id="4-二叉树的性质">4.二叉树的性质</h3><p>二叉树有以下几个性质：</p><p><strong>性质1</strong>：二叉树第i层上的结点数目最多为 2<sup>{i-1}</sup> (i≥1)。<br><strong>性质2</strong>：深度为k的二叉树至多有2<sup>{k}</sup>-1个结点(k≥1)。<br><strong>性质3</strong>：包含n个结点的二叉树的高度至少为log<sub>2</sub> (n+1)。<br><strong>性质4</strong>：在任意一棵二叉树中，若叶子结点的个数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</p><blockquote><p>注：性质4的证明<br>因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=“0度结点数(n<sub>0</sub>)” + “1度结点数(n<sub>1</sub>)” + “2度结点数(n<sub>2</sub>)”。由此，得到 n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>；<br>另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n<sub>1</sub>+2n<sub>2</sub>。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为n=n<sub>1</sub>+2n<sub>2</sub>+1，两式相等，可得。</p></blockquote><h3 id="5-满二叉树，完全二叉树和二叉查找树">5.满二叉树，完全二叉树和二叉查找树</h3><p><strong>满二叉树</strong>：高度为h，并且由2<sup>{h}</sup> –1个结点的二叉树，被称为满二叉树。</p><p><img src="https://i.loli.net/2021/04/20/uPBhqe7XQxT6wKU.jpg" alt="满二叉树.jpg"></p><p><strong>完全二叉树</strong>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p><p><img src="https://i.loli.net/2021/04/20/cdp2J1GUN87EvjS.jpg" alt="完全二叉树.jpg"></p><p><strong>二叉查找树</strong>：二叉查找树，又被称为<strong>二叉搜索树</strong>。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p><p><img src="https://i.loli.net/2021/04/20/Ddq61aksuTCjpWK.jpg" alt="二叉查找树.jpg"></p><p>在二叉查找树中：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）任意节点的左、右子树也分别为二叉查找树；<br>（4）没有key值相等的节点。</p><h3 id="6-总结">6.总结</h3><p>整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。</p><blockquote><p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3576328.html">https://www.cnblogs.com/skywang12345/p/3576328.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch学习笔记：transforms中的方法</title>
    <link href="http://example.com/2021/04/19/PyTorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Atransforms%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/04/19/PyTorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Atransforms%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-18T16:04:56.000Z</published>
    <updated>2021-04-18T16:07:15.537Z</updated>
    
    <content type="html"><![CDATA[<p>引言 ：torchvision.transforms是pytorch中的图像预处理包，包含了很多种对图像数据进行变换的函数，这些都是在我们进行图像数据读入步骤中必不可少的。</p><span id="more"></span><h3 id="1-综述">1.综述</h3><p>transforms中的方法可以归纳为四大类：</p><ul><li><p>裁剪：</p><p>中心裁剪：<code>transforms.CenterCrop</code><br>随机裁剪：<code>transforms.RandomCrop</code><br>随机长宽比裁剪：<code>transforms.RandomResizedCrop</code><br>上下左右中心裁剪：<code>transforms.FiveCrop</code><br>上下左右中心裁剪后翻转：<code>transforms.TenCrop</code></p></li><li><p>翻转和旋转：</p><p>依概率p水平翻转：<code>transforms.RandomHorizontalFlip</code><br>依概率p垂直翻转：<code>transforms.RandomVerticalFlip</code><br>随机翻转：<code>transforms.RandomRotation</code></p></li><li><p>图像变换：</p><p>resize：<code>transforms.Resize</code><br>标准化：<code>transforms.Normalize</code><br>转tensor并归一化：<code>transforms.ToTensor</code><br>填充：<code>transforms.Pad</code><br>修改亮度、对比度、饱和度：<code>transforms.ColorTitter</code><br>转灰度图：<code>transforms.Grayscale</code><br>线性变换：<code>transforms.LinearTransformation</code><br>仿射变换：<code>transforms.RandomAffine</code><br>依概率p转为灰度图：<code>transforms.RandomGrayscale</code><br>将数据转换为PILImage：<code>transforms.ToPILImage</code><br>依自定义的lambda函数变换：<code>transforms.Lambda</code></p></li><li><p>对transforms操作，使数据增强更灵活：</p><p>选择一个transforms进行操作：<code>transforms.RandomChoice(transforms)</code><br>给一个transforms加上概率，依概率进行操作：<code>transforms.RandomApply(transforms,p=0.5)</code><br>将transforms中的操作随机打乱：<code>transforms.RandomOrder</code></p></li></ul><h3 id="2-裁剪">2.裁剪</h3><p><strong>1.中心裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.CenterCrop(size) </span><br></pre></td></tr></table></figure><p><code>size</code>：为sequence或者int，若为sequence，则为(h，w)，若为int，则进行正方形裁剪</p><p><strong>2.随机裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomCrop(size，padding = <span class="literal">None</span>，pad_if_needed = <span class="literal">False</span>，fill = <span class="number">0</span>，padding_mode =<span class="string">&#x27;constant&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>size</code>：为sequence或者int，若为sequence，则为(h，w)，若为int，则进行正方形裁剪</p><p><code>padding</code>：为sequence或者int，可选的，图像每个边上的填充，默认为None，即不填充。如果提供长度为4的序列，则它用于分别填充左，上，右，下边界。如果提供长度为2的序列，则分别用于填充左/右，上/下边界</p><p><code>pad_if_needed</code>：bool类型，如果小于所需大小，它将填充图像以避免引发异常</p><p><code>fill</code>：恒定填充的像素填充值。默认值为0.如果长度为3的元组，则分别用于填充R，G，B通道。仅当padding_mode为constant时才使用此值</p><p><code>padding_mode</code>：填充类型，可选：constant，edge，reflect，symmetric。constant是填充指定像素值，edge是填充边缘像素值，reflect是反射填充，比如用2个元素填充[1,2,3,4]为[3,2,1,2,3,4,3,2]，symmetric是对称填充，比如用2个像素填充[1,2,3,4]为[2,1,1,2,3,4,4,3]</p><p><strong>3.随机长宽比裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomResizedCrop(size, scale=(<span class="number">0.08</span>, <span class="number">1.0</span>), ratio=(<span class="number">0.75</span>, <span class="number">1.3333333333333333</span>), interpolation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将给定的PIL图像随机大小和宽高比裁剪，最后resize到指定大小</p><p><code>size</code>：输出大小</p><p><code>scale</code>：裁剪的原始尺寸的大小范围</p><p><code>ratio</code>：裁剪的原始宽高比的宽高比范围</p><p><code>interpolation</code>：resize的插值方式，默认为BILINEAR</p><p><strong>4.上下左右中心裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.FiveCrop(size)</span><br></pre></td></tr></table></figure><p>对图片进行上下左右以及中心裁剪，获得5张图片，返回一个4D-tensor</p><p><code>size</code>： sequence或者int，若为sequence,则为(h,w)，若为int，则为正方形</p><p><strong>5.上下左右中心裁剪后翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.TenCrop(size, vertical_flip=<span class="literal">False</span>) </span><br></pre></td></tr></table></figure><p>对图片进行上下左右以及中心裁剪，返回裁剪得到的5张图像加上5张翻转图像共10张图像（默认水平翻转）</p><p><code>size</code>：sequence或者int，若为sequence,则为(h,w)，若为int，则为正方形</p><p><code>vertical_flip</code>：bool类型，使用垂直翻转而不是水平翻转</p><h3 id="3-翻转和旋转">3.翻转和旋转</h3><p><strong>6.依概率p水平翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>以给定的概率随机水平翻转给定的PIL图像</p><p><code>p</code>：图像被翻转的概率，默认为0.5</p><p><strong>7.依概率p垂直翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomVerticalFlip(p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>以给定的概率随机垂直翻转给定的PIL图像</p><p><code>p</code>：图像被翻转的概率，默认为0.5</p><p><strong>8.随机旋转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomRotation(degrees, resample=<span class="literal">False</span>, expand=<span class="literal">False</span>, center=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>按角度旋转图像</p><p><code>degrees</code>：sequence 或float或int，要选择的度数范围。如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+ degrees）</p><p><code>resample</code>：插值方式</p><p><code>expand</code>：可选的扩展标志。如果为true，则展开输出以使其足够大以容纳整个旋转图像。如果为false或省略，则使输出图像与输入图像的大小相同。</p><p><code>center</code>：2元tuple，可选的旋转中心。原点是左上角。默认值是图像的中心。</p><h3 id="4-图像变换">4.图像变换</h3><p><strong>9.resize</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Resize(size, interpolation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将输入PIL图像的大小调整为给定大小。</p><p><code>size</code>：sequence 或int，所需的输出大小。如果size是类似（h，w）的序列，则输出大小将与此匹配。如果size是int，则<strong>图像的较小边缘将与此数字匹配。即，如果高度&gt;宽度，则图像将重新缩放为（尺寸*高度/宽度，尺寸）</strong></p><p><code>interpolation</code>：插值方式，默认为BILINEAR</p><p><strong>10.标准化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Normalize(mean, std)</span><br></pre></td></tr></table></figure><p>用平均值和标准差归一化张量图像。给定mean：(M1,…,Mn)和std：(S1,…,Sn)对于n通道，此变换将标准化输入的每个通道</p><p><code>mean</code>：sequence，每个通道的均值序列</p><p><code>std</code>：sequence，每个通道的标准差序列</p><p><strong>11.转tensor并归一化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.ToTensor</span><br></pre></td></tr></table></figure><p>将PIL Image或者 ndarray 转换为tensor，并且归一化至[0-1]。<strong>若自己的ndarray数据尺度有变化，则需要自行修改。</strong></p><p><strong>12.填充</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Pad(padding, fill=<span class="number">0</span>, padding_mode=<span class="string">&#x27;constant&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>padding</code>：为sequence或者int，可选的，图像每个边上的填充，默认为None，即不填充。如果提供长度为4的序列，则它用于分别填充左，上，右，下边界。如果提供长度为2的序列，则分别用于填充左/右，上/下边界</p><p><code>fill</code>：恒定填充的像素填充值。默认值为0.如果长度为3的元组，则分别用于填充R，G，B通道。仅当padding_mode为constant时才使用此值</p><p><code>padding_mode</code>：填充类型，可选：constant，edge，reflect，symmetric。constant是填充指定像素值，edge是填充边缘像素值，reflect是反射填充，比如用2个元素填充[1,2,3,4]为[3,2,1,2,3,4,3,2]，symmetric是对称填充，比如用2个像素填充[1,2,3,4]为[2,1,1,2,3,4,4,3]</p><p><strong>13.修改亮度、对比度和饱和度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.ColorJitter(brightness=<span class="number">0</span>, contrast=<span class="number">0</span>, saturation=<span class="number">0</span>, hue=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>brightness</code>： float或者元组，从该范围内随机选择brightness_factor</p><p><code>contrast</code>：float或者元组，从该范围内随机选择contrast_factor</p><p><code>saturation</code>：float或者元组，从该范围内随机选择saturation_factor</p><p><code>hue</code>：float或者元组，从该范围内随机选择hue_factor</p><p><strong>14.转灰度图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Grayscale(num_output_channels=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>num_output_channels</code>：当为1时，正常的灰度图，当为3时，r == g == b的图像</p><p><strong>15.线性变换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.LinearTransformation(transformation_matrix) </span><br></pre></td></tr></table></figure><p>用一个转换矩阵和一个离线计算出的均值向量将图片进行转换。给定转换矩阵transformation_matrix后,会将torch.*Tensor平铺并按位减mean_vector之后与转换矩阵做点积（dot product）运算，最后将shape转换成原始尺寸</p><p><strong>16.仿射变换</strong></p><p>图像保持中心不变的随机仿射变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomAffine(degrees, translate=<span class="literal">None</span>, scale=<span class="literal">None</span>, shear=<span class="literal">None</span>, resample=<span class="literal">False</span>, fillcolor=<span class="number">0</span>) </span><br></pre></td></tr></table></figure><p><code>degrees</code>：sequence或float或int，要选择的度数范围。如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+degrees）。设置为0可停用旋转</p><p><code>translate</code>：元组，可选。水平和垂直平移的最大绝对分数元组。例如translate =（a，b），然后在范围-img_width * a &lt;dx &lt;img_width * a中随机采样水平移位，并且在-img_height * b &lt;dy &lt;img_height * b范围内随机采样垂直移位。默认情况下不会平移</p><p><code>scale</code>：元组，可选。缩放因子间隔，例如（a，b），然后从范围a &lt;= scale &lt;= b中随机采样缩放。默认情况下会保持原始比例</p><p><code>shear</code>：sequence 或float或int，可选，错切角度范围， 如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+ degrees）。默认情况下不会应用错切</p><p><code>resample</code>：插值方式，默认为BILINEAR</p><p><code>fillcolor</code>：输出图像中变换外部区域的可选填充颜色</p><p><strong>17.依概率p转为灰度图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomGrayscale(p=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>依概率p将图片转换为灰度图，若通道数为3，则输出r == g == b的图像</p><p><strong>18.将数据转换为PILImage</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.ToPILImage()</span><br></pre></td></tr></table></figure><p>将tensor 或者 ndarray的数据转换为 PIL Image 类型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：对于一个Tensor的转化过程是</span><br><span class="line">1.将张量的每个元素乘上255</span><br><span class="line">2.将张量的数据类型由FloatTensor转化成Uint8</span><br><span class="line">3.将张量转化成numpy的ndarray类型</span><br><span class="line">4.对ndarray对象做permute (1, 2, 0)的操作</span><br><span class="line">5.利用Image下的fromarray函数，将ndarray对象转化成PILImage形式</span><br><span class="line">6.输出PILImage</span><br></pre></td></tr></table></figure><p><strong>19.依自定义的lambda函数变换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Lambda（<span class="keyword">lambda</span>）</span><br></pre></td></tr></table></figure><p>将用户定义的lambda应用为变换。</p><p><code>lambda</code>：用于转换的Lambda函数</p><h3 id="5-对transforms操作，使数据增强更灵活">5.对transforms操作，使数据增强更灵活</h3><p><strong>20.选择一个transforms进行操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomChoice(transforms)</span><br></pre></td></tr></table></figure><p>从给定的一系列transforms中选一个进行操作</p><p><strong>21.给一个transform加上概率，以一定的概率执行该操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomApply(transforms, p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><code>transforms</code>：列表或元组，要操作的transforms列表</p><p><code>p</code>：概率</p><p><strong>22.将transforms中的操作随机打乱</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomOrder(transforms)</span><br></pre></td></tr></table></figure><p><code>transforms</code>：列表或元组，要操作的transforms列表</p><h3 id="6-Compose操作">6.Compose操作</h3><p>将一系列操作组合在一起，按顺序执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Compose(transforms)</span><br></pre></td></tr></table></figure><p><code>transforms</code>：要组合的transforms列表</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), std = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="7-总结">7.总结</h3><p>上面所述transforms方法中，只有少部分是经常用到的，熟练掌握经常用到的即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言 ：torchvision.transforms是pytorch中的图像预处理包，包含了很多种对图像数据进行变换的函数，这些都是在我们进行图像数据读入步骤中必不可少的。&lt;/p&gt;</summary>
    
    
    
    <category term="PyTorch" scheme="http://example.com/categories/PyTorch/"/>
    
    
    <category term="torchvision.transforms" scheme="http://example.com/tags/torchvision-transforms/"/>
    
    <category term="图像预处理函数" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中的static关键字总结</title>
    <link href="http://example.com/2021/04/18/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/04/18/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-18T15:55:34.000Z</published>
    <updated>2021-04-18T16:03:54.049Z</updated>
    
    <content type="html"><![CDATA[<p>引言：C++的static有两种用法，面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。</p><span id="more"></span><h3 id="1-面向过程设计中的static">1.面向过程设计中的static</h3><h4 id="1-1静态全局变量">1.1静态全局变量</h4><p>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量，我们先举一个静态全局变量的例子，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态全局变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而<strong>在文件之外是不可见</strong>的；</li></ul><p>静态变量都在<strong>全局数据区</strong>分配内存，包括后面将要提到的静态局部变量。</p><p>一般程序的由new产生的动态数据存放在<strong>堆区</strong>，函数内部的自动变量存放在<strong>栈区</strong>。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在<strong>全局数据区</strong>。全局数据区的数据并不会因为函数的退出而释放空间。细心的读者可能会发现，上面的代码中将<code>static int n;</code>改为<code>int n; </code>。程序照样正常运行。的确，定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：</p><ul><li>静态全局变量不能被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ul><p>将上述示例代码改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　n=<span class="number">20</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 n++;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行，会发现上述代码可以分别通过编译，但运行时出现错误。将<code>static int n;</code>改为<code>int n;</code>，再次编译运行程序，就会明白全局变量和静态全局变量的区别。</p><h4 id="1-2静态局部变量">1.2静态局部变量</h4><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 我们先举一个静态局部变量的例子，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="keyword">static</span> n=<span class="number">10</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">　　 n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时，都会给该局部变量分配栈区内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p><p>静态局部变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li></ul><h4 id="1-3静态函数">1.3静态函数</h4><p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;<span class="comment">//声明静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;<span class="comment">//定义静态函数</span></span><br><span class="line"> 　　<span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义静态函数的好处：</p><ul><li>静态函数不能被其它文件所用；</li><li>其它文件中可以定义相同名字的函数，不会发生冲突。</li></ul><h3 id="2-面向对象的static关键字">2.面向对象的static关键字</h3><h4 id="2-1静态数据成员">2.1静态数据成员</h4><p>在类内的数据成员的声明前加上关键字static，该数据成员就是类内的静态成员函数，先举一个静态数据成员的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 　　<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line"> 　　<span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 　　<span class="keyword">int</span> a,b,c;</span><br><span class="line"> 　　<span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) &#123;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> 　　Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line">　　 <span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> 　　N.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态数据成员有以下特点：</p><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也<strong>只有一份拷贝</strong>，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</li><li><strong>静态数据成员存储在全局数据区</strong>。静态数据成员<strong>定义时要分配空间，所以不能在类声明中定义</strong>。在上述程序中，语句<code>int Myclass::Sum=0;</code>是定义静态数据成员；</li><li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li><li>静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：<code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code></li><li>类的静态数据成员有两种访问形式：<code>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞</code></li><li>静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以<strong>节省存储空间</strong>。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；</li><li>同全局变量相比，使用静态数据成员有两个优势：<ul><li>静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；</li><li>可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</li></ul></li></ul><h4 id="2-2静态成员函数">2.2静态成员函数</h4><p>与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。<strong>普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身</strong>，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它<strong>不具有this指针</strong>。从这个意义上讲，它<strong>无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数</strong>。下面举个静态成员函数的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 　　<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line"> 　　<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;/声明静态成员函数</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 　　<span class="keyword">int</span> a,b,c;</span><br><span class="line">　　 <span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> 　　Sum+=a+b+c; <span class="comment">//非静态成员函数可以访问静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> <span class="comment">//静态成员函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="comment">// cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员</span></span><br><span class="line"> 　　cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> 　　N.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　Myclass::<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于静态成员函数，可以总结为以下几点：</p><ul><li>出现在类体外的函数<strong>定义不能指定关键字static</strong>；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li><li>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式调用类的静态成员函数：<code>＜类名＞::＜静态成员函数名＞（＜参数表＞）</code>。</li></ul><h3 id="3-总结">3.总结</h3><p><strong>从作用域看</strong>，全局变量具有全局作用域，全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用<code>extern</code> 关键字再次声明这个全局变量。局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p><p><strong>从分配内存空间来看</strong>，<strong>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</strong></p><p><strong>综上，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期，并没有改变它的作用域，即作用域还是在函数内部。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：C++的static有两种用法，面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="static关键字" scheme="http://example.com/tags/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    <category term="全局变量" scheme="http://example.com/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
    <category term="局部变量" scheme="http://example.com/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="静态全局变量" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
    <category term="静态局部变量" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="静态成员函数" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    
    <category term="静态数据成员" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/"/>
    
    <category term="作用域" scheme="http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    <category term="生存期" scheme="http://example.com/tags/%E7%94%9F%E5%AD%98%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++构造函数不能声明为虚函数</title>
    <link href="http://example.com/2021/04/18/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/04/18/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-18T15:43:07.000Z</published>
    <updated>2021-04-18T15:52:23.189Z</updated>
    
    <content type="html"><![CDATA[<p>引言：构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时是必须声明为虚函数。</p><span id="more"></span><h3 id="1-背景">1.背景</h3><p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数，且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为<strong>动态联编</strong>。而函数的重载可以认为是多态，只不过是静态的。如果使用了<code>virtual</code>关键字，程序将根据引用或指针指向的对象类型来选择方法，否则使用引用类型或指针类型来选择方法。我们知道，在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。所以，基类的析构函数一定要定义成虚函数，那么构造函数为什么不能定义成虚函数呢？</p><h3 id="2-虚函数的底层实现机制">2.虚函数的底层实现机制</h3><p>要想搞清楚这个问题，首先要弄明白虚函数的底层是如何实现的。</p><p>编译器处理虚函数的方法是：首先为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。称为<strong>虚表指针（vptr）</strong>，这种数组称为<strong>虚函数表</strong>，即每个类使用一个虚函数表，每个类对象有一个虚表指针。</p><p>举个例子：基类对象包含一个虚表指针，指向基类所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表，看下面两种情况：</p><ul><li>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数地址，而不是基类的虚函数地址。</li><li>如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中的虚函数表将保存基类中未被重写的虚函数地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</li></ul><p>下面的图片体现了上述底层实现机制：</p><p><img src="https://i.loli.net/2021/04/18/luwBIOtfY3r1EWy.png" alt="虚函数的底层实现.jpg"></p><h3 id="3-原因">3.原因</h3><p>搞明白虚函数的底层实现机制之后，这个问题就迎刃而解了。虚函数的执行依赖于虚表指针查找虚函数表的操作，而对象的虚表指针在构造函数中进行初始化，让它指向正确的虚函数地址，而在构造对象期间，虚表指针还没有被初始化，所以将无法执行查表操作。</p><p>虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时是必须声明为虚函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="构造函数" scheme="http://example.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
    <category term="虚函数" scheme="http://example.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="底层实现" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="虚函数表" scheme="http://example.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
    <category term="虚表指针" scheme="http://example.com/tags/%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++之memset和fill函数</title>
    <link href="http://example.com/2021/04/17/C-%E4%B9%8Bmemset%E5%92%8Cfill%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/04/17/C-%E4%B9%8Bmemset%E5%92%8Cfill%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-16T16:37:45.000Z</published>
    <updated>2021-04-16T16:40:03.635Z</updated>
    
    <content type="html"><![CDATA[<p>引言：memset和fill都能进行赋值操作，但是二者有所区别，使用场景和方法也不同。</p><span id="more"></span><h3 id="1-问题引出">1.问题引出</h3><p>当我们运行下面一段代码试图将数组中的所有数字全部设置为1的时候，会发生预期之外的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main &#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现输出以下的结果：</p><p><code>16843009 16843009 16843009 16843009 16843009</code></p><h3 id="2-原因">2.原因</h3><p>为什么和我们的预期不符？这是因为<code>memset()</code>函数是<strong>以字节为单位进行赋值</strong>的，一个int型数据有4个字节，在上面的例子中我们赋的值是十六进制<code>0x01010101</code>，即二进制数<code>00000001 00000001 00000001 00000001</code>，换算成十进制就是16843009，所以会得出上面的结果。</p><p>所以如果想将int型数组置为想要的十进制数，<strong>只能用<code>memset()</code>置为0或者-1</strong>，因为0的二进制表示全为0， -1的二进制表示全为1，按字节为单位完成赋值的结果保持不变。</p><p>一般情况下，<code>memset()</code>只用来给char型数组赋值，或者对int型数组进行全0或者全1操作。</p><h3 id="3-解决方法">3.解决方法</h3><p><code>fill()</code>函数<strong>按照单元进行赋值</strong>，将一个区间的元素都赋予同一个值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    fill(a, a+5, 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现对数值中每个元素都赋值为1的目的，也可以对容器进行赋值，注意第一个参数和第二个参数是容器的迭代器。</p><h3 id="4-总结">4.总结</h3><p>1.<code>memset()</code>和<code>fill()</code>都可以实现赋值操作；<br>2.<code>memset()</code>是以字节为单位进行，对int型数组赋值只能赋值为0或者-1，<code>fill()</code>以元素为单位进行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：memset和fill都能进行赋值操作，但是二者有所区别，使用场景和方法也不同。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="memset" scheme="http://example.com/tags/memset/"/>
    
    <category term="fill" scheme="http://example.com/tags/fill/"/>
    
  </entry>
  
  <entry>
    <title>详解C++拷贝构造函数和赋值运算符</title>
    <link href="http://example.com/2021/04/13/%E8%AF%A6%E8%A7%A3C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://example.com/2021/04/13/%E8%AF%A6%E8%A7%A3C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2021-04-12T17:33:07.000Z</published>
    <updated>2021-04-17T12:20:38.875Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍了拷贝构造函数和赋值运算符的区别，以及在什么时候调用拷贝构造函数、什么情况下调用赋值运算符；同时较为详细的说明了拷贝构造函数必须以引用的方式传递参数。</p><span id="more"></span><h3 id="1-拷贝构造函数和拷贝赋值运算符">1.拷贝构造函数和拷贝赋值运算符</h3><p>在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但用户可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示无法调用该函数，它是已删除的函数。</p><h3 id="2-何时调用">2.何时调用</h3><p>拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值<strong>生成一个新的对象的实例</strong>，而赋值运算符是将对象的值复制给一个<strong>已经存在的实例</strong>。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是<strong>创建一个新的对象实例</strong>；赋值运算符是执行某种运算，将一个对象的值复制给另一个<strong>已经存在的对象</strong>。<strong>调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。</strong></p><p><strong>调用拷贝构造函数主要有以下场景：</strong></p><ul><li>对象作为函数的参数，以值传递的方式传给函数；</li><li>对象作为函数的返回值，以值的方式从函数返回；</li><li>使用一个对象给另一个对象初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Assign operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do1</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">do2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    Person p1 = p;<span class="comment">// 第一种情况</span></span><br><span class="line">    Person p2;</span><br><span class="line">    p2 = p; <span class="comment">// 第二种情况</span></span><br><span class="line">    <span class="built_in">do1</span>(p2); <span class="comment">// 第三种情况</span></span><br><span class="line">    p2 = <span class="built_in">do2</span>(); <span class="comment">// 第四种情况</span></span><br><span class="line">    Person p3 = <span class="built_in">do2</span>();<span class="comment">// 第五种情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义了一个类Person，显式的定义了拷贝构造函数和赋值运算符。然后定义了两个函数：do1以值传递的方式将对象作为函数的参数传入函数；do2以值的方式返回Person对象。执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一种情况： Copy Constructor</span><br><span class="line">第二种情况： Assign operator</span><br><span class="line">第三种情况： Copy Constructor</span><br><span class="line">第四种情况： Copy Constructor</span><br><span class="line">           Assign operator</span><br><span class="line">第五种情况： Copy Constructor</span><br></pre></td></tr></table></figure><p>分析如下：</p><p>第一种情况：使用已经存在的对象p创建新对象p1，产生了新对象，所以调用拷贝构造函数；</p><p>第二种情况：将对象p的值复制给已经存在的对象p2，为一个已经存在的对象赋值，所以调用赋值运算符；</p><p>第三种情况：以值传递的方式将对象p2传入函数内，所以是调用拷贝构造函数创建一个函数do1可用的实参；</p><p>第四种情况：函数do2以值的方式返回一个对象，由于这是一个局部对象，声明周期在函数内，所以返回的是一个它的拷贝，具体就是在返回时调用拷贝构造函数创建一个临时对象作为返回值；返回后调用赋值运算符将该临时对象复制给已经存在的对象p2；所以先调用拷贝构造函数，再调用赋值运算符；</p><p>第五种情况：按理来说应该先调用一次拷贝构造函数创建临时对象，再调用拷贝构造函数用临时对象创建新对象p3，调用两次拷贝构造函数，但是这实际上只调用了一次拷贝构造函数，这是因为直接在函数返回时调用拷贝构造函数创建了对象p3，因为编译器认为返回临时对象这一步是多余的，直接把p3当做了“临时对象”。</p><h3 id="3-拷贝构造函数必须以引用的方式传递参数">3.拷贝构造函数必须以引用的方式传递参数</h3><p>这一点要特别注意，即拷贝构造函数的形参必须是引用或者常引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p)</span><br></pre></td></tr></table></figure><p>而不能是值或者指针，下面分别对以值的方式传递参数和以指针的方式传递参数进行分析。</p><p>1.以值的方式传递参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person p)</span><br></pre></td></tr></table></figure><p>看起来好像和传引用的方式相比只是减少了一次内存拷贝，其实实际上不是这样的。这种情况编译器会报错，原因是<strong>在以值的方式传递参数的时候，会调用拷贝构造函数生成函数的实参，但是拷贝构造函数的参数是值的方式，将会继续调用拷贝构造函数，这样就会无限递归的调用下去，直到函数的栈溢出</strong>，所以值的方式传递参数是编译器绝对不允许的。</p><p>上面这句话可能一下子不太容易理解，没关系，下面我们详细的进行分析。</p><p>在进行值传递参数的时候，会调用拷贝构造函数对实参(假设实参为p)进行一次拷贝，假设新生成的对象叫做tmp，即<code>Person tmp = p</code>，tmp是一个新对象，根据上面的分析，我们知道在进行这个操作的时候，也会调用拷贝构造函数，但是拷贝构造函数的参数是值啊，值传递参数又会调用拷贝构造函数进行拷贝，生成新对象又会调用拷贝构造函数…，这样就会无限循环下去。</p><p>2.以指针的方式传递参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person* p)</span><br></pre></td></tr></table></figure><p>恩，这种方式的确不会报错，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A* test) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = test-&gt;a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(&amp;a)</span></span>;</span><br><span class="line">    b.<span class="built_in">printA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in constructor</span><br><span class="line">in copy constructor</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>确实是调用了拷贝构造函数，但是<code>A(A* test)</code>真的是拷贝构造函数吗？答案是否定的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(A* test) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = test-&gt;a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(&amp;a)</span></span>;</span><br><span class="line">    A c = a;</span><br><span class="line">    b.<span class="built_in">printA</span>();</span><br><span class="line">    c.<span class="built_in">printA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in constructor</span><br><span class="line">in copy constructor</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>发现<code>in copy constructor</code>只打印了一次，也就是说<code>A c = a;</code>并没有调用<code>A(A* test)</code>，那调用的拷贝构造函数是哪个呢？毫无疑问，是默认拷贝构造函数，默认拷贝构造函数还存在，说明<code>A(A* test)</code>并不是拷贝构造函数。</p><h3 id="4-总结">4.总结</h3><p>1.区分调用拷贝构造函数还是拷贝赋值运算符的依据是看是否生成了新对象，生成，拷贝构造函数，不生成，赋值运算符；<br>2.调用拷贝构造函数的三种情况：值传递，值方式返回局部对象，使用一个已有对象初始化一个新对象；<br>3.拷贝构造函数必须以引用的方式传递参数，因为值方式会造成栈区溢出，编译器不允许；指针方式根本不是拷贝构造函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍了拷贝构造函数和赋值运算符的区别，以及在什么时候调用拷贝构造函数、什么情况下调用赋值运算符；同时较为详细的说明了拷贝构造函数必须以引用的方式传递参数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="拷贝构造函数" scheme="http://example.com/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
    <category term="拷贝复制运算符" scheme="http://example.com/tags/%E6%8B%B7%E8%B4%9D%E5%A4%8D%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++11之delete</title>
    <link href="http://example.com/2021/04/12/C-11%E4%B9%8Bdeleate/"/>
    <id>http://example.com/2021/04/12/C-11%E4%B9%8Bdeleate/</id>
    <published>2021-04-12T14:56:47.000Z</published>
    <updated>2021-04-12T15:47:38.308Z</updated>
    
    <content type="html"><![CDATA[<p>引言：delete关键字可以禁用某些函数，或者不期望转换和操作符。</p><span id="more"></span><h3 id="1-背景">1.背景</h3><p>对于 C++ 的类，如果程序员没有为其定义特殊成员函数，那么在需要用到某个特殊成员函数的时候，编译器会隐式的自动生成一个默认的特殊成员函数，比如拷贝构造函数，或者拷贝赋值操作符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x1;</span><br><span class="line">    X x2 = x1; <span class="comment">// 正确，调用编译器隐式生成的默认拷贝构造函数</span></span><br><span class="line">    X x3;</span><br><span class="line">    x3 = x1; <span class="comment">// 正确，调用编译器隐式生成的默认拷贝赋值操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，程序员不需要自己手动编写拷贝构造函数以及拷贝赋值操作符，依靠编译器自动生成的默认拷贝构造函数以及拷贝赋值操作符就可以实现类对象的拷贝和赋值。这在某些情况下是非常方便省事的，但是在某些情况下，假设我们<strong>不允许发生类对象之间的拷贝和赋值</strong>，可是又无法阻止编译器隐式自动生成默认的拷贝构造函数以及拷贝赋值操作符，那这就成为一个问题了。</p><h3 id="2-delete的提出">2.delete的提出</h3><p>为了能够让程序员显式的禁用某个函数，C++11标准引入了一个新特性：delete函数。程序员只需在函数声明后加上<code>=delete</code>，就可将该函数禁用。例如，我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 delete函数，就可以禁止类 X 对象之间的拷贝和赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>();</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝构造函数为delete函数</span></span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为delete函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x1;</span><br><span class="line">    X x2=x1; <span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">    X x3;</span><br><span class="line">    x3=x1; <span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，虽然只显式的禁用了一个拷贝构造函数和一个拷贝赋值操作符，但是由于编译器检测到类 X 存在用户自定义的拷贝构造函数和拷贝赋值操作符的声明，所以不会再隐式的生成其它参数类型的拷贝构造函数或拷贝赋值操作符，也就相当于类 X 没有任何拷贝构造函数和拷贝赋值操作符，所以对象间的拷贝和赋值被完全禁止了。</p><h3 id="3-delete的用法及示例">3.delete的用法及示例</h3><p>delete函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换。在下面程序中，假设类 X 只支持参数为双精度浮点数double类型的转换构造函数，而不支持参数为整数int类型的转换构造函数，则可以将参数为int类型的转换构造函数声明为delete函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">double</span>);</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">x1</span><span class="params">(<span class="number">1.2</span>)</span></span>;</span><br><span class="line">    <span class="function">X <span class="title">x2</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// 错误，参数为整数int类型的转换构造函数被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数特性还可以用来禁用某些用户自定义的类的new操作符，从而避免在自由存储区创建类的对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X *pa = <span class="keyword">new</span> X; <span class="comment">// 错误，new操作符被禁用</span></span><br><span class="line">    X *pb = <span class="keyword">new</span> X[<span class="number">10</span>]; <span class="comment">// 错误，new[]操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须在函数第一次声明的时候将其声明为delete函数，否则编译器会报错。即对于类的成员函数而言，delete函数必须在类体里（inline）定义，而不能在类体外（out-of-line）定义。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>; <span class="comment">// 错误，delete函数必须在函数第一次声明处声明</span></span><br></pre></td></tr></table></figure><p>虽然 default函数特性规定了只有类的特殊成员函数才能被声明为default函数，但是delete函数特性并没有此限制。非类的成员函数，即普通函数也可以被声明为 delete函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">add</span>(a, b); <span class="comment">// 错误，函数add(int, int)被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，在上述程序中，虽然 add(int, int)函数被禁用了，但是禁用的仅是函数的定义，即该函数不能被调用。但是函数标示符add仍是有效的，在名字查找和函数重载解析时仍会查找到该函数标示符。如果编译器在解析重载函数时，解析结果为已经delete的函数，则会出现编译错误。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 错误，调用delete函数add(int, int)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.2</span>, <span class="number">1.3</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-总结">4.总结</h3><p>1.delete函数用于禁用某个函数；<br>2.delete必须在函数第一次声明的时候使用，对于类的成员函数，即只能在类体内使用，这点和default不同；<br>3.delete既可以用于类的特殊成员函数，也可用于普通函数；<br>4.delete可以用来禁用某些用户自定义的类的new操作符，从而避免在自由存储区创建类的对象;<br>5.delete可以通过参数禁用某种参数类型的函数，并不会禁用函数的标识符，所以不会影响函数重载；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：delete关键字可以禁用某些函数，或者不期望转换和操作符。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++11" scheme="http://example.com/tags/C-11/"/>
    
    <category term="delete关键字" scheme="http://example.com/tags/delete%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>C++11之default</title>
    <link href="http://example.com/2021/04/10/C-11%E4%B9%8Bdefault/"/>
    <id>http://example.com/2021/04/10/C-11%E4%B9%8Bdefault/</id>
    <published>2021-04-10T09:59:20.000Z</published>
    <updated>2021-04-12T15:11:09.531Z</updated>
    
    <content type="html"><![CDATA[<p>引言：对于default函数，编译器会自动生成函数体定义，从而获得更高的代码执行效率。同时说明了为什么基类的析构函数一定要显式定义成虚析构函数。</p><span id="more"></span><h3 id="1-背景">1.背景</h3><p>C++有4类特殊成员函数，分别是：默认构造函数，默认析构函数，拷贝构造函数以及拷贝赋值运算符，这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X x;</span><br></pre></td></tr></table></figure><p>在上述程序中，程序员并没有定义类 X 的默认构造函数，但是在创建类 X 的对象 x 的时候，又需要用到类 X 的默认构造函数，此时，编译器会隐式的为类 X 生成一个默认构造函数。该自动生成的默认构造函数没有参数，包含一个空的函数体，即<code>X::X() &#123;&#125;</code>。虽然自动生成的默认构造函数仅有一个空函数体，但是它仍可用来成功创建类 X 的对象 x，上述程序可以编译通过。</p><p>但是，如果程序员为类 X 显式的自定义了非默认构造函数，却没有定义默认构造函数的时候，将会出现编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;<span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure><p>编译出错的原因在于类 X 已经有了用户自定义的构造函数，所以编译器将不再会为它隐式的生成默认构造函数。如果需要用到默认构造函数来创建类的对象时，程序员必须自己显式的定义默认构造函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123;&#125;; <span class="comment">// 手动定义默认构造函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上述程序可以看出，原本期望编译器自动生成的默认构造函数需要程序员手动编写了，即程序员的工作量加大了。此外，手动编写的默认构造函数的代码执行效率比编译器自动生成的默认构造函数低。类的其它几类特殊成员函数也和默认构造函数一样，当存在用户自定义的特殊成员函数时，编译器将不会隐式的自动生成默认特殊成员函数，而需要程序员手动编写，加大了程序员的工作量。类似的，手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低。</p><h3 id="2-default的提出">2.default的提出</h3><p>为了解决上述两个问题：1. 减轻程序员的编程工作量；2. 获得编译器自动生成的默认特殊成员函数的高代码执行效率，C++11 标准引入了一个新特性：default函数。程序员只需在函数声明后加上<code>=default</code>，就可将该函数声明为 default函数，编译器将为显式声明的 default函数自动生成函数体。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>()= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x;</span><br></pre></td></tr></table></figure><p>在上述程序中，编译器会自动生成默认构造函数 <code>X::X() &#123;&#125;</code>，该函数可以比用户自己定义的默认构造函数获得更高的代码效率。</p><h3 id="3-default的用法及示例">3.default的用法及示例</h3><p>default仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="keyword">default</span>; <span class="comment">// 错误, 函数f()非类X的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span>) = <span class="keyword">default</span>; <span class="comment">// 错误, 构造函数X(int) 非X的特殊成员函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> = <span class="number">1</span>) = <span class="keyword">default</span>; <span class="comment">// 错误, 默认构造函数X(int=1)含有默认参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>default函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() = <span class="keyword">default</span>; <span class="comment">//inline default默认构造函数</span></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp;);</span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;);</span><br><span class="line">    ~<span class="built_in">X</span>() = <span class="keyword">default</span>; <span class="comment">//inline default析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>; <span class="comment">//out-of-line default拷贝构造函数</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//out-of-line default拷贝赋值操作符</span></span><br></pre></td></tr></table></figure><p>在 C++ 代码编译过程中，如果程序员没有为类 X 定义析构函数，但是在销毁类 X 对象的时候又需要调用类 X 的析构函数时，编译器会自动隐式的为该类生成一个析构函数。该自动生成的析构函数没有参数，包含一个空的函数体，即<code>X::~X() &#123;&#125;</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X* x = <span class="keyword">new</span> Y;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，程序员没有为基类 X 和派生类 Y 定义析构函数，当在主函数内 delete 基类指针 x 的时候，需要调用基类的析构函数。于是，编译器会隐式自动的为类 X 生成一个析构函数，从而可以成功的销毁 x 指向的派生类对象中的基类子对象（即 int 型成员变量 x）。</p><p>但是，这段代码存在<strong>内存泄露</strong>的问题，当利用 delete 语句删除指向派生类对象的指针 x时，<strong>系统调用的是基类的析构函数，而非派生类 Y 类的析构函数</strong>，因此，编译器无法析构派生类的 int 型成员变量 y。</p><p>因此，一般情况下我们需要将基类的析构函数定义为虚函数，当利用 delete 语句删除指向派生类对象的基类指针时，系统会调用相应的派生类的析构函数（实现多态性），从而避免内存泄露。但是编译器隐式自动生成的析构函数都是非虚函数，这就需要由程序员手动的为基类 X 定义虚析构函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123;&#125;; <span class="comment">// 手动定义虚析构函数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X* x = <span class="keyword">new</span> Y;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，由于程序员手动为基类 X 定义了虚析构函数，当利用 delete 语句删除指向派生类对象的基类指针 x 时，系统会调用相应的派生类 Y 的析构函数（由编译器隐式自动生成）以及基类 X 的析构函数，从而将派生类对象完整的销毁，可以避免内存泄露。</p><p>但是，在清单 8 中，程序员需要手动的编写基类的虚构函数的定义（哪怕函数体是空的），增加了程序员的编程工作量。更值得一提的是，<strong>手动定义的析构函数的代码执行效率要低于编译器自动生成的析构函数</strong>。</p><p>为了解决上述问题，我们可以将基类的虚析构函数声明为default函数，这样就可以显式的指定编译器为该函数自动生成函数体。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() = <span class="keyword">default</span>; <span class="comment">// 编译器自动生成default函数定义体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X* x = <span class="keyword">new</span> Y;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，编译器会自动生成虚析构函数<code>virtual X::~X() &#123;&#125;</code>，该函数比用户自己定义的虚析构函数具有更高的代码执行效率。</p><h3 id="4-总结">4.总结</h3><p>1.default只能用于类的特殊成员函数；<br>2.default解决了两个问题：一是减轻程序员编写函数定义的编程工作量，二是default定义的函数代码执行效率要高于手动编写；<br>3.default可以在类体内定义，也可在类体外定义；<br>4.基类的析构函数一定要显式地定义成虚析构函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：对于default函数，编译器会自动生成函数体定义，从而获得更高的代码执行效率。同时说明了为什么基类的析构函数一定要显式定义成虚析构函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++11" scheme="http://example.com/tags/C-11/"/>
    
    <category term="default关键字" scheme="http://example.com/tags/default%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    <category term="虚析构函数" scheme="http://example.com/tags/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
    <category term="代码执行效率" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
</feed>
