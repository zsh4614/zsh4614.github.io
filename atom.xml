<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到我的主页!</title>
  
  
  <link href="https://zsh4614.cn/atom.xml" rel="self"/>
  
  <link href="https://zsh4614.cn/"/>
  <updated>2022-03-13T14:57:48.457Z</updated>
  <id>https://zsh4614.cn/</id>
  
  <author>
    <name>zsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++智能指针weak_ptr</title>
    <link href="https://zsh4614.cn/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88weak-ptr/"/>
    <id>https://zsh4614.cn/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88weak-ptr/</id>
    <published>2022-03-10T02:58:03.000Z</published>
    <updated>2022-03-13T14:57:48.457Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍C++11的智能指针weak_ptr。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr<T>（ T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），<strong>只能和 shared_ptr 类型指针搭配使用</strong>。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如<strong>有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放</strong>等等。</p><p><strong>当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。</strong></p><p>weak_ptr&lt;T&gt; 模板类中<strong>没有重载 * 和 -&gt; 运算符</strong>，这也就意味着，weak_ptr 类型指针<strong>只能访问</strong>所指的堆内存，而无法修改它。</p><h3 id="创建">创建</h3><p>三种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="keyword">int</span>&gt; wp1;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp2</span> <span class="params">(wp1)</span></span>;  <span class="comment">//凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp3</span> <span class="params">(sp)</span></span>; <span class="comment">// weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化</span></span><br></pre></td></tr></table></figure><h3 id="成员方法">成员方法</h3><p><img src="https://s2.loli.net/2022/03/10/qoOWVLPHs7udBgy.png" alt="image.png"></p><h3 id="用法">用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sp2)</span></span>;</span><br><span class="line">    <span class="comment">//输出和 wp 同指向的 shared_ptr 类型指针的数量</span></span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//释放 sp2</span></span><br><span class="line">    sp2.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据</span></span><br><span class="line">    cout &lt;&lt; *(wp.<span class="built_in">lock</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">10</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍C++11的智能指针weak_ptr。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：工厂模式</title>
    <link href="https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-08T09:36:16.000Z</published>
    <updated>2022-03-13T14:57:48.457Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++工厂模式，从低级到高级的逐步严谨。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>工厂模式：这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>本文主要介绍五种工厂模式：简单工厂模式，工厂方法模式，抽象工厂模式，工厂模板模式，注册模板类+单例工厂模式，其设计思路以及兼容性、拓展性逐步递进。</p><h3 id="简单工厂模式">简单工厂模式</h3><p>简单工厂模式由工厂类，抽象产品类，具体产品类组成，简单工厂模式的工厂类中封装了创建具体产品对象的函数。以Shoes类为例进行说明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nike鞋子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeShoes</span> :</span> <span class="keyword">public</span> Shoes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Nike!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adidas鞋子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasShoes</span> :</span> <span class="keyword">public</span> Shoes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adidas!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoesFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">SHOESTYPE</span> &#123;</span></span><br><span class="line">        NIKE,</span><br><span class="line">        ADIDAS,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Shoes* <span class="title">createShoes</span><span class="params">(SHOESTYPE type)</span></span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> NIKE:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NikeShoes;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ADIDAS:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AdidasShoes;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ShoesFactory factory;</span><br><span class="line">    Shoes* pNikeShoes = factory.<span class="built_in">createShoes</span>(ShoesFactory::SHOESTYPE::NIKE);</span><br><span class="line">    pNikeShoes-&gt;<span class="built_in">show</span>();</span><br><span class="line">    Shoes* pAdidasShoes = factory.<span class="built_in">createShoes</span>(ShoesFactory::SHOESTYPE::ADIDAS);</span><br><span class="line">    pAdidasShoes-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">    <span class="keyword">delete</span> pAdidasShoes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种简单工厂模式的<strong>扩展性非常差，新增产品类的时候，需要去修改工厂类</strong>。</p><h3 id="工厂方法模式">工厂方法模式</h3><p>工厂方法模式是用多个工厂去生产多个产品，每个工厂只负责生产对应的产品。由抽象工厂类，具体工行类，抽象产品类，具体产品类组成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nike鞋子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeShoes</span> :</span> <span class="keyword">public</span> Shoes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Nike!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adidas鞋子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasShoes</span> :</span> <span class="keyword">public</span> Shoes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adidas!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoesFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes* <span class="title">createShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShoesFactory</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nike生产工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeProducer</span> :</span> <span class="keyword">public</span> ShoesFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes* <span class="title">createShoes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adidas生产工厂 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasProducer</span> :</span> <span class="keyword">public</span> ShoesFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes* <span class="title">createShoes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ShoesFactory* nikeProducer = <span class="keyword">new</span> NikeProducer;</span><br><span class="line">    Shoes* pNikeShoes = nikeProducer-&gt;createShoes;</span><br><span class="line">    pNikeShoes-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    ShoesFactory* adidasProducer = <span class="keyword">new</span> AdidasProducer;</span><br><span class="line">    Shoes* pAdidasShoes = adidasProducer-&gt;createShoes;</span><br><span class="line">    pAdidasShoes-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">    <span class="keyword">delete</span> pAdidasShoes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> nikeProducer;</span><br><span class="line">    <span class="keyword">delete</span> adidasProducer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法模式每新增一个产品，虽然不需要去改变已有的工厂类，但是需要新增新产品的具体工厂类，而且一个工厂只能生产一个产品。</p><h3 id="抽象工厂模式">抽象工厂模式</h3><p>抽象工厂模式解决了工厂方法模式只能生产一个产品的缺点，比如想要除了Shoes要生产，还有Clothes要生产</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clothes基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clothes</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shoes基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Nike Clothes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothes</span> :</span> <span class="keyword">public</span> Clothes&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NikeClothes!&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nike Shoes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeShoes</span> :</span> <span class="keyword">public</span> Shoes&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NikeShoes!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes* <span class="title">createShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Clothes* <span class="title">createClothes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nike工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeProducer</span> :</span> <span class="keyword">public</span> Factory &#123;</span><br><span class="line">    <span class="function">Shoes* <span class="title">createShoes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NikeShoes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Clothes* <span class="title">createClothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NikeClothes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>抽象工厂模式虽然一个工厂能生产多个产品，但是还是受到新增产品的限制， 拓展性依旧很差。需要一个封装性非常强的工厂类，在新增产品时，既不需要新增工厂类，也不需要对原有的工厂类进行修改。</p><h3 id="模板工厂模式">模板工厂模式</h3><p>抽象类只需要给出相应的接口，在具体工厂类中根据传入的模板参数实现具体生产</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeShoes</span> :</span> <span class="keyword">public</span> Shoes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NikeShoes!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasShoes</span> :</span> <span class="keyword">public</span> Shoes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AdidasShoes!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clothes</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothes</span> :</span> <span class="keyword">public</span> Clothes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NikeClothes!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasClothes</span> :</span> <span class="keyword">public</span> Clothes &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AdidasClothes!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象模板工厂类定义抽象产品类的生产接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span>&gt;</span></span><br><span class="line"><span class="function">class <span class="title">AbstractFacory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFacory</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProduct* <span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体模板工厂类实现抽象工厂类中的接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span>, <span class="keyword">class</span> <span class="title">ConcreteProduct</span>&gt;</span></span><br><span class="line"><span class="function">class <span class="title">ConcreteFactory</span><span class="params">()</span> : public AbstractFacory&lt;AbstractProduct&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct* <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteFactory&lt;Shoes, NikeShoes&gt; nikeFactory;</span><br><span class="line">    Shoes* pNikShoes = nikeFactory.<span class="built_in">createProduct</span>();</span><br><span class="line">    pNikeShoe-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pNikShoes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="产品注册模板类-单例工厂模式">产品注册模板类+单例工厂模式</h3><p>上面的模板工厂模式实现虽然在扩展性上有了极大提升，新增产品时不在需要对工厂类进行增加或者修改，但是缺少一个可以统一随时随地获取指定产品<strong>对象</strong>的类。可以把注册的对象用一个map保存起来，通过键值对的方式可以轻松获取该对象实例。一种实现方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品注册抽象类，提供创建产品对象的接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ProductType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProductRegister</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductType *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">IProductRegister</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IProductRegister</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">IProductRegister</span>(<span class="keyword">const</span> IProductRegister&amp;);</span><br><span class="line">    IProductRegister&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> IProductRegister&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模板类，有一个map，用于保存注册和查询获取产品对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ProductType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 工厂是唯一的，设计为单例（非线程安全）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ProductFactory&lt;ProductType&gt; &amp;<span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ProductFactory&lt;ProductType&gt; instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产品注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterProduct</span><span class="params">(IProductRegister&lt;ProductType&gt; *<span class="keyword">register</span>, std::string name)</span></span>&#123;</span><br><span class="line">        m_ProductRegistry[name] = <span class="keyword">register</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据名字，获取具体的产品对象</span></span><br><span class="line">    <span class="function">ProductType* <span class="title">GetProduct</span><span class="params">(std::string name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_ProductRegistry.<span class="built_in">find</span>(name)!=m_ProductRegistry.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> m_ProductRegistry[name]-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 未注册产品时，报错未找到</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No found &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止外部构造和虚构</span></span><br><span class="line">   <span class="built_in">ProductFactory</span>() &#123;&#125;</span><br><span class="line">   ~<span class="built_in">ProductFactory</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 禁止外部拷贝和赋值操作</span></span><br><span class="line">   <span class="built_in">ProductFactory</span>(<span class="keyword">const</span> ProductFactory &amp;);</span><br><span class="line">   <span class="keyword">const</span> ProductFactory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ProductFactory &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存注册过的产品，key:产品名字 , value:产品类型</span></span><br><span class="line">    std::map&lt;std::string, IProductRegister&lt;ProductType&gt;*&gt; m_ProductRegistry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品注册模板类，用于创建具体产品和向工厂里注册产品</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ProductType</span>, <span class="keyword">class</span> <span class="title">ProductImpl</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductRegistrar</span> :</span> <span class="keyword">public</span> IProductRegistrar&lt;ProductType&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ProductRegistrar</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        ProductFactory&lt;ProductType&gt;::Instance.<span class="built_in">RegisterProduct</span>(<span class="keyword">this</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建具体产品对象指针</span></span><br><span class="line">    <span class="function">ProductType *<span class="title">CreateProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductImpl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    ProductRegistrar&lt;Shoes, NiKeShoes&gt; nikeShoes(&quot;nike&quot;);</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    Shoes* pNikeShoes = ProductFactory&lt;Shoes&gt;::Instance.<span class="built_in">GetProduct</span>(<span class="string">&quot;nike&quot;</span>);</span><br><span class="line">    pNikeShoes-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++工厂模式，从低级到高级的逐步严谨。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式（C++）" scheme="https://zsh4614.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    
    
    <category term="工厂模式" scheme="https://zsh4614.cn/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="注册" scheme="https://zsh4614.cn/tags/%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百零五题：从前序与中序遍历序列构造二叉树</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%94%E9%A2%98%EF%BC%9A%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%94%E9%A2%98%EF%BC%9A%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-02-17T16:05:01.000Z</published>
    <updated>2022-02-17T16:48:55.494Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百零五题，给定一个二叉树的前序遍历和中序遍历结果，构造出二叉树，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/02/18/K7sFBvzndqh1AJ5.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>1 &lt;= preorder.length &lt;= 3000</li><li>inorder.length == preorder.length</li><li>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</li><li>preorder 和 inorder 均 无重复 元素</li><li>inorder 均出现在 preorder</li><li>preorder 保证 为二叉树的前序遍历序列</li><li>inorder 保证 为二叉树的中序遍历序列</li></ul><h3 id="分析">分析</h3><p>对于任意一颗树而言，前序遍历的形式总是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</span><br></pre></td></tr></table></figure><p>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</span><br></pre></td></tr></table></figure><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)O(1) 的时间对根节点进行定位了。</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTHelper</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; preorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> pre_start_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> in_start_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        node-&gt;val = preorder[pre_start_idx];</span><br><span class="line">        <span class="comment">// 左子树存在</span></span><br><span class="line">        <span class="keyword">int</span> left_size = hashmap[node-&gt;val] - in_start_idx;</span><br><span class="line">        <span class="keyword">if</span> (left_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">buildTHelper</span>(preorder,</span><br><span class="line">                                         pre_start_idx + <span class="number">1</span>,</span><br><span class="line">                                         inorder,</span><br><span class="line">                                         in_start_idx,</span><br><span class="line">                                         left_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右子树存在</span></span><br><span class="line">        <span class="keyword">int</span> right_size = size - <span class="number">1</span> - left_size;</span><br><span class="line">        <span class="keyword">if</span> (right_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">buildTHelper</span>(preorder,</span><br><span class="line">                                          pre_start_idx + <span class="number">1</span> + left_size,</span><br><span class="line">                                          inorder,</span><br><span class="line">                                          in_start_idx + <span class="number">1</span> + left_size,</span><br><span class="line">                                          right_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">                                  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            hashmap[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTHelper</span>(preorder,</span><br><span class="line">                               <span class="number">0</span>,</span><br><span class="line">                               inorder,</span><br><span class="line">                               <span class="number">0</span>,</span><br><span class="line">                               inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><p>本题还有迭代实现方法，比较巧妙，有兴趣可以看看。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百零五题，给定一个二叉树的前序遍历和中序遍历结果，构造出二叉树，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉树遍历" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第九十六题：不同的二叉搜索树</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AD%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AD%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2022-02-14T13:35:49.000Z</published>
    <updated>2022-02-14T14:20:58.549Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第九十六题，不同的二叉搜索树数量，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/02/14/WLQ716EtF5zqYTN.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= n &lt;= 19</li></ul><h3 id="分析">分析</h3><p>这道题首先要搞清楚二叉搜索树的定义，二叉搜索树的左儿子一定比根结点小，右儿子一定比根结点大，而且所有子树也一定是二叉搜索树。这道题其实和结点的值无关，只与大小关系有关，我们以从1到n的结点分别做为根结点，那么每种情况就是比根结点小的结点都在左子树上，大的都在右子树上，而子树的情况，也是这样，当以i为根结点时，那么左子树的情况就是G(i-1)，右子树的情况就是G(n - 1 - i)，所以G(i - 1) * G(n - 1 - i)就是以i为根结点的所有情况数量，以其他结点为根结点时也是类似，所以加在一起有如下递推关系式：</p><p><img src="https://s2.loli.net/2022/02/14/QIatenpuVd1J5Ns.png" alt="image.png"></p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res += <span class="built_in">numTrees</span>(i) * <span class="built_in">numTrees</span>(n - <span class="number">1</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><p>其实满足上述递推关系式的数叫做卡塔兰数，可以证明，卡塔兰数的递推关系式如下：</p><p><img src="https://s2.loli.net/2022/02/14/mafL5cOnVMuzqBH.png" alt="6F9AC23A-F832-4FC7-9E9A-767437F6FACD.png"></p><p>推导<a href="https://blog.csdn.net/Sherry_Yue/article/details/88364746">如下</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第九十六题，不同的二叉搜索树数量，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="动态规划" scheme="https://zsh4614.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百零四题：二叉树的最大深度</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-02-09T11:01:48.000Z</published>
    <updated>2022-02-14T13:33:14.993Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode第一百零一题：对称二叉树</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-02-09T10:23:54.000Z</published>
    <updated>2022-02-14T13:33:14.993Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一百零一题，判断一颗二叉树是不是对称二叉树，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/02/09/PZ82L4cjJNe5vqE.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/02/09/CW9zMkq8h3xZGYD.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>树中节点数目在范围 <code>[1, 1000]</code> 内</p></li><li><p><code>-100 &lt;= Node.val &lt;= 100</code></p></li></ul><h3 id="分析">分析</h3><p>这道题比较容易想到的一个思路就是递归，判断两个结点，左右儿子结点是否分别相等，这样递归下去；二叉树将递归改成迭代，首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><h3 id="实现">实现</h3><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* lhs, TreeNode* rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs &amp;&amp; !rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!lhs || !rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lhs-&gt;val == rhs-&gt;val &amp;&amp; <span class="built_in">check</span>(lhs-&gt;left, rhs-&gt;right) &amp;&amp; <span class="built_in">check</span>(lhs-&gt;right, rhs-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p><strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* lhs, TreeNode* rhs)</span> </span>&#123;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(lhs);</span><br><span class="line">    queue.<span class="built_in">push</span>(rhs);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> l = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">auto</span> r = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> ((!l || !r) || l-&gt;val != r-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        queue.<span class="built_in">push</span>(l-&gt;left);</span><br><span class="line">        queue.<span class="built_in">push</span>(r-&gt;right);</span><br><span class="line">        queue.<span class="built_in">push</span>(l-&gt;right);</span><br><span class="line">        queue.<span class="built_in">push</span>(r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一百零一题，判断一颗二叉树是不是对称二叉树，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="队列" scheme="https://zsh4614.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>PaperReading之数据对DL的影响</title>
    <link href="https://zsh4614.cn/PaperReading%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AF%B9DL%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>https://zsh4614.cn/PaperReading%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AF%B9DL%E7%9A%84%E5%BD%B1%E5%93%8D/</id>
    <published>2022-02-07T02:08:03.000Z</published>
    <updated>2022-02-14T13:33:14.994Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍ICCV2017论文《Revisiting Unreasonable Effectiveness of Data in Deep Learning Era》。</p><span id="more"></span><h3 id="综述">综述</h3><p>这篇论文主要介绍了作者在数据集大小对深度学习性能的影响，得出了一些结论。</p><h3 id="结论">结论</h3><p>结论一：增大数据集有助于提升表征学习的性能，也就是类似于CNN这种自动提取特征的学习受益于数据集的增大，而且数据集的规模可以战胜标签噪声，作者在JFT-300数据集上的实验证明了这一点，虽然数据集的标签中仍然有20%的噪声，但是增大数据集依然获得了预想中的性能提升。</p><p>结论二：任务表现与<strong>数据量级</strong>呈线性关系，即与数据量呈对数关系，对于JFT-300这么大的数据量，也没有出现平顶效应。</p><p>结论三：模型容量也很重要，在大规模数据量下，模型容量越大，也就是层数越多，收益越大。</p><p>结论四：数据量增加会带来更好的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍ICCV2017论文《Revisiting Unreasonable Effectiveness of Data in Deep Learning Era》。&lt;/p&gt;</summary>
    
    
    
    <category term="PaperReading" scheme="https://zsh4614.cn/categories/PaperReading/"/>
    
    
    <category term="data" scheme="https://zsh4614.cn/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>PaperReading之Vision Transformer(ViT)</title>
    <link href="https://zsh4614.cn/PaperReading-Vision-Transformer-ViT/"/>
    <id>https://zsh4614.cn/PaperReading-Vision-Transformer-ViT/</id>
    <published>2022-01-30T03:44:55.000Z</published>
    <updated>2022-02-14T13:33:14.993Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍ICLR2021论文《AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE》。</p><span id="more"></span><h3 id="概述">概述</h3><p>这篇文章，也就是大名鼎鼎的ViT，是把在NLP领域中炙手可热的transformer引入CV领域的开篇之作，也是经典的挖坑之作，值得精读。</p><h3 id="综述">综述</h3><p>作者开篇介绍了CNN在视觉领域的统治地位，启发于transformer在NLP领域的卓越表现，有人将自注意力机制嵌入CNN中，也有人用自注意力完全取代卷积，但是这些都经过了个性化的修改，目前还没有对应的加速算子。作者自己完全把transformer搬过来，不作任何修改，而是修改输入，他们把图像分成一个一个的patch平铺开，然后经过一个linear embedding，这样来模仿一个token，作为transformer的输入，并用监督方式训练了图像分类任务。</p><p>作者在小数据集上训练效果较差，他们认为主要是transformer没有了CNN的归纳偏置：局部相关性和平移等变性。这里的归纳偏置（inductive biases）其实就是人类的先验，在CNN的设计中很多地方体现了这种先验，比如卷积核，就是认为图像具有局部性，离得越近的像素相关性越强。transformer没有利用这种性质，所以在小数据集上学习不够充分，所以效果不好。</p><p>最后在大数据集ImageNet-21k和JFT-300M上预训练之后，然后在许多数据集上finetune都取得了超越CNN的效果。</p><h3 id="相关工作">相关工作</h3><p>先介绍了transformer在NLP领域的成果，GPT，BERT等。但是在CV领域自注意力复杂度与图像尺寸的平方成正比，计算量非常大，之前有人采用了只在局部进行自注意力的方法，也有采用稀疏自注意力的方法，也有在一个block内部采用自注意力的方法，虽然效果不错，但是这些方法的工程实现非常复杂，而且硬件加速很不友好。然后介绍了一篇与自己的工作非常相似的文章，但是那篇文章只是在尺寸较小的图像上进行了实验，不适用大尺寸图像，而且作者对预训练进行了更加深入的论证。</p><h3 id="方法">方法</h3><p>作者说他们的方法基本上没有对原始的transformer进行改动，可以拿过来开箱即用。</p><p><img src="https://s2.loli.net/2022/01/30/Rz271Qcp4aEMfBT.png" alt="image.png"></p><p>这张图画的非常好，可以从这张图清晰的看出作者的整个设计思路。先将图像分成一个个patch，这样每个patch的通道数量就是PxPx3，这里的P是每个patch的边长，然后把这个patch经过一个linear embedding层也就是一个全连接层，这样通道数量就变成了D。经过上述操作之后，每个输入就变成了一个1D的token，和NLP中的输入类似。</p><p>参照BERT的做法，额外增加了一个可学习的类别token，用来作最终的分类，因为transformer的自注意力是全局的，所以这个类别token具有全局信息，这样是合理的，消融实验证明采用全局平均池化的方式代替这个额外的类别token效果也是差不多的，但是还是那一点，为了保持一致。</p><p>因为transformer不想卷积一样具有位置信息，所以在输入上额外增加了一个位置编码，这里作者采用的是一个1D的位置编码，消融实验证明用2D位置编码效果并没有什么提升。</p><p>transformer编码器采用的是多头自注意力+MLP，而且每个块之前都用了LayerNorm，同时采用了残差连接的方式，MLP采用的是GELU激活函数。</p><p>在这里，作者又详细说明了他们所设计的网络结构并没有太多图像相关的归纳偏置，只有MLP是局部和平移等变的，像自注意力是全局的，而且每个patch被平铺开，并没有携带2D信息，所以这些patch的空间相关性需要从头学习。</p><p>基于上述问题，作者给出了一种变体实现方法，就是不把原始图像打成patch，而是用一个普通的CNN，最后得到的特征图和处理成patch是一样大小的，然后在经过一个linear embedding丢给transformer，后面其他操作是一样的，这样就携带了空间信息。</p><p>最后作者提到预训练时在更大的图像上效果会更好，保持patch尺寸不变，这样patch数量就会增加，之前的位置编码可能会没用，这里作者采用的是直接插值的方式，但是这其实是一种临时的解决策略，因为当尺寸变得很大时，这种直接插值的方式会掉点。这里的分辨率调整和抽图像块是ViT唯一使用到的2D信息的归纳偏置。</p><h3 id="实验">实验</h3><p>作者在三个数据上进行了预训练：分别是ImageNet-1K，ImageNet-221K和JFT，数量分别是130万，1400万和3亿，并且在许多流行的数据集上进行了评测。他们的模型一共有三种变体：Base，Large和Huge，主要是层数，D，MLP尺寸，多头自注意力的头数不同。然后从表现和训练成本进行了对比说明，表现效果略好，但是训练相较于其他的要快不少。</p><p><img src="https://s2.loli.net/2022/01/30/zl42HWZNvSYnj6b.png" alt="image.png"></p><p>这张图可以说是这篇文章的精髓了，当在较小的数据集上训练时，transformer的效果明显不如CNN，当在数据量适中的数据集上训练时，效果基本上就和CNN持平了，当在更大的数据集上训练时，效果就会优于CNN，而且没有收敛的迹象。</p><p>之后进行了可视化分析，linear embedding类似与CNN，提取到的都是类似于Gabor滤波器提取到的特征，比如颜色纹理等，位置编码用1D位置编码，却已经学到了2D的特征，这也就解释了为什么用1D就够了。</p><p><img src="https://s2.loli.net/2022/01/30/9etDSmUHnabWCuV.png" alt="image.png"></p><p>最后，作者着重说明了自监督训练，这也是transformer能这么火的原因，作者采用masked patch方法进行自监督，效果并没有达到预期。</p><h3 id="结论">结论</h3><p>作者对自己的工作作了总结，并指明了几个可以进一步研究的方向，比如下游任务如检测分割等，比如自监督预训练，又比如架构和目标函数等等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍ICLR2021论文《AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT SCALE》。&lt;/p&gt;</summary>
    
    
    
    <category term="PaperReading" scheme="https://zsh4614.cn/categories/PaperReading/"/>
    
    
    <category term="transformer" scheme="https://zsh4614.cn/tags/transformer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百四十四题：二叉树的前序遍历</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-01-29T15:11:23.000Z</published>
    <updated>2022-01-29T15:19:49.980Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百四十四题，对二叉树进行前序遍历，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你二叉树的根节点 root ，返回它节点值的前序遍历。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/29/3uCdQJNIDKjmpqR.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例4</strong></p><p><img src="https://s2.loli.net/2022/01/29/26xpMiUJCXz8jHa.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例5</strong></p><p><img src="https://s2.loli.net/2022/01/29/h4D5web1dx8ozZC.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 [0, 100] 内</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><h3 id="分析">分析</h3><p>本题可以用迭代和递归方法解决，和中序遍历类似。</p><h3 id="实现">实现</h3><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*&amp; root)&gt; func = [&amp;](TreeNode*&amp; root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">func</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">func</span>(root-&gt;right);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func</span>(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">**迭代**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="疑问">疑问</h3><p>为什么那个匿名函数的参数写成const不行？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百四十四题，对二叉树进行前序遍历，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉树遍历" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第九十四题：二叉树的中序遍历</title>
    <link href="https://zsh4614.cn/Leetcode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://zsh4614.cn/Leetcode%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-01-29T13:48:59.000Z</published>
    <updated>2022-01-29T14:27:31.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第九十四题，对二叉树进行中序遍历，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给定一个二叉树的根节点 root ，返回它的中序遍历。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/29/Eevz7hcCw6OlT2L.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例4</strong></p><p><img src="https://s2.loli.net/2022/01/29/qLzo6GYlsIHgOwE.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例5</strong></p><p><img src="https://s2.loli.net/2022/01/29/TFpeRnoCJvZEOH2.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 [0, 100] 内</li><li>-100 &lt;= Node.val &lt;= 100</li></ul><h3 id="分析">分析</h3><p>中序遍历先访问左儿子，最后访问右儿子，对于子树也是如此。递归方法很容易想到，代码也很简单；迭代的话就是自己维护一个stack，先将根结点入栈，然后将左儿子入栈，再将左儿子的左儿子入栈，如此，直到没有左儿子，然后将栈顶结点出栈，将其值加入结果，然后对其右儿子执行上述操作，直到栈为空且所有结点都遍历过。</p><h3 id="代码">代码</h3><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">inorder</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            root = stack.<span class="built_in">top</span>()</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><p>以上两种方法时间复杂度和空间复杂度都是O(n)，还有一种空间复杂度为O(1)的方法，Morris方法，之后再讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第九十四题，对二叉树进行中序遍历，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="二叉树" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉树遍历" scheme="https://zsh4614.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>C++11之constexpr和const的区别</title>
    <link href="https://zsh4614.cn/C-11%E4%B9%8Bconstexpr%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://zsh4614.cn/C-11%E4%B9%8Bconstexpr%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-26T15:12:06.000Z</published>
    <updated>2022-01-26T15:22:42.493Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍C++11的新关键字constexpr和const的区别。</p><span id="more"></span><h3 id="背景">背景</h3><p>我们知道，constexpr 是 C++ 11 标准新添加的关键字，在此之前（C++ 98/03标准）只有 const 关键字，其在实际使用中经常会表现出两种不同的语义。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误，x是只读的变量</span></span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">dis_1</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">dis_2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，dis_1() 和 dis_2() 函数中都包含一个 const int x，但 dis_1() 函数中的 x 无法完成初始化 array 容器的任务，而 dis_2() 函数中的 x 却可以。</p><p>这是因为，dis_1() 函数中的“const int x”只是想强调 x 是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器；而 dis_2() 函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5 的常量，所以可以用来初始化 array 容器。</p><h3 id="区别">区别</h3><p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即<strong>凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</strong></p><p>有读者可能会问，“只读”不就意味着其不能被修改吗？答案是否定的，“只读”和“不允许被修改”之间并没有必然的联系，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; con_b = a;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>可以看到，程序中用 const 修饰了 con_b 变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p><p>在大部分实际场景中，const 和 constexpr 是可以混用的，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>它们是完全等价的，都可以在程序的编译阶段计算出结果。但在某些场景中，必须明确使用 constexpr，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">sqr1</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">sqr2</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr1(10)&gt; mylist1;<span class="comment">//可以，因为sqr1时constexpr函数</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr2(10)&gt; mylist1;<span class="comment">//不可以，因为sqr2不是constexpr函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，因为 sqr2() 函数的返回值仅有 const 修饰，而没有用更明确的 constexpr 修饰，导致其无法用于初始化 array 容器（只有常量才能初始化 array 容器）。</p><p>总的来说在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。</p><blockquote><p>转载自：<a href="http://c.biancheng.net/view/7807.html">http://c.biancheng.net/view/7807.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍C++11的新关键字constexpr和const的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="const" scheme="https://zsh4614.cn/tags/const/"/>
    
    <category term="constexpr" scheme="https://zsh4614.cn/tags/constexpr/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百四十六题：LRU缓存</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%E9%A2%98%EF%BC%9ALRU%E7%BC%93%E5%AD%98/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E5%85%AD%E9%A2%98%EF%BC%9ALRU%E7%BC%93%E5%AD%98/</id>
    <published>2022-01-24T15:24:38.000Z</published>
    <updated>2022-01-24T15:47:05.583Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百四十六题，设计一个LRU缓存，并给出c++实现</p><span id="more"></span><h3 id="题目">题目</h3><p>请你设计并实现一个满足<code>LRU (最近最少使用) 缓存</code>约束的数据结构。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li><li>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</li></ul><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 10000</li><li>0 &lt;= value &lt;= 105</li><li>最多调用 2 * 105 次 get 和 put</li></ul><h3 id="分析">分析</h3><p>LRU缓存用哈希表+双向链表实现，双向链表一般都会用到虚拟的头结点和尾结点，用来防止处理边界，在c++中，unordered_map是用哈希表实现的，list是用双向链表实现的，所以如果不用自己实现底层的话，直接用这两个容器就行，双向链表的实现比较简单，而哈希映射的实现就复杂了，所以这里只给出双向链表自己实现的写法。</p><h3 id="实现">实现</h3><p><strong>双向链表+哈希</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoubleLinkedListNode</span>() : <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DoubleLinkedListNode</span>(<span class="keyword">int</span> key_, <span class="keyword">int</span> val_) : <span class="built_in">key</span>(key_), <span class="built_in">val</span>(val_), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DoubleLinkedListNode</span>(<span class="keyword">int</span> key_, <span class="keyword">int</span> val_, DoubleLinkedListNode* pre_, DoubleLinkedListNode* next_) : <span class="built_in">key</span>(key_), <span class="built_in">val</span>(val_), <span class="built_in">pre</span>(pre_), <span class="built_in">next</span>(next_) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    DoubleLinkedListNode* pre;</span><br><span class="line">    DoubleLinkedListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">m_capacity</span>(capacity), <span class="built_in">m_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DoubleLinkedListNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DoubleLinkedListNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashmap.<span class="built_in">find</span>(key) == hashmap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将查找到的结点放到第一个位置</span></span><br><span class="line">            hashmap[key]-&gt;pre-&gt;next = hashmap[key]-&gt;next;</span><br><span class="line">            hashmap[key]-&gt;next-&gt;pre = hashmap[key]-&gt;pre;</span><br><span class="line">            hashmap[key]-&gt;pre = head;</span><br><span class="line">            hashmap[key]-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;pre = hashmap[key];</span><br><span class="line">            head-&gt;next = hashmap[key];</span><br><span class="line">            <span class="keyword">return</span> hashmap[key]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashmap.<span class="built_in">find</span>(key) == hashmap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 不存在，则添加到双链表的第一个位置</span></span><br><span class="line">            hashmap[key] = <span class="keyword">new</span> <span class="built_in">DoubleLinkedListNode</span>(key, value);</span><br><span class="line">            hashmap[key]-&gt;pre = head;</span><br><span class="line">            hashmap[key]-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;pre = hashmap[key];</span><br><span class="line">            head-&gt;next = hashmap[key];</span><br><span class="line">            <span class="comment">// 如果超过长度，则删除最后一个节点，同时删除哈希表中的值</span></span><br><span class="line">            <span class="keyword">if</span> ((++m_size) &gt; m_capacity) &#123;</span><br><span class="line">                DoubleLinkedListNode* last = tail-&gt;pre;</span><br><span class="line">                tail-&gt;pre-&gt;pre-&gt;next = tail;</span><br><span class="line">                tail-&gt;pre = tail-&gt;pre-&gt;pre;</span><br><span class="line">                m_size--;</span><br><span class="line">                hashmap.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在, 更新值，并移动到第一个位置</span></span><br><span class="line">            hashmap[key]-&gt;val = value;</span><br><span class="line">            hashmap[key]-&gt;pre-&gt;next = hashmap[key]-&gt;next;</span><br><span class="line">            hashmap[key]-&gt;next-&gt;pre = hashmap[key]-&gt;pre;</span><br><span class="line">            hashmap[key]-&gt;pre = head;</span><br><span class="line">            hashmap[key]-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;pre = hashmap[key];</span><br><span class="line">            head-&gt;next = hashmap[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, DoubleLinkedListNode*&gt; hashmap;</span><br><span class="line">    DoubleLinkedListNode* head;</span><br><span class="line">    DoubleLinkedListNode* tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：删除某个结点的时候，一定要同步删除哈希表中对应的元素，而这个元素，也就是键，必须通过双向链表中要删除的结点获取，所以双向链表中不能只存储值。</p><p><strong>list+unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">cap</span>(capacity) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(key) == map.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> key_value = *map[key];</span><br><span class="line">        cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        cache.<span class="built_in">push_front</span>(key_value);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> key_value.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(key) == map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">size</span>() == cap) &#123;</span><br><span class="line">                map.<span class="built_in">erase</span>(cache.<span class="built_in">back</span>().first);</span><br><span class="line">                cache.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：list容器有一个特别的地方就是它的size()接口的时间复杂度并不是像其他容器一样复杂度为1，而是O(n)，n是list的长度，这样设计有其他的考量，具体可以参考<a href="https://blog.csdn.net/zhwenx3/article/details/89163574">这里</a>。</p><h3 id="拓展">拓展</h3><p>缓存是一种广义的概念，在计算机存储层次结构中，低一层的存储器都可以看做是高一层的缓存。比如Cache是内存的缓存，内存是硬盘的缓存，硬盘是网络的缓存等等。</p><p>缓存可以有效地解决存储器性能与容量的这对矛盾，但绝非看上去那么简单。如果缓存算法设计不当，非但不能提高访问速度，反而会使系统变得更慢。</p><p>从本质上来说，缓存之所以有效是因为程序和数据的局部性（locality）。程序会按固定的顺序执行，数据会存放在连续的内存空间并反复读写。这些特点使得我们可以缓存那些经常用到的数据，从而提高读写速度。</p><p>缓存的大小是固定的，它应该只保存最常被访问的那些数据。然而未来不可预知，我们只能从过去的访问序列做预测，于是就有了各种各样的缓存替换策略。</p><p>我们以内存访问为例解释缓存的工作原理。假设缓存的大小固定，初始状态为空。每发生一次读内存操作，首先查找待读取的数据是否存在于缓存中，若是，则缓存命中，返回数据；若否，则缓存未命中，从内存中读取数据，并把该数据添加到缓存中。向缓存添加数据时，如果缓存已满，则需要删除访问时间最早的那条数据，这种更新缓存的方法就叫做LRU。</p><p>实现LRU时，我们需要关注它的读性能和写性能，理想的LRU应该可以在O(1)的时间内读取一条数据或更新一条数据，也就是说读写的时间复杂度都是O(1)。</p><p>此时很容易想到使用HashMap，根据数据的键访问数据可以达到O(1)的速度。但是更新缓存的速度却无法达到O(1)，因为需要确定哪一条数据的访问时间最早，这需要遍历所有缓存才能找到。</p><p>因此，我们需要一种既按访问时间排序，又能在常数时间内随机访问的数据结构。</p><p>这可以通过HashMap+双向链表实现。HashMap保证通过key访问数据的时间为O(1)，双向链表则按照访问时间的顺序依次穿过每个数据。之所以选择双向链表而不是单链表，是为了可以从中间任意结点修改链表结构，而不必从头结点开始遍历。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百四十六题，设计一个LRU缓存，并给出c++实现&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双向链表" scheme="https://zsh4614.cn/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
    <category term="list" scheme="https://zsh4614.cn/tags/list/"/>
    
    <category term="缓存" scheme="https://zsh4614.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第十九题：删除链表的倒数第 N 个结点</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E5%8D%81%E4%B9%9D%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E5%8D%81%E4%B9%9D%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2022-01-22T16:42:00.000Z</published>
    <updated>2022-01-23T17:17:40.696Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第十九题，删除链表的倒数第N个结点，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/24/Nyuo2cVLTt3iQ8z.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 sz</li><li>1 &lt;= sz &lt;= 30</li><li>0 &lt;= Node.val &lt;= 100</li><li>1 &lt;= n &lt;= sz</li></ul><h3 id="分析">分析</h3><p>因为只有遍历才能求链表的长度，所以最常想到的方法就是遍历链表求长度l，删除倒数第n个结点，也就知道了删除正数第几个结点，这种方法效率较低，这里就不实现了；第二种方法就是用双指针，让第一个指针始终领先第二个指针n个结点，这样当第一个结点在链表尾结点上时，第二个结点正好在倒数第n个结点的前一个结点；第三种方法是使用stack实现。</p><h3 id="实现">实现</h3><p><strong>双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">      ListNode* first = head;</span><br><span class="line">      ListNode* second = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    ListNode* ans = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：用到node-&gt;next  一定要保证node不为空结点，避免为空的一个好方法是使用哨兵结点。</p><p><strong>stack</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* work = head;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(dummy);</span><br><span class="line">    <span class="keyword">while</span> (work) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(work);</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="built_in">top</span>()-&gt;next = stack.<span class="built_in">top</span>()-&gt;next-&gt;next;</span><br><span class="line">    ListNode* res = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第十九题，删除链表的倒数第N个结点，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="stack" scheme="https://zsh4614.cn/tags/stack/"/>
    
    <category term="双指针" scheme="https://zsh4614.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第二百三十四题：回文链表</title>
    <link href="https://zsh4614.cn/Leetcode%E7%AC%AC%E4%BA%8C%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/Leetcode%E7%AC%AC%E4%BA%8C%E7%99%BE%E4%B8%89%E5%8D%81%E5%9B%9B%E9%A2%98%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-21T15:53:46.000Z</published>
    <updated>2022-01-21T16:13:24.418Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第二百三十四题，判断一个链表是否是回文链表，并给出c++实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/21/ZG1w5Au2j8v9KsT.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/21/DcblhSoI8WV9QMg.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>链表中节点数目在范围[1, 10^5] 内</li><li>0 &lt;= Node.val &lt;= 9</li></ul><h3 id="分析">分析</h3><p>常规思路是用一个容器把结点全部按顺序存起来，然后遍历链表一一比对，但是消耗空间比较大，另一种容易想到的思路是反转链表，然后遍历判断每个结点是否相等，但是反转之后原链表就丢失了，所以不能这么做；正确思路应该是反转链表的后半部分，和前半部分的结点一一比对，如何找到中间的结点呢？用快慢指针！</p><h3 id="实现">实现</h3><p><strong>容器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">uint8_t</span>&gt; vec;</span><br><span class="line">    ListNode* work = head;</span><br><span class="line">    <span class="keyword">while</span>(work) &#123;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(work-&gt;val);</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> itr = vec.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (itr != vec.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        itr--;</span><br><span class="line">        <span class="keyword">if</span> ((*itr) != head-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p><strong>双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!(head-&gt;next)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> reverse = [](ListNode* head)&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* rev = <span class="built_in">reverse</span>(slow);</span><br><span class="line">            <span class="keyword">while</span> (rev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rev-&gt;val != head-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rev = rev-&gt;next;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* rev = <span class="built_in">reverse</span>(slow-&gt;next);</span><br><span class="line">            <span class="keyword">while</span> (rev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rev-&gt;val != head-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rev = rev-&gt;next;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第二百三十四题，判断一个链表是否是回文链表，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://zsh4614.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++中的栈对象和堆对象</title>
    <link href="https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A0%86%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A0%86%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-01-21T07:18:26.000Z</published>
    <updated>2022-01-21T16:10:33.766Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍两种建立类对象的方式，在栈上和堆上建立，以及对它们的理解。</p><span id="more"></span><h3 id="背景">背景</h3><p>在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。</p><ul><li><p><strong>静态建立类对象：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。</strong></p></li><li><p><strong>动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。</strong></p></li></ul><h3 id="区别">区别</h3><p>初始化两种方法：</p><p>第一种初始化方法：ClassName object(初始化参数)；</p><p>第二种初始化方法：ClassName* object=new ClassName(初始化参数);</p><p>两种初始化方法的区别：</p><p>第一种初始化方法：在stack栈里面分配空间，自动释放。</p><p>第二种初始化方法：在heap堆里面分配空间，要手动释放。</p><h3 id="选择">选择</h3><p>栈对象的优势是在适当的时候自动生成，又在适当的时候<strong>自动销毁</strong>，不需要程序员操心；而且<strong>栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用 operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了</strong>。但是要注意的是，通常<strong>栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配</strong>。特别要注意<strong>递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误</strong>。</p><p>堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，<strong>相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。</strong></p><h3 id="限制">限制</h3><p>如何限制类对象只能在堆或者栈上建立呢？下面分别进行讨论。</p><p><strong>1、只能在堆上分配类对象，就是不能静态建立类对象，即不能直接调用类的构造函数。</strong></p><p>容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operatornew()函数只用于分配内存，无法提供构造功能。因此，<strong>这种方法不可以。</strong></p><p>当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，<strong>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了</strong>。代码如下：（这种方法不好）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>试着使用<code>A a</code>;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。<strong>类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。</strong></p><p>上述方法的缺点：</p><ul><li><p><strong>无法解决继承问题</strong>。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。<strong>将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。</strong></p></li><li><p><strong>类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。</strong>（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。</p></li></ul><p>为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于<strong>单例模式</strong>：（这种方法比较可取）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> A* <span class="title">create</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>这样，调用create()函数在堆上创建类A对象，调用destory()函数释放内存。</p><p><strong>2、只能在栈上分配类对象</strong></p><p>只有使用new运算符，对象才会建立在堆上，因此，**只要禁用new运算符就可以实现类对象只能建立在栈上。**虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，<strong>将operator new()设为私有即可禁止对象被new在堆上</strong>。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><blockquote><p>转载自：<a href="http://blog.csdn.net/sdnu111111111/article/details/38707923">http://blog.csdn.net/sdnu111111111/article/details/38707923</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍两种建立类对象的方式，在栈上和堆上建立，以及对它们的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="堆" scheme="https://zsh4614.cn/tags/%E5%A0%86/"/>
    
    <category term="栈" scheme="https://zsh4614.cn/tags/%E6%A0%88/"/>
    
    <category term="new" scheme="https://zsh4614.cn/tags/new/"/>
    
    <category term="delete" scheme="https://zsh4614.cn/tags/delete/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第二百零六题：反转链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E7%99%BE%E9%9B%B6%E5%85%AD%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E7%99%BE%E9%9B%B6%E5%85%AD%E9%A2%98%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-20T14:32:30.000Z</published>
    <updated>2022-01-21T16:12:22.478Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第二百零六题，将一个链表进行反转。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/20/h8WBedLgsJ6qRYw.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/20/8IV4ybzfQXGHJxi.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>链表中节点的数目范围是 [0, 5000]</li><li>-5000 &lt;= Node.val &lt;= 5000</li></ul><h3 id="分析">分析</h3><p><strong>要深刻理解链表的结构，每个结点在存储上并不连续，他们之间的关系就是指针的指向，所以反转一个链表就是将每个结点的指针域由指向后一个结点变成指向前一个结点即可</strong>；另一种思路是递归，这种思路比较好想到，但是实现起来需要一定的功底；工程中应尽量避免递归，基本上所有的递归都能改成用stack和dfs实现，这个也不例外，而且stack是先进后出，很适合这种反转操作。</p><h3 id="实现">实现</h3><p><strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head; </span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* end = head-&gt;next;</span><br><span class="line">    ListNode* new_head = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    end-&gt;next = head;</span><br><span class="line">    end-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p>注意：在递归的写法中，前面两个判断条件可以写成同一个，都返回head；另外<code>head == nullptr</code>可以写成<code>!head</code>；需要注意递归方法的时间复杂度。</p><p><strong>stack</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* res = stack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ListNode* top = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            top-&gt;next = stack.<span class="built_in">top</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            top-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第二百零六题，将一个链表进行反转。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://zsh4614.cn/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="stack" scheme="https://zsh4614.cn/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百六十题：相交链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%85%AD%E5%8D%81%E9%A2%98%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%85%AD%E5%8D%81%E9%A2%98%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-17T15:01:11.000Z</published>
    <updated>2022-01-17T16:12:48.798Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百六十题，判断两个链表是否相交，并找出相交的结点。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://s2.loli.net/2022/01/17/xf6UjXkD2TeWI3F.png" alt="image.png"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h3 id="示例">示例</h3><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/17/deKrCEjBOtQgmWI.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/17/pec9sSCqiohBu5r.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><img src="https://s2.loli.net/2022/01/17/hEXnDypY7I56LfO.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>listA 中节点数目为 m</li><li>listB 中节点数目为 n</li><li>1 &lt;= m, n &lt;= 3 * 104</li><li>1 &lt;= Node.val &lt;= 105</li><li>0 &lt;= skipA &lt;= m</li><li>0 &lt;= skipB &lt;= n</li><li>如果 listA 和 listB 没有交点，intersectVal 为 0</li><li>如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</li></ul><h3 id="分析">分析</h3><p>如果只是判断两个链表是否相交，那么就很简单了，只需要判断最后一个结点是否是同一个结点。但是本题要返回相交的那个结点，一个最直接的思路是使用哈希表，先将一个链表的每个结点地址存储起来，然后在遍历第二个链表的时候去查表，这样时间复杂度是O(m+n)，空间复杂度为O(m)。另一种常用的思路是用双指针，同时遍历两个链表，当遍历到尾结点的时候，指向另一个链表的头结点，这样如果有相交的话，那么一定会指到同一个结点上；如果不相交的话，那么最后他们一定同时指向nullptr。</p><h3 id="实现">实现</h3><p><strong>方法一：哈希</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; hashset;</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        hashset.<span class="built_in">emplace</span>(headA);</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.<span class="built_in">find</span>(headB) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">    ListNode* workA &#x3D; headA;</span><br><span class="line">    ListNode* workB &#x3D; headB;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        </span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            return workB;</span><br><span class="line">        &#125;</span><br><span class="line">        workA &#x3D; workA-&gt;next;</span><br><span class="line">        workB &#x3D; workB-&gt;next;</span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workA &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workA &#x3D; headB;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workB &#x3D; headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的思路，看一下大神写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA &#x3D;&#x3D; nullptr || headB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA &#x3D; headA, *pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NB!!!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百六十题，判断两个链表是否相交，并找出相交的结点。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://zsh4614.cn/categories/Leetcode/"/>
    
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百四十二题：环形链表二</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/</id>
    <published>2022-01-16T08:40:10.000Z</published>
    <updated>2022-01-16T10:01:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一百四十二题，判断一个链表是否有环，有环的话找到入环的结点，用佛洛依德判圈算法实现。</p><span id="more"></span><h3 id="题目：">题目：</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改链表。</p><h3 id="示例">示例</h3><p><strong>示例一</strong></p><p><img src="https://s2.loli.net/2022/01/16/p4XMYle9k8yqxwm.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例二</strong></p><p><img src="https://s2.loli.net/2022/01/16/v8whclNoCksYBQT.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例三</strong></p><p><img src="https://s2.loli.net/2022/01/16/2PmvFTZqnyrhkap.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 [0, 10^4] 内</li><li>-10^5 &lt;= Node.val &lt;= 10^5</li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><h3 id="分析">分析</h3><p>本题可使用佛洛依德判圈算法求解。</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* slow = dummy1;</span><br><span class="line">    ListNode* dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* fast = dummy2;</span><br><span class="line">    slow-&gt;next = head;</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow-&gt;next) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里虚拟了一个dummy结点，这样可以将头结点当作一般结点看待，否则可能需要判断头结点为空的情况，这样做就不用单独判断了。另外<strong>新开辟的无用内存，在返回前一定要释放，否则会内存泄漏</strong>，这里的slow和fast相当于工作结点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一百四十二题，判断一个链表是否有环，有环的话找到入环的结点，用佛洛依德判圈算法实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：Floyd判圈算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-15T09:21:19.000Z</published>
    <updated>2022-01-16T08:28:07.984Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍一种常用的判圈算法，并给出其推导。</p><span id="more"></span><h3 id="简述">简述</h3><p>Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。</p><h3 id="问题">问题</h3><p>如何检测一个链表是否有环，如果有，那么如何确定环的起点和环的长度。</p><p>1）判断是否有环？<br>龟兔解法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p><p>基于上面的想法，Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果时等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。</p><p>2）求环的长度<br>假设相遇点为B点,让其中一个指针停在B不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p><p>3）如何确定环的起点<br>假设相遇点为B点。方法是将其中一个指针移到链表起点，另一个指针为B点,两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。</p><h3 id="证明">证明</h3><p>首先假设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m，环的长度为n，相遇的位置与起点与起点位置距离为k。于是有：</p><p>i = m + a * n + k</p><p>其中a为慢指针走的圈数。</p><p>因为快指针的速度是慢指针的2倍，于是又可以得到另一个式子：</p><p>2 * i = m + b * n + k</p><p>其中b为快指针走的圈数。</p><p>两式相减得：</p><p>i = ( b - a ) * n</p><p>也就是说i是圈长的整数倍。</p><p>这是将其中一个节点放在起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点i+m，i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍一种常用的判圈算法，并给出其推导。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++之STL无序关联式容器unordered_map</title>
    <link href="https://zsh4614.cn/C-%E4%B9%8BSTL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8unordered-map/"/>
    <id>https://zsh4614.cn/C-%E4%B9%8BSTL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8unordered-map/</id>
    <published>2022-01-15T08:55:38.000Z</published>
    <updated>2022-01-15T09:19:39.450Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。</p><span id="more"></span><h3 id="引言">引言</h3><p>关联式容器，常被称为“无序容器”、“哈希容器”或者“无序关联容器”。注意，无序容器是 C++ 11 标准才正式引入到 STL 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><p>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p><ul><li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li><li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li></ul><p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p><p><img src="https://s2.loli.net/2022/01/15/NcwjdSUL5kMvG1o.png" alt="image.png"></p><h3 id="创建">创建</h3><p>unordered_map 容器模板的定义如下所示：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="STL" scheme="https://zsh4614.cn/tags/STL/"/>
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="unordered_map" scheme="https://zsh4614.cn/tags/unordered-map/"/>
    
  </entry>
  
</feed>
