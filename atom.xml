<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到我的主页!</title>
  
  
  <link href="https://zsh4614.cn/atom.xml" rel="self"/>
  
  <link href="https://zsh4614.cn/"/>
  <updated>2022-01-09T15:13:52.376Z</updated>
  <id>https://zsh4614.cn/</id>
  
  <author>
    <name>zsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode第二十一题：合并两个有序链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-09T15:12:40.000Z</published>
    <updated>2022-01-09T15:13:52.376Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第二十一题，合并两个有序链表，用迭代和递归两种方法实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="示例">示例</h3><p><img src="https://s2.loli.net/2022/01/09/L8AQHIcVbtk1ZUe.png" alt="image.png"></p><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;= s.length &lt;= 5 * 104</li><li>s由英文字母、数字、符号和空格组成</li></ul><h3 id="分析">分析</h3><p>该题目常规思路就是迭代两个链表的结点，比较大小，小的往后面移动一个结点，然后再比较大小，如此迭代下去，直到一个链表指针域为空，然后把另一个链表接上即可；另一种思路是递归，这种方法比较巧妙</p><p><img src="https://s2.loli.net/2022/01/09/BrE9Dsg1YaKXQvc.png" alt="image.png"></p><p>但是需要考虑其中一个为空的情况，作为迭代的出口。</p><h3 id="实现">实现</h3><h4 id="方法一-迭代">方法一(迭代)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode *work = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *dummy = work;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* &amp;tmp = list1-&gt;val &lt; list2-&gt;val ? list1 : list2;</span><br><span class="line">        work-&gt;next = tmp;</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    work-&gt;next = (list1 == <span class="literal">nullptr</span>) ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-递归">方法二(递归)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">        list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>链表中常用到dummy结点，用来解决头结点问题，这样可以使得头结点和一般结点没有什么区别，注意灵活应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第二十一题，合并两个有序链表，用迭代和递归两种方法实现。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++动态多态</title>
    <link href="https://zsh4614.cn/C-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"/>
    <id>https://zsh4614.cn/C-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/</id>
    <published>2021-12-30T02:23:05.000Z</published>
    <updated>2022-01-09T15:12:00.807Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++动态多态（polymorphism），其核心机制为虚函数。</p><span id="more"></span><h4 id="初步印象">初步印象</h4><p>多态（polymorphism）是面向对象编程语言的一大特点，而虚函数是实现多态的机制。其核心理念就是通过基类访问派生类定义的函数。多态性使得程序调用的函数是在<strong>运行时动态确定</strong>的，而不是在编译时静态确定的。使用一个基类类型的指针或者引用，来指向子类对象，进而调用由子类复写的个性化的虚函数，这是C++实现多态性的一个最经典的场景。</p><ul><li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func()</li><li>纯虚函数，在虚函数后加“=0”，如 virtual void func()=0</li><li>对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。</li><li>对于纯虚函数，子类必须提供纯虚函数的个性化实现。</li></ul><p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了“多态”特性。但区别是：</p><ul><li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；</li><li>**子类如果不提供纯虚函数的实现，编译将会失败。**尽管在基类中可以给出纯虚函数的实现，但无法通过指向子类对象的基类类型指针来调用该纯虚函数，也即不能作为子类相应纯虚函数的备选方案。（纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路。）</li></ul><h4 id="虚函数">虚函数</h4><p>placehoder[此处插入代码]</p><p>在上述例子中，我们首先定义了一个基类base，基类有一个名为vir_func的虚函数，和一个名为func的普通成员函数。类A，B都是由类base派生的子类。然后我们定义三个base*类型的指针Base、a、b分别指向类base、A、B。可以看到，当使用这三个指针调用func函数时，调用的都是基类base的函数。而使用这三个指针调用虚函数vir_func时，调用的是指针指向的实际类型的函数。最后，我们将指针b做强制类型转换，转换为A*类型，然后分别调用func和vir_func函数，发现普通函数调用的是类A的函数，而虚函数调用的是类B的函数。以上，我们可以得出结论**“当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定”**。</p><p>对于一个只包含非静态成员变量和普通成员函数的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  void fun_a();</span><br><span class="line">  void fun_b();</span><br><span class="line">  int var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中成员函数放在代码区，为该类的所有对象公有，即不管新建多少个该类的对象，所对应的都是同一个函数存储区的函数。而成员变量则为各个对象所私有，即每新建一个对象都会新建一块内存区用来存储var值。在调用成员函数时，程序会根据类的类型，找到对应代码区所对应的函数并进行调用。</p><p>在上面例子中，Base、a、b都是base类型的指针。调用普通函数时，程序根据指针的类型到类base所对应的代码区找到所对应的函数，所以都调用了类base的func函数，即指针的类型决定了普通函数的调用。</p><p>那么包含虚函数的类又是怎样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class D&#123;</span><br><span class="line">  void func_a();</span><br><span class="line">  virtual void func_b();</span><br><span class="line">  int var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时如果sizeof一个类D的对象，会发现比类C的对象大4个字节。多出来的这4个字节就是实现虚函数的关键----<strong>虚函数表指针vptr</strong>。这个指针指向一张名为“虚函数表”（vtbl）的表，而表中的数据则为函数指针，存储了虚函数fun_b()具体实现所对应的位置。注意，**普通函数、虚函数、虚函数表都是同一个类的所有对象公有的，只有成员变量和虚函数表指针是每个对象私有的，sizeof的值也只包括vptr和var所占内存的大小，并且vptr通常会在对象内存的最起始位置。另外，当类有多个虚函数时，仍然只有一个虚函数表指针vptr（指向一个虚函数表），而此时的虚函数表vtbl中会有多个函数指针，分别指向对应的虚函数实现区域。**因此，<strong>虚函数实现的过程是：通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。所以虚函数的调用时由指针所指向内存块的具体类型决定的。</strong></p><h4 id="纯虚函数">纯虚函数</h4><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。</p><p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p><p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p><p>含有纯虚函数的类称之为抽象类，**它不能生成对象（创建实例），只能创建它的派生类的实例。**抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</p><p><strong>抽象类只能作为基类来使用</strong>，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p><h4 id="选用时机">选用时机</h4><p>当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。<br>当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数</p><h4 id="构造函数和析构函数">构造函数和析构函数</h4><p>构造函数和析构函数可以是虚函数吗？</p><p>答案是：<strong>构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</strong></p><p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p><p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p><blockquote><p>转载于：<a href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++动态多态（polymorphism），其核心机制为虚函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="虚函数" scheme="https://zsh4614.cn/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="动态多态" scheme="https://zsh4614.cn/tags/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"/>
    
    <category term="纯虚函数" scheme="https://zsh4614.cn/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++11线程池</title>
    <link href="https://zsh4614.cn/C-11%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://zsh4614.cn/C-11%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-12-08T03:51:59.000Z</published>
    <updated>2022-01-09T15:12:00.807Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍线程池，并基于C++11实现。</p><span id="more"></span><h3 id="背景">背景</h3><p>传统多线程方案是：接受一个任务之后，创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么将处于不停的创建线程，销毁线程的状态。我们将传统方案中的线程执行过程分为三个过程：线程创建时间+线程执行时间+线程销毁时间，如果线程执行时间很短的话，线程本身开销占的比重将会很大，这个开销将不可忽略。另外每个 Thread 都需要有一个内核线程的支持，也就意味着每个Thread都需要消耗一定的内核资源（如内核线程的栈空间），因为能创建的 Thread 是有限的，默认一个线程的线程栈大小是1M，如果每来一个任务就创建一个线程的话，1024个任务就会创建1024个线程，就会占用1个G的内存，很容易就系统崩溃了。</p><p>因此，线程池的出现正是着眼于线程本身的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Ptr = std::shared_ptr&lt;ThreadPool&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">int</span> idl_thr_num) : <span class="built_in">run_</span>(<span class="literal">true</span>), <span class="built_in">idl_thr_num_</span>(idl_thr_num) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idl_thr_num_; ++i) &#123;</span><br><span class="line">            pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]&#123;  <span class="comment">// 工作线程函数</span></span><br><span class="line">                <span class="keyword">while</span> (run_) &#123;</span><br><span class="line">                    Task task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; lock&#123; mutex_ &#125;;</span><br><span class="line">                        cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> !run_ || !task_.<span class="built_in">empty</span>(); &#125;);  <span class="comment">// 等待直到任务队列有任务或者线程池停止工作</span></span><br><span class="line">                        <span class="keyword">if</span> (!run_ &amp;&amp; task_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(task_.<span class="built_in">front</span>());  <span class="comment">// 从任务队列首取出一个任务</span></span><br><span class="line">                        task_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    idl_thr_num_--;</span><br><span class="line">                    <span class="built_in">task</span>();  <span class="comment">// 执行任务</span></span><br><span class="line">                    idl_thr_num_++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        run_ = <span class="literal">false</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; thread : pool_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">                thread.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idlCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idl_thr_num_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">    auto commit(F&amp;&amp; f, Args&amp;&amp;... args)-&gt;std::future&lt;decltype(f(args...))&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!run_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;commit on ThreadPool is stopped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 函数f的返回值类型</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        std::future&lt;RetType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; lock&#123;mutex_ &#125;;</span><br><span class="line">            task_.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);  <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_one</span>();  <span class="comment">// 唤醒一个线程</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">    std::vector&lt;std::thread&gt; pool_;             <span class="comment">// 线程池</span></span><br><span class="line">    std::queue&lt;Task&gt; task_;                     <span class="comment">// 任务队列</span></span><br><span class="line">    std::mutex mutex_;                          <span class="comment">// 线程锁</span></span><br><span class="line">    std::condition_variable cv_;                <span class="comment">// 条件阻塞</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">bool</span>&gt; run_;                     <span class="comment">// 线程池是否执行标志</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">int</span>&gt; idl_thr_num_;              <span class="comment">// 空闲线程数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="简单使用">简单使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在执行第 %d 个任务， 线程id为 %d\n&quot;</span>, i, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行完成第 %d 个任务， 线程id为 %d\n&quot;</span>, i, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    ThreadPool::Ptr thread_pool_ptr = std::make_shared&lt;ThreadPool&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        thread_pool_ptr-&gt;<span class="built_in">commit</span>([i]()&#123;<span class="built_in">task</span>(i);&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码链接：<a href="https://github.com/zsh4614/thread_pool">https://github.com/zsh4614/thread_pool</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍线程池，并基于C++11实现。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="多线程" scheme="https://zsh4614.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://zsh4614.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="https://zsh4614.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>多传感器时间同步机制</title>
    <link href="https://zsh4614.cn/ros%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>https://zsh4614.cn/ros%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2021-11-25T07:07:02.000Z</published>
    <updated>2022-01-09T15:12:00.807Z</updated>
    
    <content type="html"><![CDATA[<p>引言：多传感器时间同步是高级辅助驾驶系统和自动驾驶中必不可少的关键步骤，本文主要介绍一种多传感器时间同步的方法，并进行了C++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>多传感器时间同步就是把不同传感器发出的message序列在时间上进行匹配，比如有多个激光雷达，多个摄像头，多个radar，以及组合惯导等传感器，在系统启动后，这些传感器都在以一定的频率往外部发送消息，那么某一时刻而言，究竟取这些传感器的哪一个消息，才是同一时刻的呢？这些传感器的频率可能不同，但是每一帧消息应该都有一个时间戳，代表这个消息是哪个时间产生的，比如一共有20个传感器，同步好的代表当前的所有消息应该也是20帧，他们之间的时间戳应该一致，但是由于频率不一致，所以很难保证具有完全相同的时间戳，所以退而求其次，可以在一定的时间范围内认为这20个消息是同步的，他们应该满足一个条件，就是不应该存在另一个选择，使得这20个消息的时间跨度（最早时间和最晚时间之差）小于当前的时间跨度，这样才认为这个同步是正确的，ros实现了这种时间同步的方法，下面将对其使用方法和原理进行详细说明，由于该算法比较绕，考虑的情况也比较多，个人也只是一知半解。</p><h3 id="使用方法">使用方法</h3><p>下面是一个4个激光雷达产生的点云消息和1个组合惯导产生的pose消息，其中雷达发出的点云消息为10hz，惯导产生的pose消息为100hz。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/subscriber.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/synchronizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/sync_policies/approximate_time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg0,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg1,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg2,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg3,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> geometry_msgs::PoseStampedConstPtr &amp;msg4)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; <span class="string">&quot;/back_lidar: &quot;</span> &lt;&lt; msg3-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/left_lidar: &quot;</span> &lt;&lt; msg1-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/middle_lidar: &quot;</span> &lt;&lt; msg0-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/pose_stamp: &quot;</span> &lt;&lt; msg4-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/right_lidar: &quot;</span> &lt;&lt; msg2-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl;</span><br><span class="line">                            </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------------------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;ros_sync_test&quot;</span>);</span><br><span class="line">    ros::NodeHandlePtr node_ptr;</span><br><span class="line">    node_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> ros::NodeHandle);</span><br><span class="line"></span><br><span class="line">    std::string topic0, topic1, topic2, topic3, topic4;</span><br><span class="line">    topic0 = <span class="string">&quot;/mems_front/rslidar_points&quot;</span>;</span><br><span class="line">    topic1 = <span class="string">&quot;/mems_left/rslidar_points&quot;</span>;</span><br><span class="line">    topic2 = <span class="string">&quot;/mems_right/rslidar_points&quot;</span>;</span><br><span class="line">    topic3 = <span class="string">&quot;/mems_back/rslidar_points&quot;</span>;</span><br><span class="line">    topic4 = <span class="string">&quot;/loc/car_pose_1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic0</span><span class="params">(*node_ptr, topic0, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic1</span><span class="params">(*node_ptr, topic1, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic2</span><span class="params">(*node_ptr, topic2, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic3</span><span class="params">(*node_ptr, topic3, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt; <span class="title">sub_topic4</span><span class="params">(*node_ptr, topic4, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> message_filters::sync_policies::ApproximateTime&lt;sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            geometry_msgs::PoseStamped&gt; syncPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function">message_filters::Synchronizer&lt;syncPolicy&gt; <span class="title">sync</span><span class="params">(syncPolicy(<span class="number">100</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic3,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic4)</span></span>;</span><br><span class="line"></span><br><span class="line">    sync.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;callback, _1, _2, _3, _4, _5));</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>syncPolicy(100)中的100是每个消息队列的最大长度，如果某个消息队列缓存长度大于100（即连续100个消息还没有同步上），就会产生问题，所以这个尽可能设置的大一些。</p><h3 id="算法实现">算法实现</h3><p>ros规定这种时间同步机制最多支持9个不同的消息，下面在不改变算法原理的基础上进行了异步实现，且不限制同步的消息个数。</p><p><a href="https://github.com/zsh4614/time_sync">github代码链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：多传感器时间同步是高级辅助驾驶系统和自动驾驶中必不可少的关键步骤，本文主要介绍一种多传感器时间同步的方法，并进行了C++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="ADAS和自动驾驶" scheme="https://zsh4614.cn/categories/ADAS%E5%92%8C%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
    
    
    <category term="时间同步" scheme="https://zsh4614.cn/tags/%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++11之匿名函数</title>
    <link href="https://zsh4614.cn/C-11%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://zsh4614.cn/C-11%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-19T04:00:12.000Z</published>
    <updated>2021-12-01T17:30:30.010Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍C++11新特性的lambda函数用法。</p><span id="more"></span><h3 id="语法格式及含义">语法格式及含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>[外部变量访问方式说明符]</li></ul><p>[]是lambda表达式标识符，不可省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量。所谓外部变量，指的是和当前 lambda 表达式<strong>位于同一作用域内的所有局部变量</strong>。注意区分外部变量和全局变量。外部变量格式有如下几种书写方式：</p><table><thead><tr><th>外部变量格式</th><th>功能</th></tr></thead><tbody><tr><td>[]</td><td>空方括号表示当前 lambda 匿名函数中<strong>不导入</strong>任何外部变量。</td></tr><tr><td>[=]</td><td>只有一个 = 等号，表示以值传递的方式<strong>导入所有</strong>外部变量；</td></tr><tr><td>[&amp;]</td><td>只有一个 &amp; 符号，表示以引用传递的方式<strong>导入所有</strong>外部变量；</td></tr><tr><td>[val1,val2,…]</td><td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td></tr><tr><td>[&amp;val1,&amp;val2,…]</td><td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td></tr><tr><td>[val,&amp;val2,…]</td><td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td></tr><tr><td>[=,&amp;val1,…]</td><td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td></tr><tr><td>[&amp;,val1,…]</td><td>表示除 val1 以值传递的方式导入外，其它外部变量都以引用传递的方式导入。</td></tr><tr><td>[this]</td><td>表示以值传递的方式导入当前的 this 指针。</td></tr></tbody></table><blockquote><p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p></blockquote><ul><li>(参数)</li></ul><p>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，<strong>如果不需要传递参数，可以连同 () 小括号一起省略</strong>；</p><ul><li>mutable</li></ul><p>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。（修改的是拷贝的那一份，并不会修改真正的外部变量）</p><ul><li>noexcept/throw()</li></ul><p>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败。</p><ul><li>-&gt; 返回值类型</li></ul><p>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略。</p><ul><li>函数体</li></ul><p>除了可以使用传入参数外，还可以使用指定的外部变量和全局变量。（外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍C++11新特性的lambda函数用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="lambda函数" scheme="https://zsh4614.cn/tags/lambda%E5%87%BD%E6%95%B0/"/>
    
    <category term="匿名函数" scheme="https://zsh4614.cn/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：拉默-道格拉斯-普克算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/</id>
    <published>2021-11-18T07:56:45.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍RDP算法。道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。</p><span id="more"></span><h3 id="算法步骤">算法步骤</h3><ol><li>连接曲线首尾两点A、B形成一条直线AB；<br>2. 计算曲线上离该直线段距离最大的点C，计算其与AB的距离d；</li><li>比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则以该直线作为曲线的近似，该段曲线处理完毕。</li><li>如果距离大于阈值，则用点C将曲线分为两段AC和BC，并分别对两段曲线进行步骤[1~3]的处理。</li><li>当所有曲线都处理完毕后，依次连接各个分割点形成折线，作为原曲线的近似。</li></ol><h3 id="实现">实现</h3><h4 id="实现一">实现一</h4><p>下面采用 C++实现，是一个DFS深搜的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; in_pts, </span></span></span><br><span class="line"><span class="function"><span class="params">         std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">float</span> epsilon = <span class="number">0.1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = in_pts.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">mask</span><span class="params">(size, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    std::pair&lt;int, int&gt; pts_pair(0, size-1);</span><br><span class="line">    std::stack&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(pts_pair);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur_pair = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">float</span> dmax = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur_pair.first + <span class="number">1</span>; i &lt; cur_pair.second; ++i) &#123;</span><br><span class="line">            <span class="keyword">float</span> d = <span class="built_in">getPerpendicularDistance</span>(in_pts[cur_pair.first], in_pts[cur_pair.second], in_pts[i]);</span><br><span class="line">            <span class="keyword">if</span> (d &gt; dmax) &#123;</span><br><span class="line">                dmax = d;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dmax &gt; epsilon) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cur_pair.first, i));</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, cur_pair.second));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mask[cur_pair.first] = <span class="literal">true</span>;</span><br><span class="line">            mask[cur_pair.second] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(size);</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i]) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPerpendicularDistance()函数是求点到线的距离函数，有两种方法，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：利用点到直线的距离公式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, maxDist = <span class="number">0</span>;</span><br><span class="line">    A = lineEnd.y - lineStart.y;</span><br><span class="line">    B = lineStart.x - lineEnd.x;</span><br><span class="line">    C = lineEnd.x * lineStart.y - lineStart.x * lineEnd.y;</span><br><span class="line">    maxDist = <span class="built_in">fabs</span>((A * pt.x + B * pt.y + C) / <span class="built_in">sqrt</span>(A * A + B *B));</span><br><span class="line">    <span class="keyword">return</span> maxDist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：利用向量运算</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = lineEnd.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> dy = lineEnd.y - lineStart.y;</span><br><span class="line">    <span class="keyword">float</span> mag = std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(dx, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(dy, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (mag &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        dx /= mag;</span><br><span class="line">        dy /= mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> pvx = pt.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> pvy = pt.y - lineStart.y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> pvdot = dx * pvx + dy * pvy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> dsx = pvdot * dx;</span><br><span class="line">    <span class="keyword">float</span> dsy = pvdot * dy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> ax = pvx - dsx;</span><br><span class="line">    <span class="keyword">float</span> ay = pvy - dsy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(ax, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(ay, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现二">实现二</h4><p>有时需要对polygon（闭合）的点数进行限制，抽取出固定数量的点，这种情况下，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifiedRDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt; &amp;in_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> n_pts = <span class="number">64</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>()) &lt;= n_pts) &#123;</span><br><span class="line">        out_pts = in_pts;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SimData</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l_idx;</span><br><span class="line">        <span class="keyword">int</span> r_idx;</span><br><span class="line">        <span class="keyword">float</span> epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">std::vector&lt;SimData&gt; <span class="title">mask</span><span class="params">(in_pts.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;sim_data = mask[i];</span><br><span class="line">        sim_data.l_idx = i - <span class="number">1</span>;</span><br><span class="line">        sim_data.r_idx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            sim_data.l_idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i) == <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            sim_data.r_idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sim_data.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[i], in_pts[sim_data.l_idx], in_pts[sim_data.r_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> comp = [](<span class="keyword">const</span> SimData &amp;i, <span class="keyword">const</span> SimData &amp;j) &#123;</span><br><span class="line">        <span class="keyword">return</span> i.epsilon &lt; j.epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (cc &gt; n_pts) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = std::<span class="built_in">min_element</span>(mask.<span class="built_in">begin</span>(), mask.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(std::<span class="built_in">distance</span>(mask.<span class="built_in">begin</span>(), res));</span><br><span class="line">        <span class="comment">// 找到距离最小的点，标记并把其距离置为无穷大</span></span><br><span class="line">        maks[idx].flag = <span class="literal">false</span>;</span><br><span class="line">        mask[idx].epsilon = std::numeric_limits&lt;<span class="keyword">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        cc--;</span><br><span class="line">        <span class="comment">// 更新该点的左右邻居</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;l_mask = mask[res-&gt;l_idx];</span><br><span class="line">        l_mask.r_idx = res-&gt;r_idx;</span><br><span class="line">        l_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;l_idx], in_pts[l_mask.l_idx], in_pts[l_mask.r_idx]);</span><br><span class="line">        <span class="keyword">auto</span> &amp;r_mask = mask[res-&gt;r_idx];</span><br><span class="line">        r_mask.l_idx = res-&gt;l_idx;</span><br><span class="line">        r_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;r_idx], in_pts[r_mask.l_idx], in_pts[r_mask.l_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i].flag) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>本文主要总结了RDP算法的dfs实现，其原始版本是递归实现的，至于那个版本的实现更快，还需要进一步论述，但是在工程代码中，不推荐使用递归；点到直线的距离计算效率，也需要benchmark进行测试比较。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍RDP算法。道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
    <category term="几何算法" scheme="https://zsh4614.cn/tags/%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95/"/>
    
    <category term="拉默-道格拉斯-普克算法" scheme="https://zsh4614.cn/tags/%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>粗浅理解</title>
    <link href="https://zsh4614.cn/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <id>https://zsh4614.cn/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/</id>
    <published>2021-11-17T03:12:28.000Z</published>
    <updated>2021-12-01T17:30:30.016Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要总结对于机器学习和深度学习领域一些比较片面粗浅的理解，包含的范围比较杂乱，在此做一个记录。</p><span id="more"></span><h3 id="一、对于CNN和Transformer的对比">一、对于CNN和Transformer的对比</h3><p>CNN使用了较强的归纳偏置（inductive biases）:</p><ul><li>权重共享，图像不同部分以相同方式处理，位置不敏感；</li><li>由于卷积算子的性质，卷积的特征图具有局部敏感性,也就是每次卷积操作只会考虑原始数据的一小部分的局部信息。</li></ul><p>因此，CNN 的归纳偏置缺乏对输入数据本身的整体把握。它很擅长提取局部的有效信息，但是没能提取全局数据之间的长距离特征。</p><p>相比之下，基于自注意力机制的Transformer模型最小化了归纳偏置。当在大数据集上进行训练时，这些模型的性能已经可以媲美甚至超过 CNN 。但在小数据集上训练时，它们往往很难学习有意义的表征。可以说，CNN在小数据集上表现较为突出，因为预先强加了归纳偏置，可以让网络一开始就朝着比较正确的方向学习，但当数据量增大时，可能由于这些归纳偏置，导致其达到一个上限，而Transformer没有，所以对数据非常饥渴，但同时上限也很高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要总结对于机器学习和深度学习领域一些比较片面粗浅的理解，包含的范围比较杂乱，在此做一个记录。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zsh4614.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式：单例模式</title>
    <link href="https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-16T08:16:09.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍设计模式中的单例模式，并给出C++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>单例模式也称为单件模式、单子模式，可能是使用最广泛的设计模式。其意图是**保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。**有很多地方需要这样的功能模块，如系统的日志输出，操作系统只能有一个任务管理器，一台PC连一个键盘，工程中的通用配置类等。</p><h3 id="实现">实现</h3><h4 id="实现一">实现一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先检查对象是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(); <span class="comment">//私有构造函数，不允许使用者自己生成对象</span></span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance; <span class="comment">//静态成员变量 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户访问唯一实例的方法只有getInstance()成员函数。如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的。getInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的 。这是一种防弹设计——所有getInstance()之后的调用都返回相同实例的指针。</p><p>这种实现方法有以下几个特点：</p><ul><li>它有一个指向唯一实例的静态指针m_instance，并且是私有的；</li><li>它有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；</li><li>它的构造函数是私有的，这样就不能从别处创建该类的实例。</li></ul><p>但是这种实现方法存在两个问题：一是m_instance指向的空间是动态分配的，需要显式进行释放；二是这种方法不是线程安全的。对于第一个问题，可能有人会说，直接在析构函数中进行delete就可以释放了啊，但是这样会存在问题，因为**在类的析构函数中delete类自身实例的指针，delete又会调用析构函数，这样就会出现循环调用的问题，会造成栈内存溢出，因此编译器不允许这么做。**下面我们针对这两个问题一一进行分析</p><h4 id="实现二">实现二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_instance;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>   //它的唯一工作就是在析构函数中删除<span class="title">CSingleton</span>的实例</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGarbo</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Singleton::m_instance)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;  <span class="comment">//定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个妥善的方法是让这个类自己知道在合适的时候把自己删除，或者说把删除自己的操作挂在操作系统中的某个合适的点上，使其在恰当的时候被自动执行。我们知道，程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如上面的代码中的CGarbo类（Garbo意为垃圾工人），类CGarbo被定义为Singleton的私有内嵌类，以防该类被在其他地方滥用。<br>程序运行结束时，系统会调用Singleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。<br>使用这种方法释放单例对象有以下特征：</p><ul><li>在单例类内部定义专有的嵌套类；</li><li>在单例类内定义私有的专门用于释放的静态成员；</li><li>利用程序在结束时析构全局变量的特性，选择最终的释放时机；</li><li>使用单例的代码不需要任何操作，不必关心对象的释放。</li></ul><h4 id="实现三">实现三</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现二中添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如上，使用<strong>局部静态变量</strong>，非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。但使用此种方法也会出现问题，当如下方法使用单例时问题来了：</p><p><code>Singleton singleton = Singleton :: getInstance();</code></p><p>这么做就出现了一个类拷贝的问题，这就违背了单例的特性。产生这个问题原因在于：编译器会为类生成一个默认的拷贝构造函数，来支持类的拷贝。最后没有办法，我们要禁止类拷贝和类赋值，禁止程序员用这种方式来使用单例，所以可以让getInstance()返回一个指针，代码变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以显式禁用类的拷贝构造函数和赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现四">实现四</h4><p>我们从头到尾都还没考虑线程安全问题，但是如果使用实现三的方法，就避免了线程安全，这是因为：<strong>在c++ 11新标准中，静态局部变量是线程安全的</strong>。所以最终的单例模式实现版本为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍设计模式中的单例模式，并给出C++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式（C++）" scheme="https://zsh4614.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    
    
    <category term="静态局部变量" scheme="https://zsh4614.cn/tags/%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="单例模式" scheme="https://zsh4614.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习：几何绘制</title>
    <link href="https://zsh4614.cn/OpenCV%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%87%A0%E4%BD%95%E7%BB%98%E5%88%B6/"/>
    <id>https://zsh4614.cn/OpenCV%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%87%A0%E4%BD%95%E7%BB%98%E5%88%B6/</id>
    <published>2021-11-10T07:15:40.000Z</published>
    <updated>2021-12-01T17:30:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍OpenCV中的部分几何绘制函数的用法，包括：圆，椭圆，矩形，直线，填充多边形。</p><span id="more"></span><h3 id="示例">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> w 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span></span>;</span><br><span class="line"><span class="comment">// 入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cv::Mat atom_image = cv::Mat::zeros(h, w, CV_8UC3);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 0);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 90);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 45);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, -45);</span></span><br><span class="line"><span class="comment">    MyCircle(atom_image, cv::Point(w/2, w/2));</span></span><br><span class="line"><span class="comment">    cv::imshow(&quot;ellipse&quot;, atom_image);</span></span><br><span class="line"><span class="comment">    cv::waitKey();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 注意这里是 h,w 的格式</span></span><br><span class="line">    cv::Mat rook_image = cv::Mat::<span class="built_in">zeros</span>(h, w, CV_8UC3);</span><br><span class="line">    <span class="built_in">MyPolygon</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyRectangle</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">0</span>, <span class="number">15</span>*w/<span class="number">16</span> ), cv::<span class="built_in">Point</span>( w, <span class="number">15</span>*w/<span class="number">16</span> ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, w ) );</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;rook&quot;</span>, rook_image);</span><br><span class="line">    <span class="comment">// 窗口显示在屏幕上的位置</span></span><br><span class="line">    cv::<span class="built_in">moveWindow</span>(<span class="string">&quot;rook&quot;</span>, <span class="number">2000</span>, <span class="number">800</span> );</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 椭圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = <span class="number">4</span>;</span><br><span class="line">    cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">                cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">                angle,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">360</span>,</span><br><span class="line">                cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">                thickness,</span><br><span class="line">                lineType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">circle</span>(img,</span><br><span class="line">               center,</span><br><span class="line">               w/<span class="number">32</span>,</span><br><span class="line">               cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">               <span class="number">2</span>,</span><br><span class="line">               <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                  cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                  cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                  cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                  <span class="number">-1</span>,</span><br><span class="line">                  <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意多边形填充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Create some points */</span></span><br><span class="line">  cv::Point rook_points[<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">0</span>]  = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">1</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">2</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">3</span>]  = cv::<span class="built_in">Point</span>( <span class="number">11</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">4</span>]  = cv::<span class="built_in">Point</span>( <span class="number">19</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">5</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">6</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">7</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">8</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">9</span>]  = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">10</span>] = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">11</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">12</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">13</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">14</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">15</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">16</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">17</span>] = cv::<span class="built_in">Point</span>( <span class="number">13</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">18</span>] = cv::<span class="built_in">Point</span>(  <span class="number">5</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">19</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ppt为二级指针（rook_points[0]是一个指针，所以ppt是一个指针数组，数组名是指向数组的指针）</span></span><br><span class="line">  <span class="keyword">const</span> cv::Point* ppt[<span class="number">1</span>] = &#123;rook_points[<span class="number">0</span>]&#125;;</span><br><span class="line">  <span class="keyword">int</span> npt[] = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">  cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><p>1.椭圆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">            cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">            cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">            angle,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">360</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">            thickness,</span><br><span class="line">            lineType);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>cv::Point(w/2, w/2)：椭圆心</p><p>cv::Size(w/4, w/16)：焦距</p><p>angle：旋转角度（不是弧度），注意是图像坐标系，右是正x，下是正y</p><p>angle_begin：圆弧的起始角度（不是弧度）</p><p>angle_end：圆弧的结束角度（不是弧度）</p><p>cv::Scalar( 255, 0, 0 )：颜色，BGR顺序</p><p>thickness：线宽， -1代表填充</p><p>lineType：线型，16是抗锯齿的线型，看起来边缘更平滑。可选-1，4， 8， 16，关于四邻域线型和八邻域线型，参考<a href="https://blog.csdn.net/young__fan/article/details/82696276">这里</a>。</p><p>2.圆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">circle</span>(img,</span><br><span class="line">            center,</span><br><span class="line">            w/<span class="number">32</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>center：cv::Point，圆心</p><p>w/32：int,，半径</p><p>cv::Scalar(0, 0, 255)：颜色，BGR顺序</p><p>thickness：同上</p><p>lineType：同上</p><p>3.矩形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                <span class="number">-1</span>,</span><br><span class="line">                <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>pt1：矩形左上角坐标，cv::Point</p><p>pt2：矩形右下角坐标，cv::Point</p><p>cv::Scalar(0, 255, 255)：颜色</p><p>thickness：同上</p><p>lineType：同上</p><p>4.直线（多边形）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>start：cv::Point，起始点</p><p>end：cv::Point，终止点</p><p>cv::Scalar(0, 0, 0)：颜色</p><p>thickness：同上</p><p>lineType：同上</p><p>5.填充多边形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>ppt：Array of polygons where each polygon is represented as an array of points.</p><p>npt：Array of 每个polygon的点数</p><p>ncontours：多边形数量</p><p>cv::Scalar(0, 0, 0)：颜色</p><p>lineType：同上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍OpenCV中的部分几何绘制函数的用法，包括：圆，椭圆，矩形，直线，填充多边形。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenCV" scheme="https://zsh4614.cn/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu私有仓库UI服务部署</title>
    <link href="https://zsh4614.cn/Ubuntu%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93UI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
    <id>https://zsh4614.cn/Ubuntu%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93UI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</id>
    <published>2021-11-04T03:25:15.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍利用第三方镜像部署docker私有仓库可视化界面服务的方法。</p><span id="more"></span><h3 id="方法一">方法一</h3><p>1.从官方仓库拉取第三方镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure><p>2.启动UI服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -itd -p 60022:80 --restart=always --name=docker-registry-ui -e SINGLE_REGISTRY=true -e REGISTRY_TITLE=&quot;xxxxxxxx registry&quot; -e SHOW_CONTENT_DIGEST=true -e DELETE_IMAGES=true -e NGINX_PROXY_PASS_URL=&quot;http://10.10.8.185:5000&quot; joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure><p><strong>注意：这些环境变量一个也不能错</strong></p><p>3.访问http://10.10.8.185:60022可以登录UI界面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍利用第三方镜像部署docker私有仓库可视化界面服务的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="docker" scheme="https://zsh4614.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu ssh</title>
    <link href="https://zsh4614.cn/Ubuntu-ssh/"/>
    <id>https://zsh4614.cn/Ubuntu-ssh/</id>
    <published>2021-11-04T02:56:44.000Z</published>
    <updated>2021-12-01T17:30:30.013Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍Ubuntu的ssh相关服务。</p><span id="more"></span><h3 id="设置ssh免密登录">设置ssh免密登录</h3><p>ssh-copy-id &lt;username&gt;@&lt;target_host_ip&gt;</p><p>解决按照上述操作之后还不能免密登录的方法：将<code>/etc/ssh/sshd_config</code>中的<code>StrictModes yes</code>改成no。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍Ubuntu的ssh相关服务。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="ssh" scheme="https://zsh4614.cn/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 Server安装OpenPAI v1.8.0</title>
    <link href="https://zsh4614.cn/Ubuntu18-04-Server%E5%AE%89%E8%A3%85OpenPAI-v1-8-0/"/>
    <id>https://zsh4614.cn/Ubuntu18-04-Server%E5%AE%89%E8%A3%85OpenPAI-v1-8-0/</id>
    <published>2021-11-04T02:25:57.000Z</published>
    <updated>2021-12-01T17:30:30.013Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何在Ubuntu18.04上安装OpenPAI v1.8.0。</p><span id="more"></span><h3 id="环境要求">环境要求</h3><p>OpenPAI的部署要求您至少有2台独立的机器：一台dev-box机器、一台master机器和一台worker机器。master，worker必须为物理机器，dev-box可以是硬盘空间不少于40GB的虚拟机，毕竟他只有安装和维护系统的时候才用到，用物理机器太浪费了。</p><h4 id="硬件要求">硬件要求</h4><p><strong>master：</strong></p><ul><li>至少40GB内存。</li><li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li><li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li></ul><p><strong>worker：</strong></p><ul><li>至少16GB内存。</li><li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li><li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li><li>必须有Nvidia的gpu。</li></ul><h4 id="软件要求">软件要求</h4><p><strong>master：</strong></p><ul><li>Ubuntu 18.04 (16.04、20.04应该可用)</li><li>SSH服务已开启。</li><li>和所有worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</li><li>Docker已被正确安装。</li><li>NTP已被成功开启。 您可以用命令<code>apt install ntp</code>来检查。</li><li>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</li></ul><p><strong>worker：</strong></p><ul><li><p>Ubuntu 16.04 (18.04、20.04应该可用，但没有经过完整测试)</p></li><li><p>SSH服务已开启。</p></li><li><p>所有master和worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</p></li><li><p>Docker已被正确安装。</p></li><li><p>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</p></li><li><p>nvidia驱动已被正确安装</p></li><li><p>nvidia-container-runtime已被正确安装，并且被设置为Docker的默认runtime。</p></li></ul><h3 id="依赖安装">依赖安装</h3><p>1.master和所有worker安装Ubuntu18.04系统。</p><p>参考这里</p><p>2.master和所有worker进行磁盘挂载。</p><p>参考这里</p><p>3.所有worker安装nvidia显卡驱动，并设置持久模式。</p><p>参考这里</p><p>4.master和所有worker安装docker。</p><p>参考这里</p><p>5.所有worker安装nvidia-container-runtime。</p><p>参考这里</p><p>6.master开启ntp服务。</p><p>7.dev-box设置免密登录master和所有worker。</p><p>参考这里</p><p>8.master部署docker私有仓库和UI服务。</p><p>参考这里</p><p>9.master和所有worker都安装unzip</p><h3 id="K8s安装OpenPAI">K8s安装OpenPAI</h3><p>该步骤的所有操作都在dev-box机器上。</p><h4 id="准备项目">准备项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;pai.git</span><br><span class="line">cd pai</span><br><span class="line">git checkout v1.8.0</span><br></pre></td></tr></table></figure><h4 id="准备离线相关文件">准备离线相关文件</h4><p>由于网络限制，部分镜像和服务需要离线下载安装。</p><p>1.下载离线文件并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:zsh4614/pai-offline.git</span><br><span class="line">cd pai-offline</span><br><span class="line">unzip pai-offline-deploy-distribute.zip</span><br></pre></td></tr></table></figure><p>2.将<code>offline-deploy-files-distribute.yml</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd pai-offline-deploy-distribute</span><br><span class="line">cp offline-deploy-files-distribute.yml &lt;pai-code-dir&gt;/contrib/kubespray</span><br></pre></td></tr></table></figure><p>3.将<code>roles/offline-deploy-files-distribute</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray/roles</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r roles/offline-deploy-files-distribute &lt;pai-code-dir&gt;/contrib/kubespray/roles</span><br></pre></td></tr></table></figure><p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/b0fcc1ad1d78a373a12c109491914b877fc2d56d/roles/download/defaults/main.yml#L2">这一行</a>可知，安装的时候下载的文件会存放在<code>/tmp/releases/</code>文件夹，故可提前下载好相关文件以避免网络问题。</p><p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/daed3e5b6a085ac99e076b51d314fcf76e4127b4/roles/kubernetes/node/tasks/install.yml#L11">这一行</a>可知，如果使用了<code>skip_downloads: true</code>参数，kubeadm默认不会在master节点安装，所以手动安装kubeadm。</p><h4 id="修改安装脚本">修改安装脚本</h4><p>1.在<code>/contrib/kubespray/quick-start-kubespray.sh</code>中添加如下一行，在安装过程中安装上述离线文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">echo &quot;Performing docker-cache config distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml docker-cache-config-distribute.yml -e &quot;@$&#123;CLUSTER_CONFIG&#125;&quot; || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Performing offline deploy file distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml offline-deploy-files-distribute.yml || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Starting kubernetes...&quot;</span><br><span class="line">/bin/bash script/kubernetes-boot.sh || exit $?</span><br></pre></td></tr></table></figure><p>2.将<code>/contrib/kubespray/docker-cache-config-distribute.yml</code>中的<code>docker_cache_host</code>的端口改成master节点的docker私有仓库端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker_cache_host: &quot;&#123;&#123; hostvars[groups[&#x27;kube-master&#x27;][0]][&#x27;ip&#x27;] &#125;&#125;:5000&quot;</span><br></pre></td></tr></table></figure><h4 id="编写参数文件">编写参数文件</h4><p>1.修改<code>/contrib/kubespray/config/config.yaml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user: &lt;your-ssh-username&gt;</span><br><span class="line">password: &lt;your-ssh-password&gt;</span><br><span class="line">docker_image_tag: v1.8.0</span><br><span class="line"></span><br><span class="line">enable_docker_cache: false</span><br><span class="line">docker_cache_storage_backend: &quot;filesystem&quot;</span><br><span class="line">docker_cache_fs_mount_path: &quot;/sda/pai/registry&quot;</span><br><span class="line">enable_marketplace: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">docker_data_root: /sda/pai/data</span><br><span class="line"></span><br><span class="line">openpai_kubespray_extra_var:</span><br><span class="line">  download_container: false</span><br><span class="line">  skip_downloads: true</span><br></pre></td></tr></table></figure><p>2.修改<code>/contrib/kubespray/config/layout.yaml</code>文件</p><p>仿照官方用例即可</p><h4 id="安装K8s">安装K8s</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd contrib/kubespray</span><br><span class="line">bash quick-start-kubespray.sh</span><br></pre></td></tr></table></figure><h4 id="安装OpenPAI">安装OpenPAI</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash quick-start-service.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何在Ubuntu18.04上安装OpenPAI v1.8.0。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="OpenPAI" scheme="https://zsh4614.cn/tags/OpenPAI/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装docker</title>
    <link href="https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85docker/"/>
    <id>https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85docker/</id>
    <published>2021-11-03T09:46:14.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍在ubuntu上安装docker的方法。</p><span id="more"></span><h3 id="docker安装">docker安装</h3><p>1.（可选）更换国内镜像源，推荐清华源或中科大源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i &#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>2.安装需要的依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br></pre></td></tr></table></figure><p>3.添加GPG密钥，需指定源（采用中科大源，采用默认的源下载速度慢，经常失败）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p>4.更新软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>5.安装docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>6.测试docker安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="nvidia-container-runtime安装">nvidia-container-runtime安装</h3><p>docker19.03之后建议使用nvidia-container-runtime取代nvidia-docker2。</p><p>1.添加GPG密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-container-runtime&#x2F;gpgkey | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>2.添加源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br></pre></td></tr></table></figure><p>3.更新软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>4.安装nvidia-container-runtime</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-container-runtime</span><br></pre></td></tr></table></figure><p>5.设置默认运行时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在/etc/docker/daemon.json中写入以下内容:</span><br><span class="line">&#123;</span><br><span class="line">&quot;default-runtime&quot;: &quot;nvidia&quot;,</span><br><span class="line">    &quot;runtimes&quot;: &#123;</span><br><span class="line">        &quot;nvidia&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.重启docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>7.验证安装成功（出现显卡信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm nvidia/cuda:10.0-base nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍在ubuntu上安装docker的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="基础环境" scheme="https://zsh4614.cn/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
    <category term="docker" scheme="https://zsh4614.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装nvidia显卡驱动</title>
    <link href="https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    <id>https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-11-03T09:34:19.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍在ubuntu系统上安装nvidia显卡驱动的方法，并优化驱动。</p><span id="more"></span><h3 id="安装显卡驱动">安装显卡驱动</h3><h4 id="方法一：ppa源">方法一：ppa源</h4><p>1.安装PPA源，根据提示按Enter执行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br></pre></td></tr></table></figure><p>2.更新源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update </span><br></pre></td></tr></table></figure><p>3.安装显卡驱动工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ubuntu-drivers-common</span><br></pre></td></tr></table></figure><p>4.查看可以安装的显卡驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu-drivers devices </span><br></pre></td></tr></table></figure><p>5.选择推荐的驱动进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-driver-470</span><br></pre></td></tr></table></figure><p>6.重启生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="开启持久模式">开启持久模式</h3><p><code>-pm --persistence-mode</code></p><p>启用持久性模式后，即使没有活动的客户端 (such as X11 or nvidia-smi)，NVIDIA 驱动程序也会保持加载状态。这样可以最大程度地减少与运行依赖的应用程序 (例如 CUDA 程序) 相关的驱动程序加载延迟。适用于所有支持 CUDA 的产品。**persistence mode 持久模式默认关闭。persistence mode 能够让 GPU 更快响应任务，待机功耗增加。关闭 persistence mode 同样能够启动任务。开机默认为关闭。**开启后可解决GPU初始化缓慢、无任务运行但是利用率居高不下、偶尔丢卡等问题。（不担心功耗的情况下尽量开启）</p><p>在<strong>18.04</strong>上设置开机默认开启的方法：</p><p>1.<code>/lib/systemd/system/rc-local.service</code>文件新增以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=rc-local.service</span><br></pre></td></tr></table></figure><p>2.设置rc-local开机自启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable rc-local</span><br></pre></td></tr></table></figure><p>3.在<code>/etc/rc.local</code>中填入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">nvidia-smi -pm 1</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>4.赋予可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><p>5.测试是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重启之后nvidia-smi看Persistence-M的状态为On，则配置成功。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍在ubuntu系统上安装nvidia显卡驱动的方法，并优化驱动。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="基础环境" scheme="https://zsh4614.cn/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
    <category term="显卡驱动" scheme="https://zsh4614.cn/tags/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu挂载磁盘</title>
    <link href="https://zsh4614.cn/Ubuntu%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98/"/>
    <id>https://zsh4614.cn/Ubuntu%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98/</id>
    <published>2021-11-03T08:28:21.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍ubuntu系统（包含desktop和server版本）挂载磁盘的方法，包括临时挂载和永久挂载。</p><span id="more"></span><h3 id="格式化磁盘">格式化磁盘</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs -t ext4 /dev/sdb</span><br></pre></td></tr></table></figure><p>-t ext4是将硬盘格式化为ext4文件系统类型。</p><h3 id="临时挂载">临时挂载</h3><p>一般情况下,我们想挂载一个分区的办法就是用mount命令,如我想把/dev/sda3挂载到/data下，使用以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda3 /data</span><br></pre></td></tr></table></figure><p>但这种方法有个不好的都方是机器<strong>重启后变又得手工重新挂载。</strong></p><h3 id="永久挂载">永久挂载</h3><p>永久性挂载分区的办法是修改分区文件/etc/fstab</p><p>常用磁盘命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.查看所有的磁盘：</span><br><span class="line">sudo fdisk -l</span><br><span class="line">2.查看某个磁盘的UUID和类型：</span><br><span class="line">sudo blkid &#x2F;dev&#x2F;sda3</span><br></pre></td></tr></table></figure><p><code>vim /etc/fstab</code>文件如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UUID=cec82a6a-c594-4bbd-b07a-af079cc670f2 /sdb ext4 defaults 0 0</span><br><span class="line">UUID=79abd6b3-c462-4fb3-9fc2-6b71eb0a8659 /sdc ext4 defaults 0 0</span><br><span class="line">UUID=bc28f3b0-bdbd-448f-b0d0-50cc499302d1 /sdd ext4 defaults 0 0</span><br><span class="line">UUID=63259855-0d99-4475-8b9d-6f19f93872b5 /sdf ext4 defaults 0 0</span><br></pre></td></tr></table></figure><p>各个字段含义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID 挂载点 文件系统类型 挂载参数 是否备份 是否检测</span><br></pre></td></tr></table></figure><p>保存后，需要重启或者执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure><p>才能生效。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍ubuntu系统（包含desktop和server版本）挂载磁盘的方法，包括临时挂载和永久挂载。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="基础环境" scheme="https://zsh4614.cn/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
    <category term="磁盘挂载" scheme="https://zsh4614.cn/tags/%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu server基础环境搭建</title>
    <link href="https://zsh4614.cn/Ubuntu%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://zsh4614.cn/Ubuntu%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-11-01T09:40:02.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何在ubuntu电脑上制作ubuntu server 18.04的启动盘，并安装系统和基础环境。</p><span id="more"></span><h3 id="制作ubuntu18-04-server的系统盘">制作ubuntu18.04 server的系统盘</h3><p>首先，在<a href="https://ubuntu.com/download/server">官网</a>或者<a href="https://ubuntu.mirror.garr.it/ubuntu-releases/18.04.6/">镜像网站</a>下载.iso镜像，这里选择稳定版server 18.04.6。</p><p>在ubuntu系统上推荐两种方法制作系统盘，一种是ubuntu自带的Startup Disk Creator，方法比较简单，直接选择镜像文件和启动盘，一键制作即可完成。另一种是一款免费的第三方启动盘制作工具Etcher，安装和使用方法如下：</p><p>1.在<a href="https://www.balena.io/etcher/">官网</a>找到下载链接，找到自己对应系统的AppImage下载；</p><p>2.unzip解压下载的zip文件；</p><p>3.运行<code>./xxxxx.AppImage</code>即可启动；</p><p>4.选择镜像，选择U盘，等待完成即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何在ubuntu电脑上制作ubuntu server 18.04的启动盘，并安装系统和基础环境。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="ubuntu基础环境" scheme="https://zsh4614.cn/tags/ubuntu%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>C++中的非常量引用不能指向临时对象</title>
    <link href="https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E6%8C%87%E5%90%91%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E6%8C%87%E5%90%91%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-10-30T10:07:28.000Z</published>
    <updated>2021-12-01T17:30:30.010Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍为什么C++标准规定非常量引用不能指向临时对象，以及什么情况下会产生临时对象。</p><span id="more"></span><h3 id="举例">举例</h3><p>非常量引用指向临时对象 —— 即：将临时对象传递给非常量引用类型。比如以下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Rational类中定义如下</span></span><br><span class="line"><span class="comment">//重载2个操作符函数：“+”号和“&lt;&lt;” 输出符号</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt; (ostream&amp; outs,Rational &amp;rational);</span><br><span class="line">Rational <span class="keyword">operator</span>+(Rational &amp;secondRational);</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a+b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>a+b 函数返回一个Rational类的临时对象；而 &lt;&lt; 操作函数的参数却是 Rational &amp; rational 。这种情况函数会报错如下：</p><p><code>no match for 'operator&lt;&lt;' in 'std::cout &lt;&lt; a.Rational::operator+(((Rational&amp;)(&amp; b)))'</code></p><p>虽然定义了 operator&lt;&lt; 。但是编译器对 a+b 返回的临时对象不买单，直接报了个“没有匹配的函数” 的错误。</p><h3 id="分析">分析</h3><p>以C++的语义来说，如果一个程序员只想传递参数给函数，而不希望函数修改传入的参数时，那么，或者使用值传递，或者采用常量型引用。考虑到大对象复制时产生的开销，一般使用常量型引用const &amp;。如果函数的参数是某个类型的一个非常量的引用，那就相当于告诉编译器，程序员希望得到函数对参数的修改结果。<br>临时变量是由编译器生成的，C++语言规范没规定编译器生成临时变量的规则，程序员无法得知由编译器生成的临时变量的名字，程序员无法访问那个临时变量。这意味着，以引用的方式传递一个临时变量做为函数参数，如果函数内部对此临时变量做了修改，那么函数返回后，程序员无法获得函数对临时变量的修改。函数对临时变量所做出的所有更改，都将丢失。</p><p>一方面，在函数申明中，使用非常量型的引用告诉编译器你需要得到函数对某个对象的修改结果，可是你自己又不给变量起名字，直接丢弃了函数的修改结果，编译器只能说：“大哥，你这是干啥呢，告诉我把结果给你，等我把结果给你了，你又直接给扔了，你这不是在玩我吗？”</p><p>同时，C++的标准 为了防止给常量或临时变量（只有瞬间的生命周期）赋值(易产生bug)，只许使用const引用之。</p><h3 id="解决">解决</h3><p>有两种解决办法，一是将非常量引用改为值传递，二是改为常量引用。</p><h3 id="临时对象">临时对象</h3><p>c++中的临时对象是看不见的，它不出现在源码中。建立一个未命名的非堆对象会产生一个临时对象，临时对象会在以下几种情况下出现。</p><h4 id="以值传递的方式给函数传参">以值传递的方式给函数传参</h4><p>按值传递时，首先将需要传给函数的参数，调用拷贝构造函数创建一个副本，这个副本就是临时变量，所有在函数里的操作都是针对这个副本，也正是因为这个原因，在函数体里对该副本进行任何操作都不会影响原参数。（关于临时对象的生命周期，并不是用过之后立马析构，其生命周期根据实际情况确定，比如这种情况，其生命周期可能存在于正割函数体内，又比如一个常量引用指向的临时对象，其声明周期由该常量引用的声明周期决定）</p><p>这也是<a href="http://zsh4614.cn/2021/04/13/%E8%AF%A6%E8%A7%A3C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/">拷贝构造函数不能为值传递</a>的原因，因为值传递会创建临时对象，而临时对象的创建仍然要调用拷贝构造函数，这样就会递归调用下去，造成栈溢出。</p><h4 id="隐式类型转换">隐式类型转换</h4><p>这种情况比较容易理解。</p><h4 id="函数返回对象">函数返回对象</h4><p>当函数需要返回一个对象，由于这个对象的生命周期只存在于函数体内部，所以它会在栈中创建一个临时对象（调用拷贝构造函数），存储函数的返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Assign operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">do</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p</span><br><span class="line">    p = <span class="built_in"><span class="keyword">do</span></span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况就会调用一次拷贝构造函数在栈上创建一个临时对象，然后调用赋值运算符将该临时对象复制给p。</p><h4 id="手动调用构造函数">手动调用构造函数</h4><p>**这里的手动调用指的是代码上显式调用而非编译器自己调用，**如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cls</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cls</span>() &#123;</span><br><span class="line">        <span class="built_in">cls</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cls c;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会打印出预期之外的结果，因为在调用cls(0)时，其实产生了一个cls类的临时对象，这个临时对象，而我们希望的是初始化对象c的成员a，但这里初始化的是临时对象的a。可以改成<code>*this = cls(0);</code>，这其实是和如下代码一个原理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line">cls a = <span class="built_in">cls</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>看起来调用了两次拷贝构造函数，临时对象一次，构造a一次，但实际上编译器做了如下优化，只调用了一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍为什么C++标准规定非常量引用不能指向临时对象，以及什么情况下会产生临时对象。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="临时对象" scheme="https://zsh4614.cn/tags/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="引用" scheme="https://zsh4614.cn/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：基于行程的连通域标记算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%A8%8B%E7%9A%84%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%A8%8B%E7%9A%84%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T09:08:18.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文介绍一种用于二值图像或者占空图的聚类算法，并给出c++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>Two-Pass算法是一种基于行程的二值图像连通域标记算法，matlab中连通区域标记函数bwlabel中使用的就是该算法，其算法流程如下：</p><blockquote><p>1，逐行扫描图像，我们把每一行中连续的白色像素组成一个序列称为一个团(run)，并记下它的起点start、它的终点end以及它所在的行号。</p><p>2，对于除了第一行外的所有行里的团，如果它与前一行中的所有团都没有重合区域，则给它一个新的标号；如果它仅与上一行中一个团有重合区域，则将上一行的那个团的标号赋给它；如果它与上一行的2个以上的团有重叠区域，则给当前团赋一个相连团的最小标号，并将上一行的这几个团的标记写入等价对，说明它们属于一类。</p><p>3，将等价对转换为等价序列，每一个序列需要给一相同的标号，因为它们都是等价的。从1开始，给每个等价序列一个标号。</p><p>4，遍历开始团的标记，查找等价序列，给予它们新的标记。</p><p>5，将每个团的标号填入标记图像中。</p><p>6，结束。</p></blockquote><h3 id="实现">实现</h3><p>下面给出其c++实现，主要分四步进行：</p><p>第一步：查找所有团并记录，需要记录团所在的行号、团开始的位置、结束的位置，当然还有一个表征团总数的变量。需要注意的就是团开始位置和结束位置在行首和行末的情况要单独拿出来考虑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillRunVectors</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bimage, <span class="keyword">int</span>&amp; NumberOfRuns, std::vector&lt;<span class="keyword">int</span>&gt;&amp; stRun, std::vector&lt;<span class="keyword">int</span>&gt;&amp; enRun, std::vector&lt;<span class="keyword">int</span>&gt;&amp; rowRun, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rows, <span class="keyword">const</span> <span class="keyword">int</span>&amp; cols, std::vector&lt;<span class="keyword">int</span>&gt;&amp; label_map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; rowData = bimage[i];</span><br><span class="line">        <span class="keyword">if</span> (rowData[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            NumberOfRuns++;</span><br><span class="line">            stRun.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">            rowRun.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            label_map[i * cols] = NumberOfRuns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_idx = i * cols + j;</span><br><span class="line">            <span class="keyword">if</span> (rowData[j<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; rowData[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                NumberOfRuns++;</span><br><span class="line">                stRun.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                rowRun.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                label_map[cur_idx] = NumberOfRuns;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowData[j<span class="number">-1</span>] == <span class="number">1</span> &amp;&amp; rowData[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                enRun.<span class="built_in">emplace_back</span>(j<span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowData[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                label_map[cur_idx] = NumberOfRuns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowData[cols - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            enRun.<span class="built_in">emplace_back</span>(cols - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：遍历所有的团，完成团的标记与等价对列表的生成。这里判断团是否相邻的关键条件是：一个团的开始位置小于另一个团的结束位置，且结束位置大于另一个团的开始位置。 这里的equivalences 用于存储等价对，offset：0对应四连通，1对应八连通。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stRun, vector&lt;<span class="keyword">int</span>&gt;&amp; enRun, vector&lt;<span class="keyword">int</span>&gt;&amp; rowRun, <span class="keyword">int</span> NumberOfRuns, vector&lt;<span class="keyword">int</span>&gt;&amp; runLabels, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; equivalences, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idxLabel = <span class="number">1</span>;    <span class="comment">// 标记编号</span></span><br><span class="line">    <span class="keyword">int</span> curRowIdx = <span class="number">0</span>;    <span class="comment">// 当前所在行   </span></span><br><span class="line">    <span class="keyword">int</span> firstRunOnCur = <span class="number">0</span>;    <span class="comment">// 当前行的第一个团索引</span></span><br><span class="line">    <span class="keyword">int</span> firstRunOnPre = <span class="number">0</span>;    <span class="comment">// 前一行的第一个团索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRunOnPre = <span class="number">-1</span>;    <span class="comment">// 前一行的最后一个团索引</span></span><br><span class="line">    <span class="comment">// 初始化每个团的标签都为0</span></span><br><span class="line">    runLabels.<span class="built_in">assign</span>(NumberOfRuns, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfRuns; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rowRun[i] != curRowIdx) &#123;</span><br><span class="line">            <span class="comment">// 换行后更新状态变量</span></span><br><span class="line">            curRowIdx = rowRun[i];</span><br><span class="line">            firstRunOnPre = firstRunOnCur;</span><br><span class="line">            lastRunOnPre = i - <span class="number">1</span>;</span><br><span class="line">            firstRunOnCur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相邻行不存在团</span></span><br><span class="line">        <span class="keyword">if</span>（curRowIdx != rowRun[lastRunOnPre] + <span class="number">1</span>） &#123;</span><br><span class="line">            runLabels[i] = idxLabel++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对前一行进行遍历，检查是否有相邻的团</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = firstRunOnPre; j &lt;= lastRunOnPre; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stRun[i] &lt;= enRun[j] + offset &amp;&amp; enRun[i] &gt;= stRun[j] - offset) &#123;</span><br><span class="line">                <span class="comment">// 之前没有被标记过，即j是上一行第一个与当前团相邻的</span></span><br><span class="line">                <span class="keyword">if</span> (runLabels[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    runLabels[i] = runLabels[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLabels[i] != runLabels[j]) &#123;</span><br><span class="line">                    equalLabels.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_pair</span>(runLabels[i], runLabels[j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有与前一列如何run重合</span></span><br><span class="line">        <span class="keyword">if</span> (runLabels[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            runLabels[i] = idxLabel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：将等价对处理成等价序列，比如有如下等价对：(1,2),(1,6),(3,7),(9-3),(8,1),(8,10),(11,5),(11,8),(11,12),(11,13),(11,14),(15,11)，得到的最终序列是：</p><p>list1：1-2-5-6-8-10-11-12-13-14-15</p><p>list2：3-7-9</p><p>list3：4</p><p>这里还是采用DFS思想，c++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSameLabel</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; runLabels, std::vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; equivalence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLabel = *std::<span class="built_in">max_element</span>(runLabels.<span class="built_in">begin</span>(), runLabels.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 等价标签矩阵，值为true表示这两个标签等价</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">eqTab</span>(maxLabel, std::vector&lt;<span class="keyword">bool</span>&gt;(maxLabel, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 将等价对信息转移到矩阵上</span></span><br><span class="line">    std::vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator vecPairIt = equivalence.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (vecPairIt != equivalence.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        eqTab[vecPairIt-&gt;first - <span class="number">1</span>][vecPairIt-&gt;second - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        eqTab[vecPairIt-&gt;second - <span class="number">1</span>][vecPairIt-&gt;first - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        vecPairIt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标签映射，会将上一步团的标号映射到序列的标号，也是这一步的关键结果。</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">labelFlag</span><span class="params">(maxLabel, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 等价标签队列</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; tempList;</span><br><span class="line">    <span class="comment">// 当前使用的标签</span></span><br><span class="line">    <span class="keyword">int</span> curLabel = <span class="number">1</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxLabel; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果该标签已被映射，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (labelFlag[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        labelFlag[i - <span class="number">1</span>] = curLabel;</span><br><span class="line">        tempList.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="comment">// 在所有标签中寻找与当前标签等价的标签(这里可以换成栈操作，和floodfill类似) </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tempList.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= maxLabel; ++k) &#123;</span><br><span class="line">                <span class="comment">// 等价且未访问</span></span><br><span class="line">                <span class="keyword">if</span> (eqTab[tempList[j] - <span class="number">1</span>][k - <span class="number">1</span>] &amp;&amp; labelFlag[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                   labelFlag[k - <span class="number">1</span>] = curLabel;</span><br><span class="line">                   tempList.<span class="built_in">emplace_back</span>(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curLabel++;</span><br><span class="line">        tempList.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据映射修改标签</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = runLabels.<span class="built_in">begin</span>(); itr != runLabels.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        *itr = labelFlag[*itr - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：填充二值图中每个栅格的标签。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillLabel</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; runLabels, std::vector&lt;<span class="keyword">int</span>&gt;&amp; label_map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; label_map.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (label_map[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        label_map[i] = runLabels[label_map[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>该算法本质上和floodFill算法是一样的，区别在于floodFill是对每个栅格进行深度优先搜索，而这个是对团进行深度优先搜索。另外，在算法的第三步在对等价对进行合并时，可以用并查集进行优化，也可以用稀疏矩阵与Dulmage-Mendelsohn分解算法用来消除等价对（matlab中的做法），比较复杂。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文介绍一种用于二值图像或者占空图的聚类算法，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
    <category term="聚类" scheme="https://zsh4614.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
    <category term="连通域标记" scheme="https://zsh4614.cn/tags/%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A0%87%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：简化的漫水填充算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AE%80%E5%8C%96%E7%9A%84%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AE%80%E5%8C%96%E7%9A%84%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T09:04:46.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文介绍简化的漫水填充算法，用于二值图像聚类或者点云栅格聚类，并给出了c++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>floodFill，又叫seedfill，译作漫水填充算法，或者泛洪算法，其在opencv中进行了实现，参考<a href="https://github.com/opencv/opencv/blob/master/modules/imgproc/src/floodfill.cpp">这里</a>。</p><p>漫水填充法是一种用特定的颜色填充联通区域，通过设置可连通像素的上下限以及连通方式来达到不同的填充效果的方法。漫水填充经常被用来标记或分离图像的一部分以便对其进行进一步处理或分析，简而言之，漫水填充就是查找和种子点联通的颜色相同或者相近的点，ps的魔棒工具就是以该算法为基础的。</p><p>对于点云栅格化后的二值占空图，也可以采用该算法查找出与种子栅格联通的栅格，遍历所有种子点（非空点），就可以得到不同的簇。</p><h3 id="实现">实现</h3><p>下面给出该算法对二值图进行聚类的c++实现，其实质是一个DFS，优先地寻找一个完整连通域，在找的同时把他们都标记一下，找完一个完整连通域， 再去找下一个连通域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cols = <span class="number">2048</span>, rows = <span class="number">1024</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">seed_map</span><span class="params">(cols * rows, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 遍历点云初始化seed_map，有点为1，无点为0</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; label_map;</span><br><span class="line">label_map.<span class="built_in">resize</span>(cols * rows, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> tot_num_obj = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = row * cols + col;</span><br><span class="line">        <span class="keyword">if</span> (seed_map[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;    <span class="comment">// 跳过空栅格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (label_map[idx] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;    <span class="comment">// 跳过已经被标记的栅格</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::stack&lt;Eigen::Vector2i&gt; neighbor_grids;</span><br><span class="line">        Eigen::Vector2i tmp_grid;</span><br><span class="line">        tmp_grid &lt;&lt; col, row;</span><br><span class="line">        neighbor_grids.<span class="built_in">push</span>(tmp_grid);</span><br><span class="line">        tot_num_obj++;</span><br><span class="line">        label_map[idx] = tot_num_obj;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!neighbor_grids.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Eigen::Vector2i cur_grid = neighbor_grids.<span class="built_in">top</span>();</span><br><span class="line">            neighbor_grids.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_grid.x - <span class="number">1</span>; i &lt;= cur_grid.x + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= cols) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = cur_grid.y - <span class="number">1</span>; j &lt;= cur_grid.y + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt;= rows) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> tmp_idx = j * cols + i;</span><br><span class="line">                    <span class="keyword">if</span> (seed_map[tmp_idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (label_map[tmp_idx] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    label_map[tmp_idx] = tot_num_obj;</span><br><span class="line">                    tmp_grid &lt;&lt; i, j;</span><br><span class="line">                    neighbor_grids.<span class="built_in">push</span>(tmp_grid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样就对二值占空图的每个栅格进行了标记，得到了多个簇。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文介绍简化的漫水填充算法，用于二值图像聚类或者点云栅格聚类，并给出了c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
    <category term="聚类" scheme="https://zsh4614.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
    <category term="floodfill" scheme="https://zsh4614.cn/tags/floodfill/"/>
    
  </entry>
  
  <entry>
    <title>Hexo在多台电脑上维护github个人主页</title>
    <link href="https://zsh4614.cn/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%BB%B4%E6%8A%A4github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    <id>https://zsh4614.cn/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%BB%B4%E6%8A%A4github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</id>
    <published>2021-10-30T07:27:04.000Z</published>
    <updated>2021-12-01T17:30:30.011Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何在两台（多台）电脑上维护自己的github pages博客。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>总体方法是利用git分支实现。hexo生成的静态博客文件默认放在master分支上，可以新建一个分支用来存放源文件，在其他电脑上只需要git clone这个分支即可进行更新和发布等操作。</p><h3 id="环境">环境</h3><p>在操作之前，先在新电脑上安装好hexo需要的环境：</p><p><strong>安装npm和node.js:</strong></p><p>到<a href="https://nodejs.org/dist/latest/">官网</a>下载最新的压缩包，解压后在bin目录下有npm和node的可执行文件，但是安装路径没有在系统环境变量中，所以添加到系统环境中，有多种方法，这里我进行了软链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure><p><strong>安装hexo：</strong></p><p>直接使用npm安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>同样需要加到系统环境中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure><h3 id="步骤">步骤</h3><p>1.给github博客仓库新建一个hexo分支，设置为默认分支。</p><p>2.将当前电脑的ssh key添加到github上。</p><p>3.执行git clone命令将hexo克隆到本地，将除了.git的文件全部删除，然后add-commit-push更新到远程。</p><p>4.将原来博客根目录下（即包含themes、source等文件夹的那个目录）所有文件拷贝到本地hexo分支文件夹。</p><p>5.删除themes文件夹每个主题的.git文件夹和.gitignore文件。</p><p>6.执行add-commit-push更新到远程。</p><p>7.之后在任何配置好博客环境的电脑上都采用如下操作维护博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pull-add-commit-push</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何在两台（多台）电脑上维护自己的github pages博客。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="个人主页" scheme="https://zsh4614.cn/tags/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    
  </entry>
  
</feed>
