<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到我的主页!</title>
  
  
  <link href="https://zsh4614.cn/atom.xml" rel="self"/>
  
  <link href="https://zsh4614.cn/"/>
  <updated>2021-12-01T17:30:30.010Z</updated>
  <id>https://zsh4614.cn/</id>
  
  <author>
    <name>zsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11之匿名函数</title>
    <link href="https://zsh4614.cn/C-11%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://zsh4614.cn/C-11%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-19T04:00:12.000Z</published>
    <updated>2021-12-01T17:30:30.010Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍C++11新特性的lambda函数用法。</p><span id="more"></span><h3 id="语法格式及含义">语法格式及含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>[外部变量访问方式说明符]</li></ul><p>[]是lambda表达式标识符，不可省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量。所谓外部变量，指的是和当前 lambda 表达式<strong>位于同一作用域内的所有局部变量</strong>。注意区分外部变量和全局变量。外部变量格式有如下几种书写方式：</p><table><thead><tr><th>外部变量格式</th><th>功能</th></tr></thead><tbody><tr><td>[]</td><td>空方括号表示当前 lambda 匿名函数中<strong>不导入</strong>任何外部变量。</td></tr><tr><td>[=]</td><td>只有一个 = 等号，表示以值传递的方式<strong>导入所有</strong>外部变量；</td></tr><tr><td>[&amp;]</td><td>只有一个 &amp; 符号，表示以引用传递的方式<strong>导入所有</strong>外部变量；</td></tr><tr><td>[val1,val2,…]</td><td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td></tr><tr><td>[&amp;val1,&amp;val2,…]</td><td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td></tr><tr><td>[val,&amp;val2,…]</td><td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td></tr><tr><td>[=,&amp;val1,…]</td><td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td></tr><tr><td>[&amp;,val1,…]</td><td>表示除 val1 以值传递的方式导入外，其它外部变量都以引用传递的方式导入。</td></tr><tr><td>[this]</td><td>表示以值传递的方式导入当前的 this 指针。</td></tr></tbody></table><blockquote><p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p></blockquote><ul><li>(参数)</li></ul><p>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，<strong>如果不需要传递参数，可以连同 () 小括号一起省略</strong>；</p><ul><li>mutable</li></ul><p>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。（修改的是拷贝的那一份，并不会修改真正的外部变量）</p><ul><li>noexcept/throw()</li></ul><p>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败。</p><ul><li>-&gt; 返回值类型</li></ul><p>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略。</p><ul><li>函数体</li></ul><p>除了可以使用传入参数外，还可以使用指定的外部变量和全局变量。（外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍C++11新特性的lambda函数用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="lambda函数" scheme="https://zsh4614.cn/tags/lambda%E5%87%BD%E6%95%B0/"/>
    
    <category term="匿名函数" scheme="https://zsh4614.cn/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：拉默-道格拉斯-普克算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/</id>
    <published>2021-11-18T07:56:45.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍RDP算法。道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。</p><span id="more"></span><h3 id="算法步骤">算法步骤</h3><ol><li>连接曲线首尾两点A、B形成一条直线AB；<br>2. 计算曲线上离该直线段距离最大的点C，计算其与AB的距离d；</li><li>比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则以该直线作为曲线的近似，该段曲线处理完毕。</li><li>如果距离大于阈值，则用点C将曲线分为两段AC和BC，并分别对两段曲线进行步骤[1~3]的处理。</li><li>当所有曲线都处理完毕后，依次连接各个分割点形成折线，作为原曲线的近似。</li></ol><h3 id="实现">实现</h3><h4 id="实现一">实现一</h4><p>下面采用 C++实现，是一个DFS深搜的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; in_pts, </span></span></span><br><span class="line"><span class="function"><span class="params">         std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">float</span> epsilon = <span class="number">0.1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = in_pts.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">mask</span><span class="params">(size, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    std::pair&lt;int, int&gt; pts_pair(0, size-1);</span><br><span class="line">    std::stack&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(pts_pair);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur_pair = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">float</span> dmax = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur_pair.first + <span class="number">1</span>; i &lt; cur_pair.second; ++i) &#123;</span><br><span class="line">            <span class="keyword">float</span> d = <span class="built_in">getPerpendicularDistance</span>(in_pts[cur_pair.first], in_pts[cur_pair.second], in_pts[i]);</span><br><span class="line">            <span class="keyword">if</span> (d &gt; dmax) &#123;</span><br><span class="line">                dmax = d;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dmax &gt; epsilon) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cur_pair.first, i));</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, cur_pair.second));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mask[cur_pair.first] = <span class="literal">true</span>;</span><br><span class="line">            mask[cur_pair.second] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(size);</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i]) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPerpendicularDistance()函数是求点到线的距离函数，有两种方法，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：利用点到直线的距离公式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, maxDist = <span class="number">0</span>;</span><br><span class="line">    A = lineEnd.y - lineStart.y;</span><br><span class="line">    B = lineStart.x - lineEnd.x;</span><br><span class="line">    C = lineEnd.x * lineStart.y - lineStart.x * lineEnd.y;</span><br><span class="line">    maxDist = <span class="built_in">fabs</span>((A * pt.x + B * pt.y + C) / <span class="built_in">sqrt</span>(A * A + B *B));</span><br><span class="line">    <span class="keyword">return</span> maxDist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：利用向量运算</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = lineEnd.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> dy = lineEnd.y - lineStart.y;</span><br><span class="line">    <span class="keyword">float</span> mag = std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(dx, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(dy, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (mag &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        dx /= mag;</span><br><span class="line">        dy /= mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> pvx = pt.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> pvy = pt.y - lineStart.y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> pvdot = dx * pvx + dy * pvy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> dsx = pvdot * dx;</span><br><span class="line">    <span class="keyword">float</span> dsy = pvdot * dy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> ax = pvx - dsx;</span><br><span class="line">    <span class="keyword">float</span> ay = pvy - dsy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(ax, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(ay, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现二">实现二</h4><p>有时需要对polygon（闭合）的点数进行限制，抽取出固定数量的点，这种情况下，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifiedRDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt; &amp;in_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> n_pts = <span class="number">64</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>()) &lt;= n_pts) &#123;</span><br><span class="line">        out_pts = in_pts;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SimData</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l_idx;</span><br><span class="line">        <span class="keyword">int</span> r_idx;</span><br><span class="line">        <span class="keyword">float</span> epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">std::vector&lt;SimData&gt; <span class="title">mask</span><span class="params">(in_pts.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;sim_data = mask[i];</span><br><span class="line">        sim_data.l_idx = i - <span class="number">1</span>;</span><br><span class="line">        sim_data.r_idx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            sim_data.l_idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i) == <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            sim_data.r_idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sim_data.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[i], in_pts[sim_data.l_idx], in_pts[sim_data.r_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> comp = [](<span class="keyword">const</span> SimData &amp;i, <span class="keyword">const</span> SimData &amp;j) &#123;</span><br><span class="line">        <span class="keyword">return</span> i.epsilon &lt; j.epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (cc &gt; n_pts) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = std::<span class="built_in">min_element</span>(mask.<span class="built_in">begin</span>(), mask.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(std::<span class="built_in">distance</span>(mask.<span class="built_in">begin</span>(), res));</span><br><span class="line">        <span class="comment">// 找到距离最小的点，标记并把其距离置为无穷大</span></span><br><span class="line">        maks[idx].flag = <span class="literal">false</span>;</span><br><span class="line">        mask[idx].epsilon = std::numeric_limits&lt;<span class="keyword">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        cc--;</span><br><span class="line">        <span class="comment">// 更新该点的左右邻居</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;l_mask = mask[res-&gt;l_idx];</span><br><span class="line">        l_mask.r_idx = res-&gt;r_idx;</span><br><span class="line">        l_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;l_idx], in_pts[l_mask.l_idx], in_pts[l_mask.r_idx]);</span><br><span class="line">        <span class="keyword">auto</span> &amp;r_mask = mask[res-&gt;r_idx];</span><br><span class="line">        r_mask.l_idx = res-&gt;l_idx;</span><br><span class="line">        r_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;r_idx], in_pts[r_mask.l_idx], in_pts[r_mask.l_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i].flag) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>本文主要总结了RDP算法的dfs实现，其原始版本是递归实现的，至于那个版本的实现更快，还需要进一步论述，但是在工程代码中，不推荐使用递归；点到直线的距离计算效率，也需要benchmark进行测试比较。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍RDP算法。道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
    <category term="几何算法" scheme="https://zsh4614.cn/tags/%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95/"/>
    
    <category term="拉默-道格拉斯-普克算法" scheme="https://zsh4614.cn/tags/%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>粗浅理解</title>
    <link href="https://zsh4614.cn/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <id>https://zsh4614.cn/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/</id>
    <published>2021-11-17T03:12:28.000Z</published>
    <updated>2021-12-01T17:30:30.016Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要总结对于机器学习和深度学习领域一些比较片面粗浅的理解，包含的范围比较杂乱，在此做一个记录。</p><span id="more"></span><h3 id="一、对于CNN和Transformer的对比">一、对于CNN和Transformer的对比</h3><p>CNN使用了较强的归纳偏置（inductive biases）:</p><ul><li>权重共享，图像不同部分以相同方式处理，位置不敏感；</li><li>由于卷积算子的性质，卷积的特征图具有局部敏感性,也就是每次卷积操作只会考虑原始数据的一小部分的局部信息。</li></ul><p>因此，CNN 的归纳偏置缺乏对输入数据本身的整体把握。它很擅长提取局部的有效信息，但是没能提取全局数据之间的长距离特征。</p><p>相比之下，基于自注意力机制的Transformer模型最小化了归纳偏置。当在大数据集上进行训练时，这些模型的性能已经可以媲美甚至超过 CNN 。但在小数据集上训练时，它们往往很难学习有意义的表征。可以说，CNN在小数据集上表现较为突出，因为预先强加了归纳偏置，可以让网络一开始就朝着比较正确的方向学习，但当数据量增大时，可能由于这些归纳偏置，导致其达到一个上限，而Transformer没有，所以对数据非常饥渴，但同时上限也很高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要总结对于机器学习和深度学习领域一些比较片面粗浅的理解，包含的范围比较杂乱，在此做一个记录。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zsh4614.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式：单例模式</title>
    <link href="https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-16T08:16:09.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍设计模式中的单例模式，并给出C++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>单例模式也称为单件模式、单子模式，可能是使用最广泛的设计模式。其意图是**保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。**有很多地方需要这样的功能模块，如系统的日志输出，操作系统只能有一个任务管理器，一台PC连一个键盘，工程中的通用配置类等。</p><h3 id="实现">实现</h3><h4 id="实现一">实现一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先检查对象是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(); <span class="comment">//私有构造函数，不允许使用者自己生成对象</span></span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance; <span class="comment">//静态成员变量 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户访问唯一实例的方法只有getInstance()成员函数。如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的。getInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的 。这是一种防弹设计——所有getInstance()之后的调用都返回相同实例的指针。</p><p>这种实现方法有以下几个特点：</p><ul><li>它有一个指向唯一实例的静态指针m_instance，并且是私有的；</li><li>它有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；</li><li>它的构造函数是私有的，这样就不能从别处创建该类的实例。</li></ul><p>但是这种实现方法存在两个问题：一是m_instance指向的空间是动态分配的，需要显式进行释放；二是这种方法不是线程安全的。对于第一个问题，可能有人会说，直接在析构函数中进行delete就可以释放了啊，但是这样会存在问题，因为**在类的析构函数中delete类自身实例的指针，delete又会调用析构函数，这样就会出现循环调用的问题，会造成栈内存溢出，因此编译器不允许这么做。**下面我们针对这两个问题一一进行分析</p><h4 id="实现二">实现二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_instance;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>   //它的唯一工作就是在析构函数中删除<span class="title">CSingleton</span>的实例</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGarbo</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Singleton::m_instance)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;  <span class="comment">//定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个妥善的方法是让这个类自己知道在合适的时候把自己删除，或者说把删除自己的操作挂在操作系统中的某个合适的点上，使其在恰当的时候被自动执行。我们知道，程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如上面的代码中的CGarbo类（Garbo意为垃圾工人），类CGarbo被定义为Singleton的私有内嵌类，以防该类被在其他地方滥用。<br>程序运行结束时，系统会调用Singleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。<br>使用这种方法释放单例对象有以下特征：</p><ul><li>在单例类内部定义专有的嵌套类；</li><li>在单例类内定义私有的专门用于释放的静态成员；</li><li>利用程序在结束时析构全局变量的特性，选择最终的释放时机；</li><li>使用单例的代码不需要任何操作，不必关心对象的释放。</li></ul><h4 id="实现三">实现三</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现二中添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如上，使用<strong>局部静态变量</strong>，非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。但使用此种方法也会出现问题，当如下方法使用单例时问题来了：</p><p><code>Singleton singleton = Singleton :: getInstance();</code></p><p>这么做就出现了一个类拷贝的问题，这就违背了单例的特性。产生这个问题原因在于：编译器会为类生成一个默认的拷贝构造函数，来支持类的拷贝。最后没有办法，我们要禁止类拷贝和类赋值，禁止程序员用这种方式来使用单例，所以可以让getInstance()返回一个指针，代码变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以显式禁用类的拷贝构造函数和赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现四">实现四</h4><p>我们从头到尾都还没考虑线程安全问题，但是如果使用实现三的方法，就避免了线程安全，这是因为：<strong>在c++ 11新标准中，静态局部变量是线程安全的</strong>。所以最终的单例模式实现版本为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍设计模式中的单例模式，并给出C++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式（C++）" scheme="https://zsh4614.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    
    
    <category term="静态局部变量" scheme="https://zsh4614.cn/tags/%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="单例模式" scheme="https://zsh4614.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习：几何绘制</title>
    <link href="https://zsh4614.cn/OpenCV%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%87%A0%E4%BD%95%E7%BB%98%E5%88%B6/"/>
    <id>https://zsh4614.cn/OpenCV%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%87%A0%E4%BD%95%E7%BB%98%E5%88%B6/</id>
    <published>2021-11-10T07:15:40.000Z</published>
    <updated>2021-12-01T17:30:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍OpenCV中的部分几何绘制函数的用法，包括：圆，椭圆，矩形，直线，填充多边形。</p><span id="more"></span><h3 id="示例">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> w 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span></span>;</span><br><span class="line"><span class="comment">// 入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cv::Mat atom_image = cv::Mat::zeros(h, w, CV_8UC3);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 0);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 90);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 45);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, -45);</span></span><br><span class="line"><span class="comment">    MyCircle(atom_image, cv::Point(w/2, w/2));</span></span><br><span class="line"><span class="comment">    cv::imshow(&quot;ellipse&quot;, atom_image);</span></span><br><span class="line"><span class="comment">    cv::waitKey();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 注意这里是 h,w 的格式</span></span><br><span class="line">    cv::Mat rook_image = cv::Mat::<span class="built_in">zeros</span>(h, w, CV_8UC3);</span><br><span class="line">    <span class="built_in">MyPolygon</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyRectangle</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">0</span>, <span class="number">15</span>*w/<span class="number">16</span> ), cv::<span class="built_in">Point</span>( w, <span class="number">15</span>*w/<span class="number">16</span> ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, w ) );</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;rook&quot;</span>, rook_image);</span><br><span class="line">    <span class="comment">// 窗口显示在屏幕上的位置</span></span><br><span class="line">    cv::<span class="built_in">moveWindow</span>(<span class="string">&quot;rook&quot;</span>, <span class="number">2000</span>, <span class="number">800</span> );</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 椭圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = <span class="number">4</span>;</span><br><span class="line">    cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">                cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">                angle,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">360</span>,</span><br><span class="line">                cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">                thickness,</span><br><span class="line">                lineType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">circle</span>(img,</span><br><span class="line">               center,</span><br><span class="line">               w/<span class="number">32</span>,</span><br><span class="line">               cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">               <span class="number">2</span>,</span><br><span class="line">               <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                  cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                  cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                  cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                  <span class="number">-1</span>,</span><br><span class="line">                  <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意多边形填充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Create some points */</span></span><br><span class="line">  cv::Point rook_points[<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">0</span>]  = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">1</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">2</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">3</span>]  = cv::<span class="built_in">Point</span>( <span class="number">11</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">4</span>]  = cv::<span class="built_in">Point</span>( <span class="number">19</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">5</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">6</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">7</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">8</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">9</span>]  = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">10</span>] = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">11</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">12</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">13</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">14</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">15</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">16</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">17</span>] = cv::<span class="built_in">Point</span>( <span class="number">13</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">18</span>] = cv::<span class="built_in">Point</span>(  <span class="number">5</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">19</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ppt为二级指针（rook_points[0]是一个指针，所以ppt是一个指针数组，数组名是指向数组的指针）</span></span><br><span class="line">  <span class="keyword">const</span> cv::Point* ppt[<span class="number">1</span>] = &#123;rook_points[<span class="number">0</span>]&#125;;</span><br><span class="line">  <span class="keyword">int</span> npt[] = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">  cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><p>1.椭圆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">            cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">            cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">            angle,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">360</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">            thickness,</span><br><span class="line">            lineType);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>cv::Point(w/2, w/2)：椭圆心</p><p>cv::Size(w/4, w/16)：焦距</p><p>angle：旋转角度（不是弧度），注意是图像坐标系，右是正x，下是正y</p><p>angle_begin：圆弧的起始角度（不是弧度）</p><p>angle_end：圆弧的结束角度（不是弧度）</p><p>cv::Scalar( 255, 0, 0 )：颜色，BGR顺序</p><p>thickness：线宽， -1代表填充</p><p>lineType：线型，16是抗锯齿的线型，看起来边缘更平滑。可选-1，4， 8， 16，关于四邻域线型和八邻域线型，参考<a href="https://blog.csdn.net/young__fan/article/details/82696276">这里</a>。</p><p>2.圆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">circle</span>(img,</span><br><span class="line">            center,</span><br><span class="line">            w/<span class="number">32</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>center：cv::Point，圆心</p><p>w/32：int,，半径</p><p>cv::Scalar(0, 0, 255)：颜色，BGR顺序</p><p>thickness：同上</p><p>lineType：同上</p><p>3.矩形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                <span class="number">-1</span>,</span><br><span class="line">                <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>pt1：矩形左上角坐标，cv::Point</p><p>pt2：矩形右下角坐标，cv::Point</p><p>cv::Scalar(0, 255, 255)：颜色</p><p>thickness：同上</p><p>lineType：同上</p><p>4.直线（多边形）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>start：cv::Point，起始点</p><p>end：cv::Point，终止点</p><p>cv::Scalar(0, 0, 0)：颜色</p><p>thickness：同上</p><p>lineType：同上</p><p>5.填充多边形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>ppt：Array of polygons where each polygon is represented as an array of points.</p><p>npt：Array of 每个polygon的点数</p><p>ncontours：多边形数量</p><p>cv::Scalar(0, 0, 0)：颜色</p><p>lineType：同上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍OpenCV中的部分几何绘制函数的用法，包括：圆，椭圆，矩形，直线，填充多边形。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenCV" scheme="https://zsh4614.cn/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu私有仓库UI服务部署</title>
    <link href="https://zsh4614.cn/Ubuntu%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93UI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
    <id>https://zsh4614.cn/Ubuntu%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93UI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</id>
    <published>2021-11-04T03:25:15.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍利用第三方镜像部署docker私有仓库可视化界面服务的方法。</p><span id="more"></span><h3 id="方法一">方法一</h3><p>1.从官方仓库拉取第三方镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure><p>2.启动UI服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -itd -p 60022:80 --restart=always --name=docker-registry-ui -e SINGLE_REGISTRY=true -e REGISTRY_TITLE=&quot;xxxxxxxx registry&quot; -e SHOW_CONTENT_DIGEST=true -e DELETE_IMAGES=true -e NGINX_PROXY_PASS_URL=&quot;http://10.10.8.185:5000&quot; joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure><p><strong>注意：这些环境变量一个也不能错</strong></p><p>3.访问http://10.10.8.185:60022可以登录UI界面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍利用第三方镜像部署docker私有仓库可视化界面服务的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="docker" scheme="https://zsh4614.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu ssh</title>
    <link href="https://zsh4614.cn/Ubuntu-ssh/"/>
    <id>https://zsh4614.cn/Ubuntu-ssh/</id>
    <published>2021-11-04T02:56:44.000Z</published>
    <updated>2021-12-01T17:30:30.013Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍Ubuntu的ssh相关服务。</p><span id="more"></span><h3 id="设置ssh免密登录">设置ssh免密登录</h3><p>ssh-copy-id &lt;username&gt;@&lt;target_host_ip&gt;</p><p>解决按照上述操作之后还不能免密登录的方法：将<code>/etc/ssh/sshd_config</code>中的<code>StrictModes yes</code>改成no。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍Ubuntu的ssh相关服务。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="ssh" scheme="https://zsh4614.cn/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 Server安装OpenPAI v1.8.0</title>
    <link href="https://zsh4614.cn/Ubuntu18-04-Server%E5%AE%89%E8%A3%85OpenPAI-v1-8-0/"/>
    <id>https://zsh4614.cn/Ubuntu18-04-Server%E5%AE%89%E8%A3%85OpenPAI-v1-8-0/</id>
    <published>2021-11-04T02:25:57.000Z</published>
    <updated>2021-12-01T17:30:30.013Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何在Ubuntu18.04上安装OpenPAI v1.8.0。</p><span id="more"></span><h3 id="环境要求">环境要求</h3><p>OpenPAI的部署要求您至少有2台独立的机器：一台dev-box机器、一台master机器和一台worker机器。master，worker必须为物理机器，dev-box可以是硬盘空间不少于40GB的虚拟机，毕竟他只有安装和维护系统的时候才用到，用物理机器太浪费了。</p><h4 id="硬件要求">硬件要求</h4><p><strong>master：</strong></p><ul><li>至少40GB内存。</li><li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li><li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li></ul><p><strong>worker：</strong></p><ul><li>至少16GB内存。</li><li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li><li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li><li>必须有Nvidia的gpu。</li></ul><h4 id="软件要求">软件要求</h4><p><strong>master：</strong></p><ul><li>Ubuntu 18.04 (16.04、20.04应该可用)</li><li>SSH服务已开启。</li><li>和所有worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</li><li>Docker已被正确安装。</li><li>NTP已被成功开启。 您可以用命令<code>apt install ntp</code>来检查。</li><li>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</li></ul><p><strong>worker：</strong></p><ul><li><p>Ubuntu 16.04 (18.04、20.04应该可用，但没有经过完整测试)</p></li><li><p>SSH服务已开启。</p></li><li><p>所有master和worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</p></li><li><p>Docker已被正确安装。</p></li><li><p>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</p></li><li><p>nvidia驱动已被正确安装</p></li><li><p>nvidia-container-runtime已被正确安装，并且被设置为Docker的默认runtime。</p></li></ul><h3 id="依赖安装">依赖安装</h3><p>1.master和所有worker安装Ubuntu18.04系统。</p><p>参考这里</p><p>2.master和所有worker进行磁盘挂载。</p><p>参考这里</p><p>3.所有worker安装nvidia显卡驱动，并设置持久模式。</p><p>参考这里</p><p>4.master和所有worker安装docker。</p><p>参考这里</p><p>5.所有worker安装nvidia-container-runtime。</p><p>参考这里</p><p>6.master开启ntp服务。</p><p>7.dev-box设置免密登录master和所有worker。</p><p>参考这里</p><p>8.master部署docker私有仓库和UI服务。</p><p>参考这里</p><p>9.master和所有worker都安装unzip</p><h3 id="K8s安装OpenPAI">K8s安装OpenPAI</h3><p>该步骤的所有操作都在dev-box机器上。</p><h4 id="准备项目">准备项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;pai.git</span><br><span class="line">cd pai</span><br><span class="line">git checkout v1.8.0</span><br></pre></td></tr></table></figure><h4 id="准备离线相关文件">准备离线相关文件</h4><p>由于网络限制，部分镜像和服务需要离线下载安装。</p><p>1.下载离线文件并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:zsh4614/pai-offline.git</span><br><span class="line">cd pai-offline</span><br><span class="line">unzip pai-offline-deploy-distribute.zip</span><br></pre></td></tr></table></figure><p>2.将<code>offline-deploy-files-distribute.yml</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd pai-offline-deploy-distribute</span><br><span class="line">cp offline-deploy-files-distribute.yml &lt;pai-code-dir&gt;/contrib/kubespray</span><br></pre></td></tr></table></figure><p>3.将<code>roles/offline-deploy-files-distribute</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray/roles</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r roles/offline-deploy-files-distribute &lt;pai-code-dir&gt;/contrib/kubespray/roles</span><br></pre></td></tr></table></figure><p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/b0fcc1ad1d78a373a12c109491914b877fc2d56d/roles/download/defaults/main.yml#L2">这一行</a>可知，安装的时候下载的文件会存放在<code>/tmp/releases/</code>文件夹，故可提前下载好相关文件以避免网络问题。</p><p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/daed3e5b6a085ac99e076b51d314fcf76e4127b4/roles/kubernetes/node/tasks/install.yml#L11">这一行</a>可知，如果使用了<code>skip_downloads: true</code>参数，kubeadm默认不会在master节点安装，所以手动安装kubeadm。</p><h4 id="修改安装脚本">修改安装脚本</h4><p>1.在<code>/contrib/kubespray/quick-start-kubespray.sh</code>中添加如下一行，在安装过程中安装上述离线文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">echo &quot;Performing docker-cache config distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml docker-cache-config-distribute.yml -e &quot;@$&#123;CLUSTER_CONFIG&#125;&quot; || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Performing offline deploy file distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml offline-deploy-files-distribute.yml || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Starting kubernetes...&quot;</span><br><span class="line">/bin/bash script/kubernetes-boot.sh || exit $?</span><br></pre></td></tr></table></figure><p>2.将<code>/contrib/kubespray/docker-cache-config-distribute.yml</code>中的<code>docker_cache_host</code>的端口改成master节点的docker私有仓库端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker_cache_host: &quot;&#123;&#123; hostvars[groups[&#x27;kube-master&#x27;][0]][&#x27;ip&#x27;] &#125;&#125;:5000&quot;</span><br></pre></td></tr></table></figure><h4 id="编写参数文件">编写参数文件</h4><p>1.修改<code>/contrib/kubespray/config/config.yaml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user: &lt;your-ssh-username&gt;</span><br><span class="line">password: &lt;your-ssh-password&gt;</span><br><span class="line">docker_image_tag: v1.8.0</span><br><span class="line"></span><br><span class="line">enable_docker_cache: false</span><br><span class="line">docker_cache_storage_backend: &quot;filesystem&quot;</span><br><span class="line">docker_cache_fs_mount_path: &quot;/sda/pai/registry&quot;</span><br><span class="line">enable_marketplace: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">docker_data_root: /sda/pai/data</span><br><span class="line"></span><br><span class="line">openpai_kubespray_extra_var:</span><br><span class="line">  download_container: false</span><br><span class="line">  skip_downloads: true</span><br></pre></td></tr></table></figure><p>2.修改<code>/contrib/kubespray/config/layout.yaml</code>文件</p><p>仿照官方用例即可</p><h4 id="安装K8s">安装K8s</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd contrib/kubespray</span><br><span class="line">bash quick-start-kubespray.sh</span><br></pre></td></tr></table></figure><h4 id="安装OpenPAI">安装OpenPAI</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash quick-start-service.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何在Ubuntu18.04上安装OpenPAI v1.8.0。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="OpenPAI" scheme="https://zsh4614.cn/tags/OpenPAI/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装docker</title>
    <link href="https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85docker/"/>
    <id>https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85docker/</id>
    <published>2021-11-03T09:46:14.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍在ubuntu上安装docker的方法。</p><span id="more"></span><h3 id="docker安装">docker安装</h3><p>1.（可选）更换国内镜像源，推荐清华源或中科大源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i &#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>2.安装需要的依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br></pre></td></tr></table></figure><p>3.添加GPG密钥，需指定源（采用中科大源，采用默认的源下载速度慢，经常失败）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p>4.更新软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>5.安装docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>6.测试docker安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="nvidia-container-runtime安装">nvidia-container-runtime安装</h3><p>docker19.03之后建议使用nvidia-container-runtime取代nvidia-docker2。</p><p>1.添加GPG密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-container-runtime&#x2F;gpgkey | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>2.添加源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br></pre></td></tr></table></figure><p>3.更新软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>4.安装nvidia-container-runtime</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-container-runtime</span><br></pre></td></tr></table></figure><p>5.设置默认运行时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在/etc/docker/daemon.json中写入以下内容:</span><br><span class="line">&#123;</span><br><span class="line">&quot;default-runtime&quot;: &quot;nvidia&quot;,</span><br><span class="line">    &quot;runtimes&quot;: &#123;</span><br><span class="line">        &quot;nvidia&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.重启docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>7.验证安装成功（出现显卡信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm nvidia/cuda:10.0-base nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍在ubuntu上安装docker的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="基础环境" scheme="https://zsh4614.cn/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
    <category term="docker" scheme="https://zsh4614.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装nvidia显卡驱动</title>
    <link href="https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    <id>https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-11-03T09:34:19.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍在ubuntu系统上安装nvidia显卡驱动的方法，并优化驱动。</p><span id="more"></span><h3 id="安装显卡驱动">安装显卡驱动</h3><h4 id="方法一：ppa源">方法一：ppa源</h4><p>1.安装PPA源，根据提示按Enter执行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br></pre></td></tr></table></figure><p>2.更新源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update </span><br></pre></td></tr></table></figure><p>3.安装显卡驱动工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ubuntu-drivers-common</span><br></pre></td></tr></table></figure><p>4.查看可以安装的显卡驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu-drivers devices </span><br></pre></td></tr></table></figure><p>5.选择推荐的驱动进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-driver-470</span><br></pre></td></tr></table></figure><p>6.重启生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="开启持久模式">开启持久模式</h3><p><code>-pm --persistence-mode</code></p><p>启用持久性模式后，即使没有活动的客户端 (such as X11 or nvidia-smi)，NVIDIA 驱动程序也会保持加载状态。这样可以最大程度地减少与运行依赖的应用程序 (例如 CUDA 程序) 相关的驱动程序加载延迟。适用于所有支持 CUDA 的产品。**persistence mode 持久模式默认关闭。persistence mode 能够让 GPU 更快响应任务，待机功耗增加。关闭 persistence mode 同样能够启动任务。开机默认为关闭。**开启后可解决GPU初始化缓慢、无任务运行但是利用率居高不下、偶尔丢卡等问题。（不担心功耗的情况下尽量开启）</p><p>在<strong>18.04</strong>上设置开机默认开启的方法：</p><p>1.<code>/lib/systemd/system/rc-local.service</code>文件新增以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=rc-local.service</span><br></pre></td></tr></table></figure><p>2.设置rc-local开机自启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable rc-local</span><br></pre></td></tr></table></figure><p>3.在<code>/etc/rc.local</code>中填入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">nvidia-smi -pm 1</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>4.赋予可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><p>5.测试是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重启之后nvidia-smi看Persistence-M的状态为On，则配置成功。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍在ubuntu系统上安装nvidia显卡驱动的方法，并优化驱动。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="基础环境" scheme="https://zsh4614.cn/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
    <category term="显卡驱动" scheme="https://zsh4614.cn/tags/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu挂载磁盘</title>
    <link href="https://zsh4614.cn/Ubuntu%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98/"/>
    <id>https://zsh4614.cn/Ubuntu%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98/</id>
    <published>2021-11-03T08:28:21.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍ubuntu系统（包含desktop和server版本）挂载磁盘的方法，包括临时挂载和永久挂载。</p><span id="more"></span><h3 id="格式化磁盘">格式化磁盘</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs -t ext4 /dev/sdb</span><br></pre></td></tr></table></figure><p>-t ext4是将硬盘格式化为ext4文件系统类型。</p><h3 id="临时挂载">临时挂载</h3><p>一般情况下,我们想挂载一个分区的办法就是用mount命令,如我想把/dev/sda3挂载到/data下，使用以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda3 /data</span><br></pre></td></tr></table></figure><p>但这种方法有个不好的都方是机器<strong>重启后变又得手工重新挂载。</strong></p><h3 id="永久挂载">永久挂载</h3><p>永久性挂载分区的办法是修改分区文件/etc/fstab</p><p>常用磁盘命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.查看所有的磁盘：</span><br><span class="line">sudo fdisk -l</span><br><span class="line">2.查看某个磁盘的UUID和类型：</span><br><span class="line">sudo blkid &#x2F;dev&#x2F;sda3</span><br></pre></td></tr></table></figure><p><code>vim /etc/fstab</code>文件如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UUID=cec82a6a-c594-4bbd-b07a-af079cc670f2 /sdb ext4 defaults 0 0</span><br><span class="line">UUID=79abd6b3-c462-4fb3-9fc2-6b71eb0a8659 /sdc ext4 defaults 0 0</span><br><span class="line">UUID=bc28f3b0-bdbd-448f-b0d0-50cc499302d1 /sdd ext4 defaults 0 0</span><br><span class="line">UUID=63259855-0d99-4475-8b9d-6f19f93872b5 /sdf ext4 defaults 0 0</span><br></pre></td></tr></table></figure><p>各个字段含义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID 挂载点 文件系统类型 挂载参数 是否备份 是否检测</span><br></pre></td></tr></table></figure><p>保存后，需要重启或者执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure><p>才能生效。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍ubuntu系统（包含desktop和server版本）挂载磁盘的方法，包括临时挂载和永久挂载。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="基础环境" scheme="https://zsh4614.cn/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
    <category term="磁盘挂载" scheme="https://zsh4614.cn/tags/%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu server基础环境搭建</title>
    <link href="https://zsh4614.cn/Ubuntu%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://zsh4614.cn/Ubuntu%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-11-01T09:40:02.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何在ubuntu电脑上制作ubuntu server 18.04的启动盘，并安装系统和基础环境。</p><span id="more"></span><h3 id="制作ubuntu18-04-server的系统盘">制作ubuntu18.04 server的系统盘</h3><p>首先，在<a href="https://ubuntu.com/download/server">官网</a>或者<a href="https://ubuntu.mirror.garr.it/ubuntu-releases/18.04.6/">镜像网站</a>下载.iso镜像，这里选择稳定版server 18.04.6。</p><p>在ubuntu系统上推荐两种方法制作系统盘，一种是ubuntu自带的Startup Disk Creator，方法比较简单，直接选择镜像文件和启动盘，一键制作即可完成。另一种是一款免费的第三方启动盘制作工具Etcher，安装和使用方法如下：</p><p>1.在<a href="https://www.balena.io/etcher/">官网</a>找到下载链接，找到自己对应系统的AppImage下载；</p><p>2.unzip解压下载的zip文件；</p><p>3.运行<code>./xxxxx.AppImage</code>即可启动；</p><p>4.选择镜像，选择U盘，等待完成即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何在ubuntu电脑上制作ubuntu server 18.04的启动盘，并安装系统和基础环境。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="ubuntu基础环境" scheme="https://zsh4614.cn/tags/ubuntu%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>C++中的非常量引用不能指向临时对象</title>
    <link href="https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E6%8C%87%E5%90%91%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zsh4614.cn/C-%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E6%8C%87%E5%90%91%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-10-30T10:07:28.000Z</published>
    <updated>2021-12-01T17:30:30.010Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍为什么C++标准规定非常量引用不能指向临时对象，以及什么情况下会产生临时对象。</p><span id="more"></span><h3 id="举例">举例</h3><p>非常量引用指向临时对象 —— 即：将临时对象传递给非常量引用类型。比如以下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Rational类中定义如下</span></span><br><span class="line"><span class="comment">//重载2个操作符函数：“+”号和“&lt;&lt;” 输出符号</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt; (ostream&amp; outs,Rational &amp;rational);</span><br><span class="line">Rational <span class="keyword">operator</span>+(Rational &amp;secondRational);</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a+b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>a+b 函数返回一个Rational类的临时对象；而 &lt;&lt; 操作函数的参数却是 Rational &amp; rational 。这种情况函数会报错如下：</p><p><code>no match for 'operator&lt;&lt;' in 'std::cout &lt;&lt; a.Rational::operator+(((Rational&amp;)(&amp; b)))'</code></p><p>虽然定义了 operator&lt;&lt; 。但是编译器对 a+b 返回的临时对象不买单，直接报了个“没有匹配的函数” 的错误。</p><h3 id="分析">分析</h3><p>以C++的语义来说，如果一个程序员只想传递参数给函数，而不希望函数修改传入的参数时，那么，或者使用值传递，或者采用常量型引用。考虑到大对象复制时产生的开销，一般使用常量型引用const &amp;。如果函数的参数是某个类型的一个非常量的引用，那就相当于告诉编译器，程序员希望得到函数对参数的修改结果。<br>临时变量是由编译器生成的，C++语言规范没规定编译器生成临时变量的规则，程序员无法得知由编译器生成的临时变量的名字，程序员无法访问那个临时变量。这意味着，以引用的方式传递一个临时变量做为函数参数，如果函数内部对此临时变量做了修改，那么函数返回后，程序员无法获得函数对临时变量的修改。函数对临时变量所做出的所有更改，都将丢失。</p><p>一方面，在函数申明中，使用非常量型的引用告诉编译器你需要得到函数对某个对象的修改结果，可是你自己又不给变量起名字，直接丢弃了函数的修改结果，编译器只能说：“大哥，你这是干啥呢，告诉我把结果给你，等我把结果给你了，你又直接给扔了，你这不是在玩我吗？”</p><p>同时，C++的标准 为了防止给常量或临时变量（只有瞬间的生命周期）赋值(易产生bug)，只许使用const引用之。</p><h3 id="解决">解决</h3><p>有两种解决办法，一是将非常量引用改为值传递，二是改为常量引用。</p><h3 id="临时对象">临时对象</h3><p>c++中的临时对象是看不见的，它不出现在源码中。建立一个未命名的非堆对象会产生一个临时对象，临时对象会在以下几种情况下出现。</p><h4 id="以值传递的方式给函数传参">以值传递的方式给函数传参</h4><p>按值传递时，首先将需要传给函数的参数，调用拷贝构造函数创建一个副本，这个副本就是临时变量，所有在函数里的操作都是针对这个副本，也正是因为这个原因，在函数体里对该副本进行任何操作都不会影响原参数。（关于临时对象的生命周期，并不是用过之后立马析构，其生命周期根据实际情况确定，比如这种情况，其生命周期可能存在于正割函数体内，又比如一个常量引用指向的临时对象，其声明周期由该常量引用的声明周期决定）</p><p>这也是<a href="http://zsh4614.cn/2021/04/13/%E8%AF%A6%E8%A7%A3C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/">拷贝构造函数不能为值传递</a>的原因，因为值传递会创建临时对象，而临时对象的创建仍然要调用拷贝构造函数，这样就会递归调用下去，造成栈溢出。</p><h4 id="隐式类型转换">隐式类型转换</h4><p>这种情况比较容易理解。</p><h4 id="函数返回对象">函数返回对象</h4><p>当函数需要返回一个对象，由于这个对象的生命周期只存在于函数体内部，所以它会在栈中创建一个临时对象（调用拷贝构造函数），存储函数的返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Assign operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">do</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p</span><br><span class="line">    p = <span class="built_in"><span class="keyword">do</span></span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况就会调用一次拷贝构造函数在栈上创建一个临时对象，然后调用赋值运算符将该临时对象复制给p。</p><h4 id="手动调用构造函数">手动调用构造函数</h4><p>**这里的手动调用指的是代码上显式调用而非编译器自己调用，**如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cls</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cls</span>() &#123;</span><br><span class="line">        <span class="built_in">cls</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cls c;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会打印出预期之外的结果，因为在调用cls(0)时，其实产生了一个cls类的临时对象，这个临时对象，而我们希望的是初始化对象c的成员a，但这里初始化的是临时对象的a。可以改成<code>*this = cls(0);</code>，这其实是和如下代码一个原理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line">cls a = <span class="built_in">cls</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>看起来调用了两次拷贝构造函数，临时对象一次，构造a一次，但实际上编译器做了如下优化，只调用了一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍为什么C++标准规定非常量引用不能指向临时对象，以及什么情况下会产生临时对象。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="临时对象" scheme="https://zsh4614.cn/tags/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="引用" scheme="https://zsh4614.cn/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：基于行程的连通域标记算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%A8%8B%E7%9A%84%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%A8%8B%E7%9A%84%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T09:08:18.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文介绍一种用于二值图像或者占空图的聚类算法，并给出c++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>Two-Pass算法是一种基于行程的二值图像连通域标记算法，matlab中连通区域标记函数bwlabel中使用的就是该算法，其算法流程如下：</p><blockquote><p>1，逐行扫描图像，我们把每一行中连续的白色像素组成一个序列称为一个团(run)，并记下它的起点start、它的终点end以及它所在的行号。</p><p>2，对于除了第一行外的所有行里的团，如果它与前一行中的所有团都没有重合区域，则给它一个新的标号；如果它仅与上一行中一个团有重合区域，则将上一行的那个团的标号赋给它；如果它与上一行的2个以上的团有重叠区域，则给当前团赋一个相连团的最小标号，并将上一行的这几个团的标记写入等价对，说明它们属于一类。</p><p>3，将等价对转换为等价序列，每一个序列需要给一相同的标号，因为它们都是等价的。从1开始，给每个等价序列一个标号。</p><p>4，遍历开始团的标记，查找等价序列，给予它们新的标记。</p><p>5，将每个团的标号填入标记图像中。</p><p>6，结束。</p></blockquote><h3 id="实现">实现</h3><p>下面给出其c++实现，主要分四步进行：</p><p>第一步：查找所有团并记录，需要记录团所在的行号、团开始的位置、结束的位置，当然还有一个表征团总数的变量。需要注意的就是团开始位置和结束位置在行首和行末的情况要单独拿出来考虑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillRunVectors</span><span class="params">(<span class="keyword">const</span> std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bimage, <span class="keyword">int</span>&amp; NumberOfRuns, std::vector&lt;<span class="keyword">int</span>&gt;&amp; stRun, std::vector&lt;<span class="keyword">int</span>&gt;&amp; enRun, std::vector&lt;<span class="keyword">int</span>&gt;&amp; rowRun, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rows, <span class="keyword">const</span> <span class="keyword">int</span>&amp; cols, std::vector&lt;<span class="keyword">int</span>&gt;&amp; label_map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; rowData = bimage[i];</span><br><span class="line">        <span class="keyword">if</span> (rowData[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            NumberOfRuns++;</span><br><span class="line">            stRun.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">            rowRun.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            label_map[i * cols] = NumberOfRuns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_idx = i * cols + j;</span><br><span class="line">            <span class="keyword">if</span> (rowData[j<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; rowData[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                NumberOfRuns++;</span><br><span class="line">                stRun.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                rowRun.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                label_map[cur_idx] = NumberOfRuns;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowData[j<span class="number">-1</span>] == <span class="number">1</span> &amp;&amp; rowData[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                enRun.<span class="built_in">emplace_back</span>(j<span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowData[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                label_map[cur_idx] = NumberOfRuns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowData[cols - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            enRun.<span class="built_in">emplace_back</span>(cols - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：遍历所有的团，完成团的标记与等价对列表的生成。这里判断团是否相邻的关键条件是：一个团的开始位置小于另一个团的结束位置，且结束位置大于另一个团的开始位置。 这里的equivalences 用于存储等价对，offset：0对应四连通，1对应八连通。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stRun, vector&lt;<span class="keyword">int</span>&gt;&amp; enRun, vector&lt;<span class="keyword">int</span>&gt;&amp; rowRun, <span class="keyword">int</span> NumberOfRuns, vector&lt;<span class="keyword">int</span>&gt;&amp; runLabels, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; equivalences, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idxLabel = <span class="number">1</span>;    <span class="comment">// 标记编号</span></span><br><span class="line">    <span class="keyword">int</span> curRowIdx = <span class="number">0</span>;    <span class="comment">// 当前所在行   </span></span><br><span class="line">    <span class="keyword">int</span> firstRunOnCur = <span class="number">0</span>;    <span class="comment">// 当前行的第一个团索引</span></span><br><span class="line">    <span class="keyword">int</span> firstRunOnPre = <span class="number">0</span>;    <span class="comment">// 前一行的第一个团索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRunOnPre = <span class="number">-1</span>;    <span class="comment">// 前一行的最后一个团索引</span></span><br><span class="line">    <span class="comment">// 初始化每个团的标签都为0</span></span><br><span class="line">    runLabels.<span class="built_in">assign</span>(NumberOfRuns, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfRuns; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rowRun[i] != curRowIdx) &#123;</span><br><span class="line">            <span class="comment">// 换行后更新状态变量</span></span><br><span class="line">            curRowIdx = rowRun[i];</span><br><span class="line">            firstRunOnPre = firstRunOnCur;</span><br><span class="line">            lastRunOnPre = i - <span class="number">1</span>;</span><br><span class="line">            firstRunOnCur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相邻行不存在团</span></span><br><span class="line">        <span class="keyword">if</span>（curRowIdx != rowRun[lastRunOnPre] + <span class="number">1</span>） &#123;</span><br><span class="line">            runLabels[i] = idxLabel++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对前一行进行遍历，检查是否有相邻的团</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = firstRunOnPre; j &lt;= lastRunOnPre; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stRun[i] &lt;= enRun[j] + offset &amp;&amp; enRun[i] &gt;= stRun[j] - offset) &#123;</span><br><span class="line">                <span class="comment">// 之前没有被标记过，即j是上一行第一个与当前团相邻的</span></span><br><span class="line">                <span class="keyword">if</span> (runLabels[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    runLabels[i] = runLabels[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLabels[i] != runLabels[j]) &#123;</span><br><span class="line">                    equalLabels.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_pair</span>(runLabels[i], runLabels[j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有与前一列如何run重合</span></span><br><span class="line">        <span class="keyword">if</span> (runLabels[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            runLabels[i] = idxLabel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：将等价对处理成等价序列，比如有如下等价对：(1,2),(1,6),(3,7),(9-3),(8,1),(8,10),(11,5),(11,8),(11,12),(11,13),(11,14),(15,11)，得到的最终序列是：</p><p>list1：1-2-5-6-8-10-11-12-13-14-15</p><p>list2：3-7-9</p><p>list3：4</p><p>这里还是采用DFS思想，c++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSameLabel</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; runLabels, std::vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; equivalence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLabel = *std::<span class="built_in">max_element</span>(runLabels.<span class="built_in">begin</span>(), runLabels.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 等价标签矩阵，值为true表示这两个标签等价</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">eqTab</span>(maxLabel, std::vector&lt;<span class="keyword">bool</span>&gt;(maxLabel, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 将等价对信息转移到矩阵上</span></span><br><span class="line">    std::vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator vecPairIt = equivalence.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (vecPairIt != equivalence.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        eqTab[vecPairIt-&gt;first - <span class="number">1</span>][vecPairIt-&gt;second - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        eqTab[vecPairIt-&gt;second - <span class="number">1</span>][vecPairIt-&gt;first - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        vecPairIt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标签映射，会将上一步团的标号映射到序列的标号，也是这一步的关键结果。</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">labelFlag</span><span class="params">(maxLabel, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 等价标签队列</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; tempList;</span><br><span class="line">    <span class="comment">// 当前使用的标签</span></span><br><span class="line">    <span class="keyword">int</span> curLabel = <span class="number">1</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxLabel; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果该标签已被映射，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (labelFlag[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        labelFlag[i - <span class="number">1</span>] = curLabel;</span><br><span class="line">        tempList.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        <span class="comment">// 在所有标签中寻找与当前标签等价的标签(这里可以换成栈操作，和floodfill类似) </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tempList.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= maxLabel; ++k) &#123;</span><br><span class="line">                <span class="comment">// 等价且未访问</span></span><br><span class="line">                <span class="keyword">if</span> (eqTab[tempList[j] - <span class="number">1</span>][k - <span class="number">1</span>] &amp;&amp; labelFlag[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                   labelFlag[k - <span class="number">1</span>] = curLabel;</span><br><span class="line">                   tempList.<span class="built_in">emplace_back</span>(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curLabel++;</span><br><span class="line">        tempList.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据映射修改标签</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = runLabels.<span class="built_in">begin</span>(); itr != runLabels.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        *itr = labelFlag[*itr - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：填充二值图中每个栅格的标签。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillLabel</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; runLabels, std::vector&lt;<span class="keyword">int</span>&gt;&amp; label_map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; label_map.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (label_map[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        label_map[i] = runLabels[label_map[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>该算法本质上和floodFill算法是一样的，区别在于floodFill是对每个栅格进行深度优先搜索，而这个是对团进行深度优先搜索。另外，在算法的第三步在对等价对进行合并时，可以用并查集进行优化，也可以用稀疏矩阵与Dulmage-Mendelsohn分解算法用来消除等价对（matlab中的做法），比较复杂。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文介绍一种用于二值图像或者占空图的聚类算法，并给出c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
    <category term="聚类" scheme="https://zsh4614.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
    <category term="连通域标记" scheme="https://zsh4614.cn/tags/%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A0%87%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：简化的漫水填充算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AE%80%E5%8C%96%E7%9A%84%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AE%80%E5%8C%96%E7%9A%84%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T09:04:46.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文介绍简化的漫水填充算法，用于二值图像聚类或者点云栅格聚类，并给出了c++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>floodFill，又叫seedfill，译作漫水填充算法，或者泛洪算法，其在opencv中进行了实现，参考<a href="https://github.com/opencv/opencv/blob/master/modules/imgproc/src/floodfill.cpp">这里</a>。</p><p>漫水填充法是一种用特定的颜色填充联通区域，通过设置可连通像素的上下限以及连通方式来达到不同的填充效果的方法。漫水填充经常被用来标记或分离图像的一部分以便对其进行进一步处理或分析，简而言之，漫水填充就是查找和种子点联通的颜色相同或者相近的点，ps的魔棒工具就是以该算法为基础的。</p><p>对于点云栅格化后的二值占空图，也可以采用该算法查找出与种子栅格联通的栅格，遍历所有种子点（非空点），就可以得到不同的簇。</p><h3 id="实现">实现</h3><p>下面给出该算法对二值图进行聚类的c++实现，其实质是一个DFS，优先地寻找一个完整连通域，在找的同时把他们都标记一下，找完一个完整连通域， 再去找下一个连通域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cols = <span class="number">2048</span>, rows = <span class="number">1024</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">seed_map</span><span class="params">(cols * rows, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 遍历点云初始化seed_map，有点为1，无点为0</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; label_map;</span><br><span class="line">label_map.<span class="built_in">resize</span>(cols * rows, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> tot_num_obj = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = row * cols + col;</span><br><span class="line">        <span class="keyword">if</span> (seed_map[idx] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;    <span class="comment">// 跳过空栅格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (label_map[idx] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;    <span class="comment">// 跳过已经被标记的栅格</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::stack&lt;Eigen::Vector2i&gt; neighbor_grids;</span><br><span class="line">        Eigen::Vector2i tmp_grid;</span><br><span class="line">        tmp_grid &lt;&lt; col, row;</span><br><span class="line">        neighbor_grids.<span class="built_in">push</span>(tmp_grid);</span><br><span class="line">        tot_num_obj++;</span><br><span class="line">        label_map[idx] = tot_num_obj;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!neighbor_grids.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Eigen::Vector2i cur_grid = neighbor_grids.<span class="built_in">top</span>();</span><br><span class="line">            neighbor_grids.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_grid.x - <span class="number">1</span>; i &lt;= cur_grid.x + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= cols) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = cur_grid.y - <span class="number">1</span>; j &lt;= cur_grid.y + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt;= rows) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> tmp_idx = j * cols + i;</span><br><span class="line">                    <span class="keyword">if</span> (seed_map[tmp_idx] == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (label_map[tmp_idx] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    label_map[tmp_idx] = tot_num_obj;</span><br><span class="line">                    tmp_grid &lt;&lt; i, j;</span><br><span class="line">                    neighbor_grids.<span class="built_in">push</span>(tmp_grid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样就对二值占空图的每个栅格进行了标记，得到了多个簇。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文介绍简化的漫水填充算法，用于二值图像聚类或者点云栅格聚类，并给出了c++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
    <category term="聚类" scheme="https://zsh4614.cn/tags/%E8%81%9A%E7%B1%BB/"/>
    
    <category term="floodfill" scheme="https://zsh4614.cn/tags/floodfill/"/>
    
  </entry>
  
  <entry>
    <title>Hexo在多台电脑上维护github个人主页</title>
    <link href="https://zsh4614.cn/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%BB%B4%E6%8A%A4github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    <id>https://zsh4614.cn/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%BB%B4%E6%8A%A4github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</id>
    <published>2021-10-30T07:27:04.000Z</published>
    <updated>2021-12-01T17:30:30.011Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何在两台（多台）电脑上维护自己的github pages博客。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>总体方法是利用git分支实现。hexo生成的静态博客文件默认放在master分支上，可以新建一个分支用来存放源文件，在其他电脑上只需要git clone这个分支即可进行更新和发布等操作。</p><h3 id="环境">环境</h3><p>在操作之前，先在新电脑上安装好hexo需要的环境：</p><p><strong>安装npm和node.js:</strong></p><p>到<a href="https://nodejs.org/dist/latest/">官网</a>下载最新的压缩包，解压后在bin目录下有npm和node的可执行文件，但是安装路径没有在系统环境变量中，所以添加到系统环境中，有多种方法，这里我进行了软链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure><p><strong>安装hexo：</strong></p><p>直接使用npm安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>同样需要加到系统环境中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ~/software/node-v17.0.1-linux-x64/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure><h3 id="步骤">步骤</h3><p>1.给github博客仓库新建一个hexo分支，设置为默认分支。</p><p>2.将当前电脑的ssh key添加到github上。</p><p>3.执行git clone命令将hexo克隆到本地，将除了.git的文件全部删除，然后add-commit-push更新到远程。</p><p>4.将原来博客根目录下（即包含themes、source等文件夹的那个目录）所有文件拷贝到本地hexo分支文件夹。</p><p>5.删除themes文件夹每个主题的.git文件夹和.gitignore文件。</p><p>6.执行add-commit-push更新到远程。</p><p>7.之后在任何配置好博客环境的电脑上都采用如下操作维护博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pull-add-commit-push</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何在两台（多台）电脑上维护自己的github pages博客。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="个人主页" scheme="https://zsh4614.cn/tags/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一一五题：不同子序列</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E4%B8%80%E4%BA%94%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E4%B8%80%E4%BA%94%E9%A2%98%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-10-23T09:04:46.000Z</published>
    <updated>2021-12-01T17:30:30.011Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一一五题，利用C++实现；并进行了空间优化，另外还可以利用dfs进行时间优化。</p><span id="more"></span><h3 id="题目">题目</h3><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><h3 id="示例">示例</h3><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rabbbit&quot;, t &#x3D; &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babgbag&quot;, t &#x3D; &quot;bag&quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h3 id="分析">分析</h3><p>1.可以用动态规划的方法求解，<code>dp[i][j]</code>表示<code>s[0]</code>到<code>s[i]</code>之中有多少个<code>t[0]</code>到<code>t[j]</code>序列。</p><p>从最后一个字符看，假设s和t的长度分别是n和m，如果<code>s[n-1]</code>和<code>t[m-1]</code>不相等，那么显然只能在<code>s[0]</code>到<code>s[n-2]</code>中去找t；如果<code>s[n-1]</code>和<code>t[m-1]</code>相等，那么又分为两种情况，一是用<code>s[n-1]</code>，那么需要在<code>s[0]</code>到<code>s[n-2]</code>中去找<code>t[0]</code>到<code>t[m-2]</code>，另一种是不用<code>s[n-1]</code>，那么这就变成了和<code>s[n-1]</code>和<code>t[m-1]</code>不相等相同的情况，那么<code>s[n-1]</code>和<code>t[m-1]</code>相等时的方案数就是这两种情况之和。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if s[n-1] !&#x3D; t[m-1]:</span><br><span class="line">    dp[n-1][m-1] &#x3D; dp[n-2][m-1]</span><br><span class="line">else:</span><br><span class="line">    dp[n-1][m-1] &#x3D; dp[n-2][m-1] + dp[n-2][m-2]</span><br></pre></td></tr></table></figure><p>2.按照上述分析，是一个二维的动态规划，当s比较长时，那么所需要开辟的空间就会非常大，所以还需要进行空间上的优化。可以发现<code>dp[n-1][m-1]</code>只和<code>dp[n-2][m-1]</code>与<code>dp[n-2][m-2]</code>有关，即这个二维数组只和它左上方和上方的元素有关，这样就可以不开辟二维数组，只开辟一维数组，然后不断更新，需要注意的是，要进行倒序更新。</p><h3 id="实现">实现</h3><h4 id="c">c++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">size_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">size_t</span>&gt;(t.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = (s[<span class="number">0</span>] == t[<span class="number">0</span>]) ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = (s[i] == t[<span class="number">0</span>]) ? (dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>) : dp[i<span class="number">-1</span>][<span class="number">0</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>() - <span class="number">1</span>][t.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空间优化">空间优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = (s[<span class="number">0</span>] == t[<span class="number">0</span>]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = t.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">            dp[j] = (s[i] == t[j]) ? (dp[j] + dp[j<span class="number">-1</span>]) : dp[j];</span><br><span class="line">        &#125; </span><br><span class="line">        dp[<span class="number">0</span>] = (s[i] == t[<span class="number">0</span>]) ? (dp[<span class="number">0</span>] + <span class="number">1</span>) : dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[t.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><p>这道题属于困难，优化的方法比较多，还有时间优化的余地，之后可以用dfs进行时间优化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一一五题，利用C++实现；并进行了空间优化，另外还可以利用dfs进行时间优化。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="动态规划" scheme="https://zsh4614.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="算法优化" scheme="https://zsh4614.cn/tags/%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一九八题：打家劫舍</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E4%B9%9D%E5%85%AB%E9%A2%98%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E4%B9%9D%E5%85%AB%E9%A2%98%EF%BC%9A%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2021-10-23T09:04:46.000Z</published>
    <updated>2021-12-01T17:30:30.011Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一九八题，属于典型动态规划，最后C++实现。</p><span id="more"></span><h4 id="题目">题目</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><h4 id="示例">示例</h4><h5 id="示例1">示例1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><h5 id="示例2">示例2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><h5 id="提示">提示</h5><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h4 id="分析">分析</h4><p>对于第i辆车，可以选择偷和不偷，最后求偷的情况下和不偷的情况下哪种情况偷的总数更多就可以了。偷的情况<code>dp[i]=dp[i-2]+p[i]</code>，不偷的情况<code>dp[i]=dp[i-1]</code>。</p><h4 id="实现">实现</h4><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> prepre = <span class="number">0</span>, pre = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        now = <span class="built_in">max</span>(pre, prepre+nums[i]);</span><br><span class="line">        prepre = pre;</span><br><span class="line">        pre = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>这道题很典型的dp问题，而且思路比较简单，我刚开始复杂了，但是也没太复杂：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">y</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">n</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        y[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        n[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            y[i] = n[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">            n[i] = <span class="built_in">max</span>(y[i - <span class="number">1</span>], n[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(y[nums.<span class="built_in">size</span>() - <span class="number">1</span>], n[nums.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = &#123;nums[<span class="number">0</span>], <span class="number">0</span>, nums[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>] + nums[i];</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一九八题，属于典型动态规划，最后C++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="动态规划" scheme="https://zsh4614.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>C++11之shared_ptr</title>
    <link href="https://zsh4614.cn/C-11%E4%B9%8Bshared-ptr/"/>
    <id>https://zsh4614.cn/C-11%E4%B9%8Bshared-ptr/</id>
    <published>2021-06-13T08:55:10.000Z</published>
    <updated>2021-12-01T17:30:30.010Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本节介绍C++11新特性之 shared_ptr 智能指针。</p><span id="more"></span><h3 id="背景">背景</h3><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p><ul><li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li><li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li><li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li></ul><p>针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。如今，垃圾回收机制已经大行其道，得到了诸多编程语言的支持，例如 Java、Python、C#、PHP 等。而 C++ 虽然从来没有公开得支持过垃圾回收机制，但 C++98/03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 **unique_ptr、shared_ptr 以及 weak_ptr **这 3 个智能指针来实现堆内存的自动回收。所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，<strong>使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现</strong>。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p><p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p><h3 id="说明">说明</h3><p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr&lt;T&gt;（其中 T 表示指针指向的具体数据类型）的定义位于<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std；<span class="comment">//也可以不添加，则后续在使用 shared_ptr 智能指针时，就需要明确指明std::。</span></span><br></pre></td></tr></table></figure><p>值得一提的是，和 unique_ptr、weak_ptr 不同之处在于，<strong>多个 shared_ptr 智能指针可以共同使用同一块堆内存</strong>。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p><h3 id="shared-ptr智能指针的创建">shared_ptr智能指针的创建</h3><p>shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数，这里列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</p><ol><li>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p1;<span class="comment">// 不传入任何参数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;<span class="comment">// 传入空指针nullptr</span></span><br></pre></td></tr></table></figure><p>注意，<strong>空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。</strong></p><ol start="2"><li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>由此，我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p><p>同时，C++11 标准中还提供了 std::make_shared&lt;T&gt; 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>以上 2 种方式创建的 p3 是完全相同。</p><p><strong>注意，不能将一个原始指针直接赋值给一个智能指针：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);<span class="comment">// 错误 </span></span><br></pre></td></tr></table></figure><ol start="3"><li>除此之外，shared_ptr&lt;T&gt; 模板还提供有相应的拷贝构造函数和移动构造函数，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者</span></span><br><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p4 = p3;</span><br><span class="line"><span class="comment">// 调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">// 或者</span></span><br><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p5 = std::<span class="built_in">move</span>(p4);</span><br></pre></td></tr></table></figure><p>如上所示，p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。</p><p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。</p><p><strong>注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li></ol><p>在某些场景中，自定义释放规则是很有必要的。比如，<strong>对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</strong></p><p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete&lt;T&gt; 模板类，我们也可以自定义释放规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="keyword">int</span> []&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义释放规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteInt</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本节介绍C++11新特性之 shared_ptr 智能指针。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>经典算法：卡尔曼滤波（图解推导）</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%EF%BC%88%E5%9B%BE%E8%A7%A3%E6%8E%A8%E5%AF%BC%EF%BC%89/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%EF%BC%88%E5%9B%BE%E8%A7%A3%E6%8E%A8%E5%AF%BC%EF%BC%89/</id>
    <published>2021-05-24T15:05:05.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文翻译自国外博主Bzarg在2015年写的一篇卡尔曼滤波的图解。</p><span id="more"></span><h3 id="背景">背景</h3><p>卡尔曼滤波（Kalman filter）是一种高效的自回归滤波器，它能在存在诸多不确定性情况的组合信息中估计动态系统的状态，是一种强大的、通用性极强的工具。它的提出者，鲁道夫.E.卡尔曼，在一次访问NASA埃姆斯研究中心时，发现这种方法能帮助解决阿波罗计划的轨道预测问题，后来NASA在阿波罗飞船的导航系统中确实也用到了这个滤波器。最终，飞船正确驶向月球，完成了人类历史上的第一次登月。</p><p><img src="https://i.loli.net/2021/05/22/tmSXqv7sRf9P6FC.jpg" alt="v2-e7fade003119539cd2892c23ff924ca1_720w.jpg"></p><h3 id="什么是卡尔曼滤波">什么是卡尔曼滤波</h3><p>对于这个滤波器，我们几乎可以下这么一个定论：只要是存在不确定信息的动态系统，卡尔曼滤波就可以对系统下一步要做什么做出有根据的推测。即便有噪声信息干扰，卡尔曼滤波通常也能很好的弄清楚究竟发生了什么，找出现象间不易察觉的相关性。</p><p>因此卡尔曼滤波非常适合不断变化的系统，它的优点还有内存占用较小（只需保留前一个状态）、速度快，是实时问题和嵌入式系统的理想选择。</p><p>如果你曾经Google过卡尔曼滤波的教程（如今有一点点改善），你会发现相关的算法教程非常可怕，而且也没具体说清楚是什么。事实上，卡尔曼滤波很简单，如果我们以正确的方式看它，理解是很水到渠成的事。</p><p>本文会用大量清晰、美观的图片和颜色来解释这个概念，读者只需具备概率论和矩阵的一般基础知识。</p><h3 id="我们能用卡尔曼滤波做什么">我们能用卡尔曼滤波做什么</h3><p>让我们举个例子：你造了一个可以在树林里四处溜达的小机器人，为了让它实现导航，机器人需要知道自己所处的位置。</p><p><img src="https://i.loli.net/2021/05/22/7bj6ryBc4fMaeE9.png" alt="robot_forest-300x160.png"></p><p>也就是说，机器人有一个包含位置信息和速度信息的状态$\vec{x}_k$：</p><p><img src="https://i.loli.net/2021/05/22/VPt7HL4wMcaEZvf.png" alt="Screenshot from 2021-05-22 18-35-17.png"></p><p>注意，在这个例子中，状态是位置和速度，放进其他问题里，它也可以是水箱里的液体体积、汽车引擎温度、触摸板上指尖的位置，或者其他任何数据。</p><p>我们的小机器人装有GPS传感器，定位精度10米。虽然一般来说这点精度够用了，但我们希望它的定位误差能再小点，毕竟树林里到处都是土坑和陡坡，如果机器人稍稍偏了那么几米，它就有可能滚落山坡。所以GPS提供的信息还不够充分。</p><p><img src="https://i.loli.net/2021/05/22/wp4NDdIZl8EH5sQ.png" alt="robot_ohnoes-300x283.png"></p><p>我们也可以<strong>预测</strong>机器人是怎么移动的：它会把指令发送给控制轮子的马达，如果这一刻它始终朝一个方向前进，没有遇到任何障碍物，那么下一刻它可能会继续坚持这个路线。但是机器人对自己的状态不是全知的：它可能会逆风行驶，轮子打滑，滚落颠簸地形……所以车轮转动次数并不能完全代表实际行驶距离，基于这个距离的预测也不完美。</p><p>这个问题下，GPS为我们提供了一些关于状态的信息，但那是间接的、不准确的；我们的预测提供了关于机器人轨迹的信息，但那也是间接的、不准确的。</p><p>但以上就是我们能够获得的全部信息，在它们的基础上，我们是否能给出一个完整预测，让它的准确度比机器人搜集的单次预测汇总更高？用了卡尔曼滤波，这个问题可以迎刃而解。</p><h3 id="卡尔曼滤波眼里的机器人问题">卡尔曼滤波眼里的机器人问题</h3><p>还是上面这个问题，我们有一个状态，它和速度、位置有关：</p><p><img src="https://i.loli.net/2021/05/22/akiCweMZIXhRJus.jpg" alt="v2-a1a901c6aad3d87b47b148a3e5cdddbe_720w.jpg"></p><p>我们不知道它们的实际值是多少，但掌握着一些速度和位置的可能组合，其中某些组合的可能性更高：</p><p><img src="https://i.loli.net/2021/05/22/QIOpYyKaEqeDZki.png" alt="gauss_0.png"></p><p>卡尔曼滤波假设两个变量（在我们的例子里是位置和速度）都应该是<strong>随机的</strong>，而且符合<strong>高斯分布</strong>。每个变量都有一个<strong>均值</strong> $\mu$，它是随机分布的中心；有一个方差$\sigma^2$ ，它衡量组合的不确定性。</p><p><img src="https://i.loli.net/2021/05/22/XOQhw7EG1nlbMzq.png" alt="gauss_1.png"></p><p>在上图中，位置和速度是<strong>不相关</strong>的，这意味着我们不能从一个变量推测另一个变量。</p><p>那么如果位置和速度相关呢？如下图所示，机器人前往特定位置的可能性取决于它拥有的速度。</p><p><img src="https://i.loli.net/2021/05/22/Ugzas51T2e83mHJ.png" alt="gauss_3.png"></p><p>这不难理解，如果基于旧位置估计新位置，我们会产生这两个结论：如果速度很快，机器人可能移动得更远，所以得到的位置会更远；如果速度很慢，机器人就走不了那么远。</p><p>这种关系对目标跟踪来说非常重要，因为它提供了更多信息：一个可以衡量可能性的标准。这就是卡尔曼滤波的目标：从不确定信息中挤出尽可能多的信息！</p><p>为了捕获这种相关性，我们用的是协方差矩阵。简而言之，矩阵的每个值是第 $i$ 个变量和第 $j$个变量之间的相关程度（由于矩阵是对称的，$i$ 和$j$的位置可以随便交换）。我们用$\varSigma$表示协方差矩阵，在这个例子中，就是$\varSigma_{ij}$。</p><p><img src="https://i.loli.net/2021/05/22/N4HQ1Jrq86LEuCm.png" alt="gauss_2.png"></p><h3 id="用矩阵描述问题">用矩阵描述问题</h3><p>为了把以上关于状态的信息建模为高斯分布（图中色块），我们还需要$k$时的两个信息：最佳估计$\mathbf{\hat{x}_k}$ （均值，也就是$\mu$)，协方差矩阵$\mathbf{P_k}$ 。（虽然还是用了位置和速度两个变量，但只要和问题相关，卡尔曼滤波可以包含任意数量的变量）</p><p><img src="https://i.loli.net/2021/05/22/mp4zoHRAkQCcEnu.jpg" alt="v2-2ac6f7823c6e340805cce06b61c8fa16_720w.jpg"></p><p>接下来，我们要通过查看当前状态（k-1时）来预测下一个状态（k时）。这里我们查看的状态不是真值，但预测函数无视真假，可以给出新分布：</p><p><img src="https://i.loli.net/2021/05/22/vn2s18qwYNje3Ql.jpg" alt="gauss_7.jpg"></p><p>我们可以用矩阵$\mathbf{F_k}$表示这个预测步骤：</p><p><img src="https://i.loli.net/2021/05/22/hibCd4yzZr8EwVx.jpg" alt="gauss_8.jpg"></p><p>它从原始预测中取每一点，并将其移动到新的预测位置。如果原始预测是正确的，系统就会移动到新位置。</p><p>这是怎么做到的？为什么我们可以用矩阵来预测机器人下一刻的位置和速度？下面是个简单公式：</p><p><img src="https://i.loli.net/2021/05/22/bZgBprOUPf8WqQM.jpg" alt="v2-03ed134b88639dbfe347012511440a3a_720w.jpg"></p><p>换成矩阵形式：</p><p><img src="https://i.loli.net/2021/05/22/ilCmqGR1awOcWpg.jpg" alt="v2-2916712c805c703b37fce364549dadf6_720w.jpg"></p><p>这是一个预测矩阵，它能给出机器人的下一个状态，但目前我们还不知道协方差矩阵的更新方法。这也是我们要引出下面这个等式的原因：如果我们将分布中的每个点乘以矩阵$\color{firebrick}{\mathbf{A}}$，那么它的协方差矩阵会发生什么变化</p><p><img src="https://i.loli.net/2021/05/22/92dpmA3cJ5TCvNa.jpg" alt="v2-69a02c2142ed47d086a9a948cb8b17b1_720w.jpg"></p><p>把这个式子和上面的最佳估计$\mathbf{\hat{x}_k}$结合，可得：</p><p><img src="https://i.loli.net/2021/05/22/etgk3Inhlm8E1Wd.jpg" alt="v2-dbf13375a23f07e1040adf38ea186aa7_720w.jpg"></p><h3 id="外部影响">外部影响</h3><p>但是，除了速度和位置，外因也会对系统造成影响。比如模拟火车运动，除了列车自驾系统，列车操作员可能会手动调速。在我们的机器人示例中，导航软件也可以发出停止指令。对于这些信息，我们把它作为一个向量$\color{darkorange}{\vec{\mathbf{u}_k}}$，纳入预测系统作为修正。</p><p>假设油门设置和控制命令是已知的，我们知道火车的预期加速度$\color{darkorange}{a}$。根据运动学基本定理，我们可得：</p><p><img src="https://i.loli.net/2021/05/22/M6neCKhrPYOIWzV.jpg" alt="v2-e0cd414e3b6d4ef4f8a57c8b156a5103_720w.jpg"></p><p>把它转成矩阵形式：</p><p><img src="https://i.loli.net/2021/05/22/WC5EIrhRmOxU6ya.jpg" alt="v2-64e50bf118c8039f6228b5c817490601_720w.jpg"></p><p>$\mathbf{B}_k$是控制矩阵，$\color{darkorange}{\vec{\mathbf{u}_k}}$是控制向量。如果外部环境异常简单，我们可以忽略这部分内容，但是如果添加了外部影响后，模型的准确率还是上不去，这又是为什么呢？</p><h3 id="外部不确定性">外部不确定性</h3><p>当一个国家只按照自己的步子发展时，它会自生自灭。当一个国家开始依赖外部力量发展时，只要这些外部力量是已知的，我们也能预测它的存亡。</p><p>但是，如果存在我们不知道的力量呢？当我们监控无人机时，它可能会受到风的影响；当我们跟踪轮式机器人时，它的轮胎可能会打滑，或者粗糙地面会降低它的移速。这些因素是难以掌握的，如果出现其中的任意一种情况，预测结果就难以保障。</p><p>这要求我们在每个预测步骤后再加上一些新的不确定性，来模拟和“世界”相关的所有不确定性：</p><p><img src="https://i.loli.net/2021/05/22/fKRH5ZGvQzUXis3.jpg" alt="gauss_9.jpg"></p><p>如上图所示，加上外部不确定性后，$\color{royalblue}{\mathbf{\hat{x}}_{k-1}}$的每个预测状态都可能会移动到另一点，也就是蓝色的高斯分布会移动到紫色高斯分布的位置，并且具有协方差$\color{mediumaquamarine}{\mathbf{Q}_k}$。换句话说，我们把这些不确定影响视为协方差$\color{mediumaquamarine}{\mathbf{Q}_k}$ 的噪声。</p><p><img src="https://i.loli.net/2021/05/22/Y5AvPyXsC8JaFKg.jpg" alt="gauss_10a.jpg"></p><p>这个紫色的高斯分布拥有和原分布相同的均值，但协方差不同。</p><p><img src="https://i.loli.net/2021/05/22/KXNsh5GRSY1xpbE.jpg" alt="gauss_10b.jpg"></p><p>我们在原式上加入${\color{mediumaquamarine}{\mathbf{Q}_k}}$，得到预测步骤的完整表达式：</p><p><img src="https://i.loli.net/2021/05/22/72BFutEgcpAq5jl.jpg" alt="v2-2c8b709435f6c99ef9b00bba18d32b09_720w.jpg"></p><p>简而言之，这里：</p><p><font color='deeppink'>新的最佳估计</font>是基于<font color='royalblue'>原最佳估计</font>和<font color='darkorange'>已知外部影响</font>校正后得到的预测。</p><p><font color='deeppink'>新的不确定性</font>是基于<font color='royalblue'>原不确定性</font>和<font color='mediumaquamarine'>外部环境的不确定性</font>得到的预测。</p><p>现在，得到最终的预测结果，我们把传感器数据加入其中，会发生什么呢？</p><h3 id="通过测量值来修正估计值">通过测量值来修正估计值</h3><p>我们可能有好几个传感器，它们一起提供有关系统状态的信息。传感器的作用不是我们关心的重点，它可以读取位置，可以读取速度，重点是，它能告诉我们关于状态的间接信息——它是状态下产生的一组读数。</p><p><img src="https://i.loli.net/2021/05/22/aWxnoL2UKdQv3cS.jpg" alt="gauss_12.jpg"></p><p>请注意，读数的规模和状态的规模不一定相同，所以我们把传感器读数转换矩阵设为$\mathbf{H}_k$。</p><p><img src="https://i.loli.net/2021/05/22/IkaUXst49c13HEC.jpg" alt="gauss_13.jpg"></p><p>把这些分布转换为一般形式：</p><p><img src="https://i.loli.net/2021/05/22/kDbOIEhpj8fLwga.jpg" alt="v2-531d486ddd0875207e79b16d19006ca5_720w.jpg"></p><p>卡尔曼滤波的一大优点是擅长处理传感器噪声。换句话说，由于种种因素，传感器记录的信息其实是不准的，一个状态事实上可以产生多种读数。</p><p><img src="https://i.loli.net/2021/05/22/hRPIA6ZkDC4WVTu.jpg" alt="gauss_14.jpg"></p><p><img src="https://i.loli.net/2021/05/22/5ylrfT3eAtiqEn9.jpg" alt="gauss_11.jpg"></p><p>我们将这种不确定性（即传感器噪声）的协方差设为$\color{mediumaquamarine}{\mathbf{R}_k}$，读数的分布均值设为$\color{yellowgreen}{\vec{\mathbf{z}_k}}$。</p><p>现在我们得到了两块高斯分布，一块围绕预测的均值，另一块围绕传感器读数。</p><p><img src="https://i.loli.net/2021/05/22/elyvYbRBks9FVZh.jpg" alt="gauss_4.jpg"></p><p>如果要生成靠谱预测，模型必须调和这两个信息。也就是说，对于任何可能的读数$(z_1,z_2)$，这两种方法预测的状态都有可能是准的，也都有可能是不准的。重点是我们怎么找到这两个准确率。</p><p>最简单的方法是两者相乘：</p><p><img src="https://i.loli.net/2021/05/22/UjPb1LfCnmrQkGF.png" alt="gauss_6a.png"></p><p>两块高斯分布相乘后，我们可以得到它们的重叠部分，这也是会出现最佳估计的区域。换个角度看，它看起来也符合高斯分布：</p><p><img src="https://i.loli.net/2021/05/22/zEl6UjiPLBDmGfQ.png" alt="gauss_6.png"></p><p>事实证明，当你把两个高斯分布和它们各自的均值和协方差矩阵相乘时，你会得到一个拥有独立均值和协方差矩阵的新高斯分布。最后剩下的问题就不难解决了：我们必须有一个公式来从旧的参数中获取这些新参数！</p><h3 id="结合高斯">结合高斯</h3><blockquote><p>关于两个高斯分布的乘积仍为高斯分布的证明见：</p></blockquote><p>让我们从一维看起，设方差为$\sigma^2$，均值为$\mu$，一个标准一维高斯钟形曲线方程如下所示：</p><p><img src="https://i.loli.net/2021/05/22/9U1MAkrv7jpEYw4.jpg" alt="v2-97fd17b2ea76d5452a22725f19f99580_720w.jpg"></p><p>那么两条高斯曲线相乘呢，下面的蓝色曲线代表两个高斯分布的（未归一化）交集：</p><p><img src="https://i.loli.net/2021/05/22/Ll3wR16UnqFoJtO.png" alt="gauss_joint.png"></p><p><img src="https://i.loli.net/2021/05/22/vjf9RsMGbIQE23N.jpg" alt="v2-44fae648700cd28c6ed7c82e91c864a9_720w.jpg"></p><p>把这个式子按照一维方程进行扩展，并进行归一化使其概率和为1，可得：</p><p><img src="https://i.loli.net/2021/05/22/aiEYnxhTKLQsRec.jpg" alt="v2-f3119ec5da2279746e27b0e2e31ccfb9_720w.jpg"></p><p>如果有些太复杂，我们用k简化一下：</p><p><img src="https://i.loli.net/2021/05/22/ZwMnGEljsW3FSXq.jpg" alt="v2-2881114c10fc274482b013e408df9ce9_720w.jpg"></p><p>以上是一维的内容，如果是多维空间，把这个式子转成矩阵格式：</p><p><img src="https://i.loli.net/2021/05/22/2k5ZD19KwQ4cbgY.jpg" alt="v2-1c02a4b31a146aba44c5082079df1e8c_720w.jpg"></p><p>这个矩阵 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 就是我们说的<strong>卡尔曼增益</strong>，easy！</p><h3 id="把他们结合在一起">把他们结合在一起</h3><p>截至目前，我们有用矩阵$(\color{fuchsia}{\mu_0}, \color{deeppink}{\Sigma_0}) = (\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k}, \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T})$预测的分布，有用传感器读数$(\color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\Sigma_1}) = (\color{yellowgreen}{\vec{\mathbf{z}_k}}, \color{mediumaquamarine}{\mathbf{R}_k})$预测的分布。把它们代入上节的矩阵等式中：</p><p><img src="https://i.loli.net/2021/05/22/ur956PgedMq47oV.jpg" alt="v2-9cb02f4cb340f4bee98bf8fdef80867b_720w.jpg"></p><p>相应的，卡尔曼增益就是：</p><p><img src="https://i.loli.net/2021/05/22/aZlki8CpGLf7PJb.jpg" alt="v2-c2a3f0e191354e598e09d4fdd59b8d25_720w.jpg"></p><p>考虑到$\color{purple}{\mathbf{K}}$里还包含着一个$\mathbf{H}_k$，我们再精简一下上式：</p><p><img src="https://i.loli.net/2021/05/22/2lc56dFy3fGb1Ne.jpg" alt="v2-47b92e3442751ff8266b4d18e30bda2a_720w.jpg"></p><p>最后，$\color{royalblue}{\mathbf{\hat{x}}_k’}$是我们最终的最佳估计值，我们可以把它和$\color{royalblue}{\mathbf{P}_k’}$继续放进去做另一轮预测：</p><p><img src="https://i.loli.net/2021/05/22/hZrmD1IuW75wR9i.png" alt="kalflow.png"></p><blockquote><p>参考：<a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits">http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文翻译自国外博主Bzarg在2015年写的一篇卡尔曼滤波的图解。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="卡尔曼滤波" scheme="https://zsh4614.cn/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    
  </entry>
  
</feed>
