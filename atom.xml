<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到我的主页!</title>
  
  
  <link href="https://zsh4614.cn/atom.xml" rel="self"/>
  
  <link href="https://zsh4614.cn/"/>
  <updated>2022-01-17T16:07:13.096Z</updated>
  <id>https://zsh4614.cn/</id>
  
  <author>
    <name>zsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode第一百六十题：相交链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%85%AD%E5%8D%81%E9%A2%98%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%85%AD%E5%8D%81%E9%A2%98%EF%BC%9A%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-17T15:01:11.000Z</published>
    <updated>2022-01-17T16:07:13.096Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍LeetCode第一百六十题，判断两个链表是否相交，并找出相交的结点。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://s2.loli.net/2022/01/17/xf6UjXkD2TeWI3F.png" alt="image.png"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h3 id="示例">示例</h3><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/17/deKrCEjBOtQgmWI.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/17/pec9sSCqiohBu5r.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><img src="https://s2.loli.net/2022/01/17/hEXnDypY7I56LfO.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>listA 中节点数目为 m</li><li>listB 中节点数目为 n</li><li>1 &lt;= m, n &lt;= 3 * 104</li><li>1 &lt;= Node.val &lt;= 105</li><li>0 &lt;= skipA &lt;= m</li><li>0 &lt;= skipB &lt;= n</li><li>如果 listA 和 listB 没有交点，intersectVal 为 0</li><li>如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</li></ul><h3 id="分析">分析</h3><p>如果只是判断两个链表是否相交，那么就很简单了，只需要判断最后一个结点是否是同一个结点。但是本题要返回相交的那个结点，一个最直接的思路是使用哈希表，先将一个链表的每个结点地址存储起来，然后在遍历第二个链表的时候去查表，这样时间复杂度是O(m+n)，空间复杂度为O(m)。另一种常用的思路是用双指针，同时遍历两个链表，当遍历到尾结点的时候，指向另一个链表的头结点，这样如果有相交的话，那么一定会指到同一个结点上；如果不相交的话，那么最后他们一定同时指向nullptr。</p><h3 id="实现">实现</h3><p><strong>方法一：哈希</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; hashset;</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        hashset.<span class="built_in">emplace</span>(headA);</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.<span class="built_in">find</span>(headB) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">    ListNode* workA &#x3D; headA;</span><br><span class="line">    ListNode* workB &#x3D; headB;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        </span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            return workB;</span><br><span class="line">        &#125;</span><br><span class="line">        workA &#x3D; workA-&gt;next;</span><br><span class="line">        workB &#x3D; workB-&gt;next;</span><br><span class="line">        if (workA &#x3D;&#x3D; workB) &#123;</span><br><span class="line">            if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workA &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workA &#x3D; headB;</span><br><span class="line">        &#125;</span><br><span class="line">        if (workB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            workB &#x3D; headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的思路，看一下大神写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA &#x3D;&#x3D; nullptr || headB &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA &#x3D; headA, *pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NB!!!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍LeetCode第一百六十题，判断两个链表是否相交，并找出相交的结点。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="https://zsh4614.cn/categories/Leetcode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一百四十二题：环形链表二</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E7%99%BE%E5%9B%9B%E5%8D%81%E4%BA%8C%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/</id>
    <published>2022-01-16T08:40:10.000Z</published>
    <updated>2022-01-16T10:01:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一百四十二题，判断一个链表是否有环，有环的话找到入环的结点，用佛洛依德判圈算法实现。</p><span id="more"></span><h3 id="题目：">题目：</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改链表。</p><h3 id="示例">示例</h3><p><strong>示例一</strong></p><p><img src="https://s2.loli.net/2022/01/16/p4XMYle9k8yqxwm.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例二</strong></p><p><img src="https://s2.loli.net/2022/01/16/v8whclNoCksYBQT.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例三</strong></p><p><img src="https://s2.loli.net/2022/01/16/2PmvFTZqnyrhkap.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 [0, 10^4] 内</li><li>-10^5 &lt;= Node.val &lt;= 10^5</li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><h3 id="分析">分析</h3><p>本题可使用佛洛依德判圈算法求解。</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* slow = dummy1;</span><br><span class="line">    ListNode* dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* fast = dummy2;</span><br><span class="line">    slow-&gt;next = head;</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow-&gt;next) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">delete</span> dummy1, dummy2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里虚拟了一个dummy结点，这样可以将头结点当作一般结点看待，否则可能需要判断头结点为空的情况，这样做就不用单独判断了。另外<strong>新开辟的无用内存，在返回前一定要释放，否则会内存泄漏</strong>，这里的slow和fast相当于工作结点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一百四十二题，判断一个链表是否有环，有环的话找到入环的结点，用佛洛依德判圈算法实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：Floyd判圈算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-15T09:21:19.000Z</published>
    <updated>2022-01-16T08:28:07.984Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍一种常用的判圈算法，并给出其推导。</p><span id="more"></span><h3 id="简述">简述</h3><p>Floyd判圈算法（Floyd Cycle Detection Algorithm），又称龟兔赛跑算法（Tortoise and Hare Algorithm），是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。</p><h3 id="问题">问题</h3><p>如何检测一个链表是否有环，如果有，那么如何确定环的起点和环的长度。</p><p>1）判断是否有环？<br>龟兔解法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p><p>基于上面的想法，Floyd用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果时等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。</p><p>2）求环的长度<br>假设相遇点为B点,让其中一个指针停在B不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p><p>3）如何确定环的起点<br>假设相遇点为B点。方法是将其中一个指针移到链表起点，另一个指针为B点,两者同时移动，每次移动一步，那么两者相遇的地方就是环的起点。</p><h3 id="证明">证明</h3><p>首先假设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m，环的长度为n，相遇的位置与起点与起点位置距离为k。于是有：</p><p>i = m + a * n + k</p><p>其中a为慢指针走的圈数。</p><p>因为快指针的速度是慢指针的2倍，于是又可以得到另一个式子：</p><p>2 * i = m + b * n + k</p><p>其中b为快指针走的圈数。</p><p>两式相减得：</p><p>i = ( b - a ) * n</p><p>也就是说i是圈长的整数倍。</p><p>这是将其中一个节点放在起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点i+m，i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍一种常用的判圈算法，并给出其推导。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++之STL无序关联式容器unordered_map</title>
    <link href="https://zsh4614.cn/C-%E4%B9%8BSTL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8unordered-map/"/>
    <id>https://zsh4614.cn/C-%E4%B9%8BSTL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8unordered-map/</id>
    <published>2022-01-15T08:55:38.000Z</published>
    <updated>2022-01-15T09:19:39.450Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。</p><span id="more"></span><h3 id="引言">引言</h3><p>关联式容器，常被称为“无序容器”、“哈希容器”或者“无序关联容器”。注意，无序容器是 C++ 11 标准才正式引入到 STL 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><p>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p><ul><li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li><li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li></ul><p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p><p><img src="https://s2.loli.net/2022/01/15/NcwjdSUL5kMvG1o.png" alt="image.png"></p><h3 id="创建">创建</h3><p>unordered_map 容器模板的定义如下所示：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="STL" scheme="https://zsh4614.cn/tags/STL/"/>
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="unordered_map" scheme="https://zsh4614.cn/tags/unordered-map/"/>
    
  </entry>
  
  <entry>
    <title>C++之STL关联式容器map</title>
    <link href="https://zsh4614.cn/C-%E4%B9%8BSTL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8map/"/>
    <id>https://zsh4614.cn/C-%E4%B9%8BSTL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8map/</id>
    <published>2022-01-11T15:09:31.000Z</published>
    <updated>2022-01-15T08:33:07.464Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。</p><span id="more"></span><h3 id="pair">pair</h3><p>关联式容器存储的是“键值对”形式的数据，考虑到“键值对”并不是普通类型数据，C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素&lt;first, second&gt;。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</p><p>注意，pair 类模板定义在<utility>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span>) 默认构造函数，即创建空的 pair 对象</span><br><span class="line"><span class="built_in">pair</span>();</span><br><span class="line">#<span class="number">2</span>) 直接使用 <span class="number">2</span> 个元素初始化成 pair 对象</span><br><span class="line"><span class="built_in">pair</span> (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line">#<span class="number">3</span>) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span><br><span class="line">template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</span><br></pre></td></tr></table></figure><p>在 C++ 11 标准中，在引入右值引用的基础上，pair 类模板中又增添了如下 2 个构造函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">4</span>) 移动构造函数</span><br><span class="line">template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</span><br><span class="line">#<span class="number">5</span>) 使用右值引用参数，创建 pair 对象</span><br><span class="line">template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</span><br></pre></td></tr></table></figure><p>下面程序演示了以上几种创建 pair 对象的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;string, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair2</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair3</span>(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair4</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair5</span>(<span class="built_in">string</span>(<span class="string">&quot;Python教程&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序在创建 pair4 对象时，调用了 make_pair() 函数，它也是 <utility> 头文件提供的，其功能是生成一个 pair 对象。因此，当我们将 make_pair() 函数的返回值（<strong>是一个临时对象</strong>）作为参数传递给 pair() 构造函数时，<strong>其调用的是移动构造函数，而不是拷贝构造函数。</strong></p><p>在上面程序的基础上，C++ 11 还允许我们手动为 pair1 对象赋值，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair1.first &#x3D; &quot;Java教程&quot;;</span><br><span class="line">pair1.second &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;;</span><br><span class="line">cout &lt;&lt; &quot;new pair1: &quot; &lt;&lt; pair1.first &lt;&lt; &quot; &quot; &lt;&lt; pair1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>同时，上面程序中 pair4 对象的创建过程，还可以写入如下形式，它们是完全等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;string, string&gt; pair4 &#x3D; make_pair(&quot;C++教程&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;);</span><br><span class="line">cout &lt;&lt; &quot;pair4: &quot; &lt;&lt; pair4.first &lt;&lt; &quot; &quot; &lt;&lt; pair4.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><utility>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;=、&gt;、&gt;=、==、!= 这 6 的运算符，其运算规则是：<strong>对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。</strong></p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair1</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair2</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair3</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pair != pair2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pair2 != pair3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair !&#x3D; pair2</span><br><span class="line">pair2 !&#x3D; pair3</span><br></pre></td></tr></table></figure><p>最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，<strong>其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair1</span>(<span class="string">&quot;pair&quot;</span>, <span class="number">10</span>);                   </span><br><span class="line">    pair &lt;string, <span class="keyword">int</span>&gt; <span class="built_in">pair2</span>(<span class="string">&quot;pair2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.<span class="built_in">swap</span>(pair2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建map容器">创建map容器</h3><p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、使用结构体或类自定义的类型。</p><p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用std::less<T>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如std::greater<T>），也可以自定义排序规则。</p><p>另外需要注意的是，使用 map 容器存储的各个键值对，**键的值既不能重复也不能被修改。<strong>换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着</strong>只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。**前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 <strong>pair&lt;const K, T&gt;</strong> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p><p>map 容器的模板定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">T</span>,                                       // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,                     <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;pair&lt;<span class="keyword">const</span> Key,T&gt; &gt;    <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p><p>map 容器的模板类中包含多种构造函数，因此创建 map 容器的方式也有多种，下面就几种常用的创建 map 容器的方法，做一一讲解。</p><ol><li>通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap;</span><br></pre></td></tr></table></figure><p>通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此<strong>创建空 map 容器是比较常用的。</strong></p><ol start="2"><li>当然在创建 map 容器的同时，也可以进行初始化，比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>由此，myMap 容器在初始状态下，就包含有 2 个键值对。</p><p>再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>),std::<span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>)&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>除此之外，在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(myMap);</span><br></pre></td></tr></table></figure><p>由此，通过调用 map 容器的<strong>拷贝（复制）构造函数</strong>，即可成功创建一个和 myMap 完全一样的 newMap 容器。</p><p>C++ 11 标准中，还为 map 容器增添了移动构造函数。<strong>当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数</strong>。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建一个会返回临时 map 对象的函数</span><br><span class="line">std::map&lt;std::string,int&gt; disMap() &#123;</span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt;tempMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(<span class="built_in">disMap</span>());</span><br></pre></td></tr></table></figure><p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p><ol start="4"><li><strong>map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。例如：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;<span class="built_in">newMap</span>(++myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>这里，通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {“STL教程”,20} 键值对的容器。</p><ol start="5"><li>当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。<strong>默认情况下，map 容器调用 std::less<T> 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。</strong></li></ol><p>因此，如下 2 行创建 map 容器的方式，其实是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="keyword">int</span>, std::less&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="keyword">int</span>, std::greater&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="成员方法">成员方法</h3><p>下表列出了 map 容器提供的常用成员方法以及各自的功能。<br><img src="https://s2.loli.net/2022/01/11/TzhsVNtg2ewymAX.png" alt="image.png"></p><p>C++ STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较。</p><p>下面程序以 begin()/end() 组合为例，演示了如何遍历 map 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;      &#x2F;&#x2F; pair</span><br><span class="line">#include &lt;string&gt;       &#x2F;&#x2F; string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建并初始化 map 容器</span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;&#125;,&#123;&quot;C语言教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;&#125; &#125;;</span><br><span class="line">    &#x2F;&#x2F;调用 begin()&#x2F;end() 组合，遍历 map 容器</span><br><span class="line">    for (auto iter &#x3D; myMap.begin(); iter !&#x3D; myMap.end(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向<strong>迭代器</strong>；反之，其功能和 end() 方法相同。<strong>因为返回的是迭代器，因此最常用的是判断容器中有没有这个键值对：if (iter != map.end()){}</strong></p><p>同时，map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p><ul><li>lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；</li><li>upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；</li></ul><p>下面程序演示了它们的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//找到第一个键的值不小于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</p><p>equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p><p>显然，equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>  <span class="comment">//pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;std::map&lt;string, string&gt;::iterator, std::map&lt;string, string&gt;::iterator&gt; myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    <span class="comment">//通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，<strong>其返回的范围内最多也只有 1 个键值对。</strong></p><h3 id="获取键对应值">获取键对应值</h3><p>我们知道，map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p><p>注意，<strong>使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</strong></p><p>庆幸的是，map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。</p><ol><li>map 类模板中对[ ]运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。</li></ol><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    string cValue = myMap[<span class="string">&quot;C语言教程&quot;</span>];</span><br><span class="line">    cout &lt;&lt; cValue &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在第 11 行代码中，通过指定键的值为 “C语言教程”，借助重载的 [ ] 运算符，就可以在 myMap 容器中直接找到该键对应的值。</p><p><strong>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。</strong></p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt;myMap;</span><br><span class="line">    <span class="keyword">int</span> cValue = myMap[<span class="string">&quot;C语言教程&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，对于空的 myMap 容器来说，其内部没有以 “C语言教程” 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个&lt;“C语言教程”,0&gt;键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）</p><p>实际上，[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap;</span><br><span class="line">    myMap[<span class="string">&quot;STL教程&quot;</span>]=<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Python教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>;</span><br><span class="line">    myMap[<span class="string">&quot;STL教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，程序中第 9 行代码已经为 map 容器添加了一个以 “STL教程” 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。</strong></p><ol start="2"><li>除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不<strong>同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。</strong></li></ol><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;      &#x2F;&#x2F; map</span><br><span class="line">#include &lt;string&gt;   &#x2F;&#x2F; string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建并初始化 map 容器</span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;&#125;,</span><br><span class="line">                                             &#123;&quot;C语言教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;&#125;,</span><br><span class="line">                                             &#123;&quot;Java教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;&#125; &#125;;</span><br><span class="line">    cout &lt;&lt; myMap.at(&quot;C语言教程&quot;) &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;下面一行代码会引发 out_of_range 异常</span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; myMap.at(&quot;Python教程&quot;) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序第 12 行代码处，通过 myMap 容器调用  at() 成员方法，可以成功找到键为 “C语言教程” 的键值对，并返回该键对应的值；而第 14 行代码，由于当前 myMap 容器中没有以 “Python教程” 为键的键值对，会导致 at() 成员方法查找失败，并抛出 out_of_range 异常。</p><p>除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    map&lt; std::string, std::string &gt;::iterator myIter = myMap.<span class="built_in">find</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; myIter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; myIter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，此程序中如果 find() 查找失败，会导致第 13 行代码运行出错。因为当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。</p><p>如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。</p><p>本节所介绍的几种方法中，仅从“在 map 容器存储的键值对中，获取指定键对应的值”的角度出发，<strong>更推荐使用 at() 成员方法，因为该方法既简单又安全。</strong></p><h3 id="insert-方法">insert()方法</h3><p>map 类模板中提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p><p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，<strong>如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</strong></p><p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p><ol><li>无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、引用传递一个键值对</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">//2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line">    pair&lt;iterator,bool&gt; insert (P&amp;&amp; val);</span><br></pre></td></tr></table></figure><p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li><li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li></ul><p>以上 2 种语法格式的区别在于传递参数的方式不同，即无论是局部定义的键值对变量还是全局定义的键值对变量，都采用普通引用传递的方式；而对于临时的键值对变量，则以右值引用的方式传参。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    std::pair&lt;std::map&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(STL);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret.iter &#x3D; &lt;&#123;STL教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&#125;, 1&gt;</span><br><span class="line">ret.iter &#x3D; &lt;&#123;C语言教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&#125;, 1&gt;</span><br><span class="line">ret.iter &#x3D; &lt;&#123;STL教程, http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&#125;, 0&gt;</span><br></pre></td></tr></table></figure><p>从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：</p><ul><li>对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量</li><li>对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 “STL教程” 的键值对和值为 0 的 bool 变量。</li></ul><p>另外，在程序中的第 21 行代码，<strong>还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 pair 类模板的构造函数</span></span><br><span class="line">ret = mymap.<span class="built_in">insert</span>(pair&lt;string,string&gt;&#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;);</span><br><span class="line"><span class="comment">//调用 make_pair() 函数</span></span><br><span class="line">ret = mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li>除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p><ul><li>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</li><li>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.<span class="built_in">insert</span>(it, STL);</span><br><span class="line">    cout &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.<span class="built_in">insert</span>(it, std::pair&lt;string, string&gt;(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.<span class="built_in">insert</span>(it, std::pair&lt;string, string&gt;(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</strong></p><ol start="3"><li>insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是迭代器，它们的组合&lt;first,last&gt;可以表示某 map 容器中的指定区域。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    std::map&lt;string, string&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.<span class="built_in">insert</span>(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，vali 都表示的是键值对变量。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加 3 个键值对</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                   &#123; <span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span> &#125;,</span><br><span class="line">                   &#123; <span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，除了 insert() 方法，<strong>map 类模板还提供 emplace() 和 emplace_hint() 方法，它们也可以完成向 map 容器中插入键值对的操作，且效率还会比insert() 方法高</strong>。关于这 2 个方法，会在下一节做详细介绍。</p><h3 id="operator-和insert-效率对比">operator[]和insert()效率对比</h3><p>map 容器模板类中提供有 operator[ ] 和 insert() 这 2 个成员方法，而值得一提的是，这 2 个方法具有相同的功能，它们既可以实现向 map 容器中添加新的键值对元素，也可以实现更新（修改）map 容器已存储键值对的值。</p><p>显然，map 模板类中 operator[ ] 和 insert() 的功能发生了重叠，这就产生了一个问题，谁的执行效率更高呢？</p><p><strong>结论：当实现“向 map 容器中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。</strong></p><p>首先解释一下，为什么实现向 map 容器中添加新键值对元素，insert() 方法的执行效率比 operator[ ] 更高？回顾程序一中，如下语句完成了向空 mymap 容器添加新的键值对元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap[<span class="string">&quot;STL教程&quot;</span>] = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br></pre></td></tr></table></figure><p>此行代码中，mymap[“STL教程”] 实际上是 mymap.operator<a href="%E2%80%9CSTL%E6%95%99%E7%A8%8B%E2%80%9D"> </a> 的缩写（底层调用的 operator[ ] 方法），该方法会返回一个指向 “STL教程” 对应的 value 值的引用。</p><p>但需要注意的是，由于此时 mymap 容器是空的，并没有 “STL教程” 对应的 value 值。这种情况下，operator[ ] 方法会默认构造一个 string 对象，并将其作为 “STL教程” 对应的 value 值，然后返回一个指向此 string 对象的引用。在此基础上，代码还会将 “<a href="http://c.biancheng.net.java/">http://c.biancheng.net.java/</a>” 赋值给这个 string 对象。</p><p>也就是说，上面这行代码的执行流程，可以等效为如下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;string, string&gt; mstr;</span><br><span class="line"><span class="comment">//创建要添加的默认键值对元素</span></span><br><span class="line">pair&lt;mstr::iterator, <span class="keyword">bool</span>&gt;res = mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="built_in">string</span>()));</span><br><span class="line"><span class="comment">//将新键值对的值赋值为指定的值</span></span><br><span class="line">res.first-&gt;second = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以看到，使用 operator[ ] 添加新键值对元素的流程是，先构造一个有默认值的键值对，然后再为其 value 赋值。</p><p>那么，为什么不直接构造一个要添加的键值对元素呢，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br></pre></td></tr></table></figure><p>此行代码和上面程序的执行效果完全相同，但它省略了创建临时 string 对象的过程以及析构该对象的过程，同时还省略了调用 string 类重载的赋值运算符。由于可见，同样是完成向 map 容器添加新键值对，insert() 方法比 operator[ ] 的执行效率更高</p><p>仍以程序一中的代码为例，如下分别是 operator[ ] 和 insert() 实现更新 mymap 容器中指定键对应的值的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;operator[]</span><br><span class="line">mymap[&quot;STL教程&quot;] &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;;</span><br><span class="line">&#x2F;&#x2F;insert()</span><br><span class="line">std::pair&lt;string, string&gt; STL &#x3D; &#123; &quot;Java教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot; &#125;;</span><br><span class="line">mymap.insert(STL).first-&gt;second &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;;</span><br></pre></td></tr></table></figure><p>仅仅从语法形式本身来考虑，或许已经促使很多读者选择 operator[ ] 了。接下来，我们再从执行效率的角度对比以上 2 种实现方式。</p><p>从上面代码可以看到，insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构）。</p><p>而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。</p><h3 id="emplace-和emplace-hint-方法">emplace()和emplace_hint()方法</h3><p>和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：<br>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；<br>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</p><p>下面程序演示 emplace() 方法的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//插入键值对</span></span><br><span class="line">    pair&lt;map&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入新键值对</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//失败插入的样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p><p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p><ul><li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li><li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li></ul><p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p><h3 id="插入效率">插入效率</h3><p>上一节在学习 C++STL map 容器的 emplace() 和 emplace_hint() 的基本用法时，还遗留了一个问题，即为什么 emplace() 和 emplace_hint() 的执行效率会比 insert() 高？</p><p>原因很简单，它们向 map 容器插入键值对时，底层的实现方式不同：</p><ul><li>使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；</li><li>使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。</li></ul><p>也就是说，向 map 容器中插入键值对时，emplace() 和 emplace_hint() 方法都省略了移动键值对的过程，因此执行效率更高。下面程序提供了有利的证明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, testDemo&gt;mymap;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="built_in">testDemo</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace</span>( <span class="string">&quot;http://c.biancheng.net/stl/:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_hint():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert():</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace():</span><br><span class="line">调用构造函数</span><br><span class="line">emplace_hint():</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure><p>分析一下这个程序。首先，我们创建了一个存储 &lt;string,tempDemo&gt; 类型键值对的空 map 容器，接下来分别用 insert()、emplace() 和 emplace_hint() 方法向该 map 容器中插入相同的键值对。</p><p>从输出结果可以看出，在使用 insert() 方法向 map 容器插入键值对时，整个插入过程调用了 1 次 tempDemo 类的构造函数，同时还调用了 2 次移动构造函数。实际上，程序第 28 行代码底层的执行过程，可以分解为以下 3 步：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造类对象</span></span><br><span class="line">testDemo val = <span class="built_in">testDemo</span>(<span class="number">1</span>); <span class="comment">//调用 1 次构造函数</span></span><br><span class="line"><span class="comment">//构造键值对</span></span><br><span class="line"><span class="keyword">auto</span> pai = <span class="built_in">make_pair</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, val); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"><span class="comment">//完成插入操作</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(pai); <span class="comment">//调用 1 次移动构造函数</span></span><br></pre></td></tr></table></figure><p>而完成同样的插入操作，emplace() 和 emplace_hint() 方法都只调用了 1 次构造函数，这足以证明，这 2 个方法是在 map 容器内部直接构造的键值对。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++的STL中的关联式容器map，包括其接口，用法和注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="STL" scheme="https://zsh4614.cn/tags/STL/"/>
    
    <category term="map" scheme="https://zsh4614.cn/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>C++之STL关联式容器set</title>
    <link href="https://zsh4614.cn/C-STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set/"/>
    <id>https://zsh4614.cn/C-STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set/</id>
    <published>2022-01-10T15:01:04.000Z</published>
    <updated>2022-01-10T16:40:50.027Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++的STL中的关联式容器set，包括其接口，用法和注意事项。</p><span id="more"></span><h3 id="综述">综述</h3><p>set本质上也是一种关联式容器，只是在存储键值对时，要求键值必须相等。举个例子，如下有 2 组键值对数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;&#39;a&#39;, 1&gt;, &lt;&#39;b&#39;, 2&gt;, &lt;&#39;c&#39;, 3&gt;&#125;</span><br><span class="line">&#123;&lt;&#39;a&#39;, &#39;a&#39;&gt;, &lt;&#39;b&#39;, &#39;b&#39;&gt;, &lt;&#39;c&#39;, &#39;c&#39;&gt;&#125;</span><br></pre></td></tr></table></figure><p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而<strong>无法存储第一组键值对</strong>。</p><p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,‘b’,‘c’} ，该容器即可成功将它们存储起来。</p><p>set容器会自行根据键的大小对存储的键值对进行排序。另外，使用 set 容器存储的<strong>各个元素的值必须各不相同</strong>。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。<strong>切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</strong></p><p>set 容器的类模板定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;T&gt;,        <span class="comment">// 指定 set 容器内部的排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;T&gt;      <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure><p>注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。</p><h3 id="创建">创建</h3><p>常见的创建 set 容器的方法，大致有以下 5 种。</p><ol><li>调用默认构造函数，创建空的 set 容器。比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure><p>由此就创建好了一个 set 容器，该容器采用默认的std::less<T>规则，会对存储的 string 类型元素做升序排序。注意，<strong>由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</strong></p><ol start="2"><li>除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123;<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure><p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p><p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> myset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure><p>注意，<strong>由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数</strong></p><ol start="4"><li>在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(++myset.begin(), myset.end())</span></span>;</span><br></pre></td></tr></table></figure><p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>以上几种方式创建的 set 容器，都采用了默认的std::less<T>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset&#123;</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>通过选用 std::greater<string> 降序规则，myset 容器中元素的存储顺序为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;</span><br></pre></td></tr></table></figure><h3 id="成员方法">成员方法</h3><p>下表列出了 set 容器提供的常用成员方法以及各自的功能。</p><p><img src="https://s2.loli.net/2022/01/10/ldfXza6AqFe25Np.png" alt="image.png"></p><h3 id="迭代器">迭代器</h3><p>和其他容器不同，set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，<strong>要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</strong></p><p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。</p><p>注意，set成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，set成员方法返回的迭代器，<strong>无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值</strong>。</p><p>下面程序以 begin()/end() 为例，演示了如何使用图 2 中相关迭代器遍历 set 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p><p><strong>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</strong></p><p>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</p><h3 id="insert-方法">insert()方法</h3><p>为满足不同场景的需要，C++ 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">//右值引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);</span><br></pre></td></tr></table></figure><p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式。</p><p><strong>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</strong></p><ul><li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li><li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;set&lt;string&gt;::iterator, <span class="keyword">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter-&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F; bool &#x3D; 1</span><br><span class="line">iter-&gt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F; bool &#x3D; 1</span><br></pre></td></tr></table></figure><p>通过观察输出结果不难看出，程序中两次借助 insert() 方法向 set 容器中添加元素，都成功了。</p><ol start="2"><li>insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</li><li>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">end</span>(),<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size &#x3D;1</span><br><span class="line">myset size &#x3D;2</span><br></pre></td></tr></table></figure><p>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，<strong>insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</strong></p><ol start="3"><li>insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。</li></ol><p>insert() 方法的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class InputIterator&gt;</span><br><span class="line">  void insert (InputIterator first, InputIterator last);</span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//创建一个同类型的空 set 容器</span></span><br><span class="line">    std::set&lt;std::string&gt; otherset;</span><br><span class="line">    <span class="comment">//利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.<span class="built_in">insert</span>(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;</span><br></pre></td></tr></table></figure><p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p><ol start="4"><li>采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert ( &#123;E1, E2,...,En&#125; );</span><br></pre></td></tr></table></figure><p>其中，Ei 表示新添加的元素。</p><p>值的一提的是，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为<strong>implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高</strong>。</p><h3 id="emplace-和emplace-hint-方法">emplace()和emplace_hint()方法</h3><p>emplace() 和 emplace_hint() 是 C++ 11 标准加入到 set 类模板中的，相比具有同样功能的 insert() 方法，完成同样的任务，emplace() 和 emplace_hint() 的效率会更高。</p><p>emplace() 方法的语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>其中，参数 (Args&amp;&amp;… args) 指的是，只需要传入构建新元素所需的数据即可，该方法可以自行利用这些数据构建出要添加的元素。**比如，若 set 容器中存储的元素类型为自定义的结构体或者类，则在使用 emplace() 方法向容器中添加新元素时，构造新结构体变量（或者类对象）需要多少个数据，就需要为该方法传入相应个数的数据。<br>**</p><p>另外，该方法的返回值类型为 pair 类型，其包含 2 个元素，一个迭代器和一个 bool 值：</p><ul><li>当该方法将目标元素成功添加到 set 容器中时，其返回的迭代器指向新插入的元素，同时 bool 值为 true；</li><li>当添加失败时，则表明原 set 容器中已存在相同值的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时 bool 值为 false。</li></ul><p>下面程序演示 emplace() 方法的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;set&lt;string, string&gt;::iterator, <span class="keyword">bool</span>&gt; ret = myset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&quot;</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size &#x3D; 1</span><br><span class="line">ret.iter &#x3D; &lt;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;, 1&gt;</span><br></pre></td></tr></table></figure><p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p><p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>和 emplace() 方法相比，有以下 2 点不同：</p><ul><li>该方法需要额外传入一个迭代器，用来指明新元素添加到 set 容器的具体位置（<strong>新元素会添加到该迭代器指向元素的前面</strong>）；</li><li>返回值是一个迭代器，而不再是 pair 对象。当成功添加元素时，返回的迭代器指向新添加的元素；反之，如果添加失败，则迭代器就指向 set 容器和要添加元素的值相同的元素。</li></ul><p>下面程序演示 emplace_hint() 方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//在 set 容器的指定位置添加键值对</span></span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">emplace_hint</span>(myset.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size &#x3D; 1</span><br><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;</span><br></pre></td></tr></table></figure><p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法中指定了添加新元素的位置，但 set 容器为了保持数据的有序状态，可能会移动其位置。</p><p>以上内容讲解了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的。</p><h3 id="erase-和clear-方法">erase()和clear()方法</h3><p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p><p>set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，<strong>表示成功删除的元素个数</strong>；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中<strong>删除元素之后的第一个元素</strong>。</p><p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p><p>如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>显然，该方法不需要传入任何参数，也没有任何返回值。</p><p>疑问：<br>1.既然const的迭代器和非const的迭代器都不能修改值，那有什么区别？<br>2.右值引用<br>3.为什么emplace没有返回值也能调用成功，是所有函数都这样吗？<br>4.emplace效率高的原因？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++的STL中的关联式容器set，包括其接口，用法和注意事项。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="set" scheme="https://zsh4614.cn/tags/set/"/>
    
    <category term="STL" scheme="https://zsh4614.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一四一题：环形链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E5%9B%9B%E4%B8%80%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%B8%80%E5%9B%9B%E4%B8%80%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-09T15:19:12.000Z</published>
    <updated>2022-01-10T14:58:13.569Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍leetcode第一四一题，判断一个链表是否有环，并给出其实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><h3 id="示例">示例</h3><p><strong>示例1</strong></p><p><img src="https://s2.loli.net/2022/01/09/TPnu4a8cX2GUMkJ.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://s2.loli.net/2022/01/09/QzmCcjGbatMUu1E.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p><img src="https://s2.loli.net/2022/01/09/QncUVqxFeY8jEyl.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 [0, 10^4]</li><li>10^5 &lt;= Node.val &lt;= 10^5</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><h3 id="分析">分析</h3><p>本题目最容易想到的是遍历链表，在遍历的过程中把每个结点存储起来，同时查询存储的里面是否有当前结点，如果有，那么说明是个环，如果遍历完没有，说明没有环；但是链表判圈有更加适合的判圈算法——<strong>佛洛依德判圈算法</strong>。</p><h3 id="实现">实现</h3><h4 id="实现一（哈希）">实现一（哈希）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; hashset;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.<span class="built_in">find</span>(head) != hashset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashset.<span class="built_in">emplace</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h4 id="实现二（判圈算法）">实现二（判圈算法）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    slow-&gt;next = head;</span><br><span class="line">    ListNode *fast = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p><strong>注意开始的状态，要把slow和fast定义为不同的指针，否则直接就输出true了，总而言之，一定要保证特殊情况下，尤其是开始状态的正确性</strong></p><h3 id="拓展">拓展</h3><p>1.<a href="">哈希容器（无序关联式容器）</a></p><p>2.<a href="">佛洛依德判圈算法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍leetcode第一四一题，判断一个链表是否有环，并给出其实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="哈希" scheme="https://zsh4614.cn/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="判圈算法" scheme="https://zsh4614.cn/tags/%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第二十一题：合并两个有序链表</title>
    <link href="https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://zsh4614.cn/LeetCode%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E9%A2%98%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-09T15:12:40.000Z</published>
    <updated>2022-01-09T15:16:32.080Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第二十一题，合并两个有序链表，用迭代和递归两种方法实现。</p><span id="more"></span><h3 id="题目">题目</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="示例">示例</h3><p><img src="https://s2.loli.net/2022/01/09/L8AQHIcVbtk1ZUe.png" alt="image.png"></p><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;= s.length &lt;= 5 * 104</li><li>s由英文字母、数字、符号和空格组成</li></ul><h3 id="分析">分析</h3><p>该题目常规思路就是迭代两个链表的结点，比较大小，小的往后面移动一个结点，然后再比较大小，如此迭代下去，直到一个链表指针域为空，然后把另一个链表接上即可；另一种思路是递归，这种方法比较巧妙</p><p><img src="https://s2.loli.net/2022/01/09/BrE9Dsg1YaKXQvc.png" alt="image.png"></p><p>但是需要考虑其中一个为空的情况，作为迭代的出口。</p><h3 id="实现">实现</h3><h4 id="方法一-迭代">方法一(迭代)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode *work = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *dummy = work;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* &amp;tmp = list1-&gt;val &lt; list2-&gt;val ? list1 : list2;</span><br><span class="line">        work-&gt;next = tmp;</span><br><span class="line">        work = work-&gt;next;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    work-&gt;next = (list1 == <span class="literal">nullptr</span>) ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-递归">方法二(递归)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">        list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>链表中常用到dummy结点，用来解决头结点问题，这样可以使得头结点和一般结点没有什么区别，注意灵活应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第二十一题，合并两个有序链表，用迭代和递归两种方法实现。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://zsh4614.cn/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="https://zsh4614.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://zsh4614.cn/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>C++动态多态</title>
    <link href="https://zsh4614.cn/C-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"/>
    <id>https://zsh4614.cn/C-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/</id>
    <published>2021-12-30T02:23:05.000Z</published>
    <updated>2022-01-09T15:12:00.807Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍c++动态多态（polymorphism），其核心机制为虚函数。</p><span id="more"></span><h4 id="初步印象">初步印象</h4><p>多态（polymorphism）是面向对象编程语言的一大特点，而虚函数是实现多态的机制。其核心理念就是通过基类访问派生类定义的函数。多态性使得程序调用的函数是在<strong>运行时动态确定</strong>的，而不是在编译时静态确定的。使用一个基类类型的指针或者引用，来指向子类对象，进而调用由子类复写的个性化的虚函数，这是C++实现多态性的一个最经典的场景。</p><ul><li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func()</li><li>纯虚函数，在虚函数后加“=0”，如 virtual void func()=0</li><li>对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。</li><li>对于纯虚函数，子类必须提供纯虚函数的个性化实现。</li></ul><p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了“多态”特性。但区别是：</p><ul><li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；</li><li>**子类如果不提供纯虚函数的实现，编译将会失败。**尽管在基类中可以给出纯虚函数的实现，但无法通过指向子类对象的基类类型指针来调用该纯虚函数，也即不能作为子类相应纯虚函数的备选方案。（纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路。）</li></ul><h4 id="虚函数">虚函数</h4><p>placehoder[此处插入代码]</p><p>在上述例子中，我们首先定义了一个基类base，基类有一个名为vir_func的虚函数，和一个名为func的普通成员函数。类A，B都是由类base派生的子类。然后我们定义三个base*类型的指针Base、a、b分别指向类base、A、B。可以看到，当使用这三个指针调用func函数时，调用的都是基类base的函数。而使用这三个指针调用虚函数vir_func时，调用的是指针指向的实际类型的函数。最后，我们将指针b做强制类型转换，转换为A*类型，然后分别调用func和vir_func函数，发现普通函数调用的是类A的函数，而虚函数调用的是类B的函数。以上，我们可以得出结论**“当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定”**。</p><p>对于一个只包含非静态成员变量和普通成员函数的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  void fun_a();</span><br><span class="line">  void fun_b();</span><br><span class="line">  int var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中成员函数放在代码区，为该类的所有对象公有，即不管新建多少个该类的对象，所对应的都是同一个函数存储区的函数。而成员变量则为各个对象所私有，即每新建一个对象都会新建一块内存区用来存储var值。在调用成员函数时，程序会根据类的类型，找到对应代码区所对应的函数并进行调用。</p><p>在上面例子中，Base、a、b都是base类型的指针。调用普通函数时，程序根据指针的类型到类base所对应的代码区找到所对应的函数，所以都调用了类base的func函数，即指针的类型决定了普通函数的调用。</p><p>那么包含虚函数的类又是怎样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class D&#123;</span><br><span class="line">  void func_a();</span><br><span class="line">  virtual void func_b();</span><br><span class="line">  int var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时如果sizeof一个类D的对象，会发现比类C的对象大4个字节。多出来的这4个字节就是实现虚函数的关键----<strong>虚函数表指针vptr</strong>。这个指针指向一张名为“虚函数表”（vtbl）的表，而表中的数据则为函数指针，存储了虚函数fun_b()具体实现所对应的位置。注意，**普通函数、虚函数、虚函数表都是同一个类的所有对象公有的，只有成员变量和虚函数表指针是每个对象私有的，sizeof的值也只包括vptr和var所占内存的大小，并且vptr通常会在对象内存的最起始位置。另外，当类有多个虚函数时，仍然只有一个虚函数表指针vptr（指向一个虚函数表），而此时的虚函数表vtbl中会有多个函数指针，分别指向对应的虚函数实现区域。**因此，<strong>虚函数实现的过程是：通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。所以虚函数的调用时由指针所指向内存块的具体类型决定的。</strong></p><h4 id="纯虚函数">纯虚函数</h4><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。</p><p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p><p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p><p>含有纯虚函数的类称之为抽象类，**它不能生成对象（创建实例），只能创建它的派生类的实例。**抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</p><p><strong>抽象类只能作为基类来使用</strong>，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p><h4 id="选用时机">选用时机</h4><p>当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。<br>当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数</p><h4 id="构造函数和析构函数">构造函数和析构函数</h4><p>构造函数和析构函数可以是虚函数吗？</p><p>答案是：<strong>构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</strong></p><p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p><p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p><blockquote><p>转载于：<a href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍c++动态多态（polymorphism），其核心机制为虚函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="虚函数" scheme="https://zsh4614.cn/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="动态多态" scheme="https://zsh4614.cn/tags/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81/"/>
    
    <category term="纯虚函数" scheme="https://zsh4614.cn/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++11线程池</title>
    <link href="https://zsh4614.cn/C-11%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://zsh4614.cn/C-11%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-12-08T03:51:59.000Z</published>
    <updated>2022-01-09T15:12:00.807Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍线程池，并基于C++11实现。</p><span id="more"></span><h3 id="背景">背景</h3><p>传统多线程方案是：接受一个任务之后，创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么将处于不停的创建线程，销毁线程的状态。我们将传统方案中的线程执行过程分为三个过程：线程创建时间+线程执行时间+线程销毁时间，如果线程执行时间很短的话，线程本身开销占的比重将会很大，这个开销将不可忽略。另外每个 Thread 都需要有一个内核线程的支持，也就意味着每个Thread都需要消耗一定的内核资源（如内核线程的栈空间），因为能创建的 Thread 是有限的，默认一个线程的线程栈大小是1M，如果每来一个任务就创建一个线程的话，1024个任务就会创建1024个线程，就会占用1个G的内存，很容易就系统崩溃了。</p><p>因此，线程池的出现正是着眼于线程本身的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Ptr = std::shared_ptr&lt;ThreadPool&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">int</span> idl_thr_num) : <span class="built_in">run_</span>(<span class="literal">true</span>), <span class="built_in">idl_thr_num_</span>(idl_thr_num) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idl_thr_num_; ++i) &#123;</span><br><span class="line">            pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]&#123;  <span class="comment">// 工作线程函数</span></span><br><span class="line">                <span class="keyword">while</span> (run_) &#123;</span><br><span class="line">                    Task task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; lock&#123; mutex_ &#125;;</span><br><span class="line">                        cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> !run_ || !task_.<span class="built_in">empty</span>(); &#125;);  <span class="comment">// 等待直到任务队列有任务或者线程池停止工作</span></span><br><span class="line">                        <span class="keyword">if</span> (!run_ &amp;&amp; task_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(task_.<span class="built_in">front</span>());  <span class="comment">// 从任务队列首取出一个任务</span></span><br><span class="line">                        task_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    idl_thr_num_--;</span><br><span class="line">                    <span class="built_in">task</span>();  <span class="comment">// 执行任务</span></span><br><span class="line">                    idl_thr_num_++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        run_ = <span class="literal">false</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; thread : pool_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">                thread.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idlCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idl_thr_num_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">    auto commit(F&amp;&amp; f, Args&amp;&amp;... args)-&gt;std::future&lt;decltype(f(args...))&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!run_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;commit on ThreadPool is stopped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 函数f的返回值类型</span></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        std::future&lt;RetType&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; lock&#123;mutex_ &#125;;</span><br><span class="line">            task_.<span class="built_in">emplace</span>([task]()&#123; (*task)(); &#125;);  <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_one</span>();  <span class="comment">// 唤醒一个线程</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">    std::vector&lt;std::thread&gt; pool_;             <span class="comment">// 线程池</span></span><br><span class="line">    std::queue&lt;Task&gt; task_;                     <span class="comment">// 任务队列</span></span><br><span class="line">    std::mutex mutex_;                          <span class="comment">// 线程锁</span></span><br><span class="line">    std::condition_variable cv_;                <span class="comment">// 条件阻塞</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">bool</span>&gt; run_;                     <span class="comment">// 线程池是否执行标志</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">int</span>&gt; idl_thr_num_;              <span class="comment">// 空闲线程数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="简单使用">简单使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在执行第 %d 个任务， 线程id为 %d\n&quot;</span>, i, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">2000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行完成第 %d 个任务， 线程id为 %d\n&quot;</span>, i, std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主线程id为 &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    ThreadPool::Ptr thread_pool_ptr = std::make_shared&lt;ThreadPool&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        thread_pool_ptr-&gt;<span class="built_in">commit</span>([i]()&#123;<span class="built_in">task</span>(i);&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码链接：<a href="https://github.com/zsh4614/thread_pool">https://github.com/zsh4614/thread_pool</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍线程池，并基于C++11实现。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="多线程" scheme="https://zsh4614.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://zsh4614.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程池" scheme="https://zsh4614.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>多传感器时间同步机制</title>
    <link href="https://zsh4614.cn/ros%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>https://zsh4614.cn/ros%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2021-11-25T07:07:02.000Z</published>
    <updated>2022-01-09T15:12:00.807Z</updated>
    
    <content type="html"><![CDATA[<p>引言：多传感器时间同步是高级辅助驾驶系统和自动驾驶中必不可少的关键步骤，本文主要介绍一种多传感器时间同步的方法，并进行了C++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>多传感器时间同步就是把不同传感器发出的message序列在时间上进行匹配，比如有多个激光雷达，多个摄像头，多个radar，以及组合惯导等传感器，在系统启动后，这些传感器都在以一定的频率往外部发送消息，那么某一时刻而言，究竟取这些传感器的哪一个消息，才是同一时刻的呢？这些传感器的频率可能不同，但是每一帧消息应该都有一个时间戳，代表这个消息是哪个时间产生的，比如一共有20个传感器，同步好的代表当前的所有消息应该也是20帧，他们之间的时间戳应该一致，但是由于频率不一致，所以很难保证具有完全相同的时间戳，所以退而求其次，可以在一定的时间范围内认为这20个消息是同步的，他们应该满足一个条件，就是不应该存在另一个选择，使得这20个消息的时间跨度（最早时间和最晚时间之差）小于当前的时间跨度，这样才认为这个同步是正确的，ros实现了这种时间同步的方法，下面将对其使用方法和原理进行详细说明，由于该算法比较绕，考虑的情况也比较多，个人也只是一知半解。</p><h3 id="使用方法">使用方法</h3><p>下面是一个4个激光雷达产生的点云消息和1个组合惯导产生的pose消息，其中雷达发出的点云消息为10hz，惯导产生的pose消息为100hz。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/subscriber.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/synchronizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message_filters/sync_policies/approximate_time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg0,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg1,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg2,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> sensor_msgs::PointCloud2ConstPtr &amp;msg3,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> geometry_msgs::PoseStampedConstPtr &amp;msg4)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; <span class="string">&quot;/back_lidar: &quot;</span> &lt;&lt; msg3-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/left_lidar: &quot;</span> &lt;&lt; msg1-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/middle_lidar: &quot;</span> &lt;&lt; msg0-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/pose_stamp: &quot;</span> &lt;&lt; msg4-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl</span><br><span class="line">                            &lt;&lt; <span class="string">&quot;/right_lidar: &quot;</span> &lt;&lt; msg2-&gt;header.stamp.<span class="built_in">toSec</span>() &lt;&lt; std::endl;</span><br><span class="line">                            </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------------------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;ros_sync_test&quot;</span>);</span><br><span class="line">    ros::NodeHandlePtr node_ptr;</span><br><span class="line">    node_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> ros::NodeHandle);</span><br><span class="line"></span><br><span class="line">    std::string topic0, topic1, topic2, topic3, topic4;</span><br><span class="line">    topic0 = <span class="string">&quot;/mems_front/rslidar_points&quot;</span>;</span><br><span class="line">    topic1 = <span class="string">&quot;/mems_left/rslidar_points&quot;</span>;</span><br><span class="line">    topic2 = <span class="string">&quot;/mems_right/rslidar_points&quot;</span>;</span><br><span class="line">    topic3 = <span class="string">&quot;/mems_back/rslidar_points&quot;</span>;</span><br><span class="line">    topic4 = <span class="string">&quot;/loc/car_pose_1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic0</span><span class="params">(*node_ptr, topic0, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic1</span><span class="params">(*node_ptr, topic1, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic2</span><span class="params">(*node_ptr, topic2, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; <span class="title">sub_topic3</span><span class="params">(*node_ptr, topic3, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">message_filters::Subscriber&lt;geometry_msgs::PoseStamped&gt; <span class="title">sub_topic4</span><span class="params">(*node_ptr, topic4, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> message_filters::sync_policies::ApproximateTime&lt;sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            sensor_msgs::PointCloud2,</span><br><span class="line">                                                            geometry_msgs::PoseStamped&gt; syncPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function">message_filters::Synchronizer&lt;syncPolicy&gt; <span class="title">sync</span><span class="params">(syncPolicy(<span class="number">100</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic3,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        sub_topic4)</span></span>;</span><br><span class="line"></span><br><span class="line">    sync.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;callback, _1, _2, _3, _4, _5));</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>syncPolicy(100)中的100是每个消息队列的最大长度，如果某个消息队列缓存长度大于100（即连续100个消息还没有同步上），就会产生问题，所以这个尽可能设置的大一些。</p><h3 id="算法实现">算法实现</h3><p>ros规定这种时间同步机制最多支持9个不同的消息，下面在不改变算法原理的基础上进行了异步实现，且不限制同步的消息个数。</p><p><a href="https://github.com/zsh4614/time_sync">github代码链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：多传感器时间同步是高级辅助驾驶系统和自动驾驶中必不可少的关键步骤，本文主要介绍一种多传感器时间同步的方法，并进行了C++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="ADAS和自动驾驶" scheme="https://zsh4614.cn/categories/ADAS%E5%92%8C%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
    
    
    <category term="时间同步" scheme="https://zsh4614.cn/tags/%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++11之匿名函数</title>
    <link href="https://zsh4614.cn/C-11%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://zsh4614.cn/C-11%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-19T04:00:12.000Z</published>
    <updated>2021-12-01T17:30:30.010Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍C++11新特性的lambda函数用法。</p><span id="more"></span><h3 id="语法格式及含义">语法格式及含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>[外部变量访问方式说明符]</li></ul><p>[]是lambda表达式标识符，不可省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量。所谓外部变量，指的是和当前 lambda 表达式<strong>位于同一作用域内的所有局部变量</strong>。注意区分外部变量和全局变量。外部变量格式有如下几种书写方式：</p><table><thead><tr><th>外部变量格式</th><th>功能</th></tr></thead><tbody><tr><td>[]</td><td>空方括号表示当前 lambda 匿名函数中<strong>不导入</strong>任何外部变量。</td></tr><tr><td>[=]</td><td>只有一个 = 等号，表示以值传递的方式<strong>导入所有</strong>外部变量；</td></tr><tr><td>[&amp;]</td><td>只有一个 &amp; 符号，表示以引用传递的方式<strong>导入所有</strong>外部变量；</td></tr><tr><td>[val1,val2,…]</td><td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td></tr><tr><td>[&amp;val1,&amp;val2,…]</td><td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td></tr><tr><td>[val,&amp;val2,…]</td><td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td></tr><tr><td>[=,&amp;val1,…]</td><td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td></tr><tr><td>[&amp;,val1,…]</td><td>表示除 val1 以值传递的方式导入外，其它外部变量都以引用传递的方式导入。</td></tr><tr><td>[this]</td><td>表示以值传递的方式导入当前的 this 指针。</td></tr></tbody></table><blockquote><p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p></blockquote><ul><li>(参数)</li></ul><p>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，<strong>如果不需要传递参数，可以连同 () 小括号一起省略</strong>；</p><ul><li>mutable</li></ul><p>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。（修改的是拷贝的那一份，并不会修改真正的外部变量）</p><ul><li>noexcept/throw()</li></ul><p>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败。</p><ul><li>-&gt; 返回值类型</li></ul><p>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略。</p><ul><li>函数体</li></ul><p>除了可以使用传入参数外，还可以使用指定的外部变量和全局变量。（外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍C++11新特性的lambda函数用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://zsh4614.cn/categories/C/"/>
    
    
    <category term="C++11" scheme="https://zsh4614.cn/tags/C-11/"/>
    
    <category term="lambda函数" scheme="https://zsh4614.cn/tags/lambda%E5%87%BD%E6%95%B0/"/>
    
    <category term="匿名函数" scheme="https://zsh4614.cn/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>经典算法：拉默-道格拉斯-普克算法</title>
    <link href="https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://zsh4614.cn/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/</id>
    <published>2021-11-18T07:56:45.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍RDP算法。道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。</p><span id="more"></span><h3 id="算法步骤">算法步骤</h3><ol><li>连接曲线首尾两点A、B形成一条直线AB；<br>2. 计算曲线上离该直线段距离最大的点C，计算其与AB的距离d；</li><li>比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则以该直线作为曲线的近似，该段曲线处理完毕。</li><li>如果距离大于阈值，则用点C将曲线分为两段AC和BC，并分别对两段曲线进行步骤[1~3]的处理。</li><li>当所有曲线都处理完毕后，依次连接各个分割点形成折线，作为原曲线的近似。</li></ol><h3 id="实现">实现</h3><h4 id="实现一">实现一</h4><p>下面采用 C++实现，是一个DFS深搜的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; in_pts, </span></span></span><br><span class="line"><span class="function"><span class="params">         std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">float</span> epsilon = <span class="number">0.1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = in_pts.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">mask</span><span class="params">(size, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    std::pair&lt;int, int&gt; pts_pair(0, size-1);</span><br><span class="line">    std::stack&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(pts_pair);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur_pair = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">float</span> dmax = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur_pair.first + <span class="number">1</span>; i &lt; cur_pair.second; ++i) &#123;</span><br><span class="line">            <span class="keyword">float</span> d = <span class="built_in">getPerpendicularDistance</span>(in_pts[cur_pair.first], in_pts[cur_pair.second], in_pts[i]);</span><br><span class="line">            <span class="keyword">if</span> (d &gt; dmax) &#123;</span><br><span class="line">                dmax = d;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dmax &gt; epsilon) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(cur_pair.first, i));</span><br><span class="line">            stack.<span class="built_in">push</span>(std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, cur_pair.second));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mask[cur_pair.first] = <span class="literal">true</span>;</span><br><span class="line">            mask[cur_pair.second] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(size);</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i]) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPerpendicularDistance()函数是求点到线的距离函数，有两种方法，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：利用点到直线的距离公式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, maxDist = <span class="number">0</span>;</span><br><span class="line">    A = lineEnd.y - lineStart.y;</span><br><span class="line">    B = lineStart.x - lineEnd.x;</span><br><span class="line">    C = lineEnd.x * lineStart.y - lineStart.x * lineEnd.y;</span><br><span class="line">    maxDist = <span class="built_in">fabs</span>((A * pt.x + B * pt.y + C) / <span class="built_in">sqrt</span>(A * A + B *B));</span><br><span class="line">    <span class="keyword">return</span> maxDist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：利用向量运算</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">getPerpendicularDistance</span><span class="params">(<span class="keyword">const</span> T &amp;lineStart, <span class="keyword">const</span> T &amp;lineEnd, <span class="keyword">const</span> T &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = lineEnd.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> dy = lineEnd.y - lineStart.y;</span><br><span class="line">    <span class="keyword">float</span> mag = std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(dx, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(dy, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (mag &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        dx /= mag;</span><br><span class="line">        dy /= mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> pvx = pt.x - lineStart.x;</span><br><span class="line">    <span class="keyword">float</span> pvy = pt.y - lineStart.y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> pvdot = dx * pvx + dy * pvy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> dsx = pvdot * dx;</span><br><span class="line">    <span class="keyword">float</span> dsy = pvdot * dy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> ax = pvx - dsx;</span><br><span class="line">    <span class="keyword">float</span> ay = pvy - dsy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pow</span>(std::<span class="built_in">pow</span>(ax, <span class="number">2.0</span>) + std::<span class="built_in">pow</span>(ay, <span class="number">2.0</span>), <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现二">实现二</h4><p>有时需要对polygon（闭合）的点数进行限制，抽取出固定数量的点，这种情况下，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifiedRDP</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt; &amp;in_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        std::vector&lt;T&gt; &amp;out_pts,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> n_pts = <span class="number">64</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>()) &lt;= n_pts) &#123;</span><br><span class="line">        out_pts = in_pts;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SimData</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l_idx;</span><br><span class="line">        <span class="keyword">int</span> r_idx;</span><br><span class="line">        <span class="keyword">float</span> epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">std::vector&lt;SimData&gt; <span class="title">mask</span><span class="params">(in_pts.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;sim_data = mask[i];</span><br><span class="line">        sim_data.l_idx = i - <span class="number">1</span>;</span><br><span class="line">        sim_data.r_idx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            sim_data.l_idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i) == <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(mask.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            sim_data.r_idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sim_data.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[i], in_pts[sim_data.l_idx], in_pts[sim_data.r_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> comp = [](<span class="keyword">const</span> SimData &amp;i, <span class="keyword">const</span> SimData &amp;j) &#123;</span><br><span class="line">        <span class="keyword">return</span> i.epsilon &lt; j.epsilon;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (cc &gt; n_pts) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = std::<span class="built_in">min_element</span>(mask.<span class="built_in">begin</span>(), mask.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(std::<span class="built_in">distance</span>(mask.<span class="built_in">begin</span>(), res));</span><br><span class="line">        <span class="comment">// 找到距离最小的点，标记并把其距离置为无穷大</span></span><br><span class="line">        maks[idx].flag = <span class="literal">false</span>;</span><br><span class="line">        mask[idx].epsilon = std::numeric_limits&lt;<span class="keyword">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        cc--;</span><br><span class="line">        <span class="comment">// 更新该点的左右邻居</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;l_mask = mask[res-&gt;l_idx];</span><br><span class="line">        l_mask.r_idx = res-&gt;r_idx;</span><br><span class="line">        l_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;l_idx], in_pts[l_mask.l_idx], in_pts[l_mask.r_idx]);</span><br><span class="line">        <span class="keyword">auto</span> &amp;r_mask = mask[res-&gt;r_idx];</span><br><span class="line">        r_mask.l_idx = res-&gt;l_idx;</span><br><span class="line">        r_mask.epsilon = <span class="built_in">getPerpendicularDistance</span>(in_pts[res-&gt;r_idx], in_pts[r_mask.l_idx], in_pts[r_mask.l_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    out_pts.<span class="built_in">reserve</span>(in_pts.<span class="built_in">size</span>());</span><br><span class="line">    out_pts.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mask.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask[i].flag) &#123;</span><br><span class="line">            out_pts.<span class="built_in">emplace_back</span>(in_pts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_pts.<span class="built_in">resize</span>(out_pts.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>本文主要总结了RDP算法的dfs实现，其原始版本是递归实现的，至于那个版本的实现更快，还需要进一步论述，但是在工程代码中，不推荐使用递归；点到直线的距离计算效率，也需要benchmark进行测试比较。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍RDP算法。道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。&lt;/p&gt;</summary>
    
    
    
    <category term="经典算法" scheme="https://zsh4614.cn/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dfs" scheme="https://zsh4614.cn/tags/dfs/"/>
    
    <category term="几何算法" scheme="https://zsh4614.cn/tags/%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95/"/>
    
    <category term="拉默-道格拉斯-普克算法" scheme="https://zsh4614.cn/tags/%E6%8B%89%E9%BB%98-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>粗浅理解</title>
    <link href="https://zsh4614.cn/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <id>https://zsh4614.cn/%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/</id>
    <published>2021-11-17T03:12:28.000Z</published>
    <updated>2021-12-01T17:30:30.016Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要总结对于机器学习和深度学习领域一些比较片面粗浅的理解，包含的范围比较杂乱，在此做一个记录。</p><span id="more"></span><h3 id="一、对于CNN和Transformer的对比">一、对于CNN和Transformer的对比</h3><p>CNN使用了较强的归纳偏置（inductive biases）:</p><ul><li>权重共享，图像不同部分以相同方式处理，位置不敏感；</li><li>由于卷积算子的性质，卷积的特征图具有局部敏感性,也就是每次卷积操作只会考虑原始数据的一小部分的局部信息。</li></ul><p>因此，CNN 的归纳偏置缺乏对输入数据本身的整体把握。它很擅长提取局部的有效信息，但是没能提取全局数据之间的长距离特征。</p><p>相比之下，基于自注意力机制的Transformer模型最小化了归纳偏置。当在大数据集上进行训练时，这些模型的性能已经可以媲美甚至超过 CNN 。但在小数据集上训练时，它们往往很难学习有意义的表征。可以说，CNN在小数据集上表现较为突出，因为预先强加了归纳偏置，可以让网络一开始就朝着比较正确的方向学习，但当数据量增大时，可能由于这些归纳偏置，导致其达到一个上限，而Transformer没有，所以对数据非常饥渴，但同时上限也很高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要总结对于机器学习和深度学习领域一些比较片面粗浅的理解，包含的范围比较杂乱，在此做一个记录。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zsh4614.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式：单例模式</title>
    <link href="https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zsh4614.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-16T08:16:09.000Z</published>
    <updated>2021-12-01T17:30:30.017Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍设计模式中的单例模式，并给出C++实现。</p><span id="more"></span><h3 id="介绍">介绍</h3><p>单例模式也称为单件模式、单子模式，可能是使用最广泛的设计模式。其意图是**保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。**有很多地方需要这样的功能模块，如系统的日志输出，操作系统只能有一个任务管理器，一台PC连一个键盘，工程中的通用配置类等。</p><h3 id="实现">实现</h3><h4 id="实现一">实现一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先检查对象是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(); <span class="comment">//私有构造函数，不允许使用者自己生成对象</span></span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance; <span class="comment">//静态成员变量 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户访问唯一实例的方法只有getInstance()成员函数。如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的。getInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的 。这是一种防弹设计——所有getInstance()之后的调用都返回相同实例的指针。</p><p>这种实现方法有以下几个特点：</p><ul><li>它有一个指向唯一实例的静态指针m_instance，并且是私有的；</li><li>它有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；</li><li>它的构造函数是私有的，这样就不能从别处创建该类的实例。</li></ul><p>但是这种实现方法存在两个问题：一是m_instance指向的空间是动态分配的，需要显式进行释放；二是这种方法不是线程安全的。对于第一个问题，可能有人会说，直接在析构函数中进行delete就可以释放了啊，但是这样会存在问题，因为**在类的析构函数中delete类自身实例的指针，delete又会调用析构函数，这样就会出现循环调用的问题，会造成栈内存溢出，因此编译器不允许这么做。**下面我们针对这两个问题一一进行分析</p><h4 id="实现二">实现二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_instance;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span>   //它的唯一工作就是在析构函数中删除<span class="title">CSingleton</span>的实例</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGarbo</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Singleton::m_instance)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::m_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbo Garbo;  <span class="comment">//定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个妥善的方法是让这个类自己知道在合适的时候把自己删除，或者说把删除自己的操作挂在操作系统中的某个合适的点上，使其在恰当的时候被自动执行。我们知道，程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如上面的代码中的CGarbo类（Garbo意为垃圾工人），类CGarbo被定义为Singleton的私有内嵌类，以防该类被在其他地方滥用。<br>程序运行结束时，系统会调用Singleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。<br>使用这种方法释放单例对象有以下特征：</p><ul><li>在单例类内部定义专有的嵌套类；</li><li>在单例类内定义私有的专门用于释放的静态成员；</li><li>利用程序在结束时析构全局变量的特性，选择最终的释放时机；</li><li>使用单例的代码不需要任何操作，不必关心对象的释放。</li></ul><h4 id="实现三">实现三</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现二中添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如上，使用<strong>局部静态变量</strong>，非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。但使用此种方法也会出现问题，当如下方法使用单例时问题来了：</p><p><code>Singleton singleton = Singleton :: getInstance();</code></p><p>这么做就出现了一个类拷贝的问题，这就违背了单例的特性。产生这个问题原因在于：编译器会为类生成一个默认的拷贝构造函数，来支持类的拷贝。最后没有办法，我们要禁止类拷贝和类赋值，禁止程序员用这种方式来使用单例，所以可以让getInstance()返回一个指针，代码变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以显式禁用类的拷贝构造函数和赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现四">实现四</h4><p>我们从头到尾都还没考虑线程安全问题，但是如果使用实现三的方法，就避免了线程安全，这是因为：<strong>在c++ 11新标准中，静态局部变量是线程安全的</strong>。所以最终的单例模式实现版本为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍设计模式中的单例模式，并给出C++实现。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式（C++）" scheme="https://zsh4614.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    
    
    <category term="静态局部变量" scheme="https://zsh4614.cn/tags/%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="单例模式" scheme="https://zsh4614.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习：几何绘制</title>
    <link href="https://zsh4614.cn/OpenCV%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%87%A0%E4%BD%95%E7%BB%98%E5%88%B6/"/>
    <id>https://zsh4614.cn/OpenCV%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%87%A0%E4%BD%95%E7%BB%98%E5%88%B6/</id>
    <published>2021-11-10T07:15:40.000Z</published>
    <updated>2021-12-01T17:30:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍OpenCV中的部分几何绘制函数的用法，包括：圆，椭圆，矩形，直线，填充多边形。</p><span id="more"></span><h3 id="示例">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> w 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span></span>;</span><br><span class="line"><span class="comment">// 入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cv::Mat atom_image = cv::Mat::zeros(h, w, CV_8UC3);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 0);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 90);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, 45);</span></span><br><span class="line"><span class="comment">    MyEllipse(atom_image, -45);</span></span><br><span class="line"><span class="comment">    MyCircle(atom_image, cv::Point(w/2, w/2));</span></span><br><span class="line"><span class="comment">    cv::imshow(&quot;ellipse&quot;, atom_image);</span></span><br><span class="line"><span class="comment">    cv::waitKey();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 注意这里是 h,w 的格式</span></span><br><span class="line">    cv::Mat rook_image = cv::Mat::<span class="built_in">zeros</span>(h, w, CV_8UC3);</span><br><span class="line">    <span class="built_in">MyPolygon</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyRectangle</span>(rook_image);</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">0</span>, <span class="number">15</span>*w/<span class="number">16</span> ), cv::<span class="built_in">Point</span>( w, <span class="number">15</span>*w/<span class="number">16</span> ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">4</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( w/<span class="number">2</span>, w ) );</span><br><span class="line">    <span class="built_in">MyLine</span>( rook_image, cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, <span class="number">7</span>*w/<span class="number">8</span> ), cv::<span class="built_in">Point</span>( <span class="number">3</span>*w/<span class="number">4</span>, w ) );</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;rook&quot;</span>, rook_image);</span><br><span class="line">    <span class="comment">// 窗口显示在屏幕上的位置</span></span><br><span class="line">    cv::<span class="built_in">moveWindow</span>(<span class="string">&quot;rook&quot;</span>, <span class="number">2000</span>, <span class="number">800</span> );</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 椭圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEllipse</span><span class="params">(cv::Mat img, <span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = <span class="number">4</span>;</span><br><span class="line">    cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">                cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">                angle,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">360</span>,</span><br><span class="line">                cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">                thickness,</span><br><span class="line">                lineType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCircle</span><span class="params">(cv::Mat img, cv::Point center)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">circle</span>(img,</span><br><span class="line">               center,</span><br><span class="line">               w/<span class="number">32</span>,</span><br><span class="line">               cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">               <span class="number">2</span>,</span><br><span class="line">               <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyRectangle</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                  cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                  cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                  cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                  <span class="number">-1</span>,</span><br><span class="line">                  <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意多边形填充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPolygon</span><span class="params">(cv::Mat img)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Create some points */</span></span><br><span class="line">  cv::Point rook_points[<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">0</span>]  = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">1</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">7</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">2</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">3</span>]  = cv::<span class="built_in">Point</span>( <span class="number">11</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">4</span>]  = cv::<span class="built_in">Point</span>( <span class="number">19</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">5</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">6</span>]  = cv::<span class="built_in">Point</span>(  <span class="number">3</span>*w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">7</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">8</span>]  = cv::<span class="built_in">Point</span>( <span class="number">26</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">9</span>]  = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">10</span>] = cv::<span class="built_in">Point</span>( <span class="number">22</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">11</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">12</span>] = cv::<span class="built_in">Point</span>( <span class="number">18</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">13</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">4</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">14</span>] = cv::<span class="built_in">Point</span>( <span class="number">14</span>*w/<span class="number">40</span>,    w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">15</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,     w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">16</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,   <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">17</span>] = cv::<span class="built_in">Point</span>( <span class="number">13</span>*w/<span class="number">32</span>,  <span class="number">3</span>*w/<span class="number">8</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">18</span>] = cv::<span class="built_in">Point</span>(  <span class="number">5</span>*w/<span class="number">16</span>, <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  rook_points[<span class="number">0</span>][<span class="number">19</span>] = cv::<span class="built_in">Point</span>(    w/<span class="number">4</span>,  <span class="number">13</span>*w/<span class="number">16</span> );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ppt为二级指针（rook_points[0]是一个指针，所以ppt是一个指针数组，数组名是指向数组的指针）</span></span><br><span class="line">  <span class="keyword">const</span> cv::Point* ppt[<span class="number">1</span>] = &#123;rook_points[<span class="number">0</span>]&#125;;</span><br><span class="line">  <span class="keyword">int</span> npt[] = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">  cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLine</span><span class="params">(cv::Mat img, cv::Point start, cv::Point end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lineType = cv::LINE_8;</span><br><span class="line">    cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><p>1.椭圆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">ellipse</span>(img,</span><br><span class="line">            cv::<span class="built_in">Point</span>(w/<span class="number">2</span>, w/<span class="number">2</span>),</span><br><span class="line">            cv::<span class="built_in">Size</span>(w/<span class="number">4</span>, w/<span class="number">16</span>),</span><br><span class="line">            angle,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">360</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">            thickness,</span><br><span class="line">            lineType);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>cv::Point(w/2, w/2)：椭圆心</p><p>cv::Size(w/4, w/16)：焦距</p><p>angle：旋转角度（不是弧度），注意是图像坐标系，右是正x，下是正y</p><p>angle_begin：圆弧的起始角度（不是弧度）</p><p>angle_end：圆弧的结束角度（不是弧度）</p><p>cv::Scalar( 255, 0, 0 )：颜色，BGR顺序</p><p>thickness：线宽， -1代表填充</p><p>lineType：线型，16是抗锯齿的线型，看起来边缘更平滑。可选-1，4， 8， 16，关于四邻域线型和八邻域线型，参考<a href="https://blog.csdn.net/young__fan/article/details/82696276">这里</a>。</p><p>2.圆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">circle</span>(img,</span><br><span class="line">            center,</span><br><span class="line">            w/<span class="number">32</span>,</span><br><span class="line">            cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>center：cv::Point，圆心</p><p>w/32：int,，半径</p><p>cv::Scalar(0, 0, 255)：颜色，BGR顺序</p><p>thickness：同上</p><p>lineType：同上</p><p>3.矩形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">rectangle</span>(img,</span><br><span class="line">                cv::<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">7</span>*w/<span class="number">8</span>),</span><br><span class="line">                cv::<span class="built_in">Point</span>(w, w),</span><br><span class="line">                cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">                <span class="number">-1</span>,</span><br><span class="line">                <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>pt1：矩形左上角坐标，cv::Point</p><p>pt2：矩形右下角坐标，cv::Point</p><p>cv::Scalar(0, 255, 255)：颜色</p><p>thickness：同上</p><p>lineType：同上</p><p>4.直线（多边形）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">line</span>(img, start, end, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness, lineType);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>start：cv::Point，起始点</p><p>end：cv::Point，终止点</p><p>cv::Scalar(0, 0, 0)：颜色</p><p>thickness：同上</p><p>lineType：同上</p><p>5.填充多边形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::<span class="built_in">fillPoly</span>(img, ppt, npt, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span> ), <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>img：cv::Mat图像</p><p>ppt：Array of polygons where each polygon is represented as an array of points.</p><p>npt：Array of 每个polygon的点数</p><p>ncontours：多边形数量</p><p>cv::Scalar(0, 0, 0)：颜色</p><p>lineType：同上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍OpenCV中的部分几何绘制函数的用法，包括：圆，椭圆，矩形，直线，填充多边形。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenCV" scheme="https://zsh4614.cn/categories/OpenCV/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu私有仓库UI服务部署</title>
    <link href="https://zsh4614.cn/Ubuntu%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93UI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
    <id>https://zsh4614.cn/Ubuntu%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93UI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</id>
    <published>2021-11-04T03:25:15.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍利用第三方镜像部署docker私有仓库可视化界面服务的方法。</p><span id="more"></span><h3 id="方法一">方法一</h3><p>1.从官方仓库拉取第三方镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure><p>2.启动UI服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -itd -p 60022:80 --restart=always --name=docker-registry-ui -e SINGLE_REGISTRY=true -e REGISTRY_TITLE=&quot;xxxxxxxx registry&quot; -e SHOW_CONTENT_DIGEST=true -e DELETE_IMAGES=true -e NGINX_PROXY_PASS_URL=&quot;http://10.10.8.185:5000&quot; joxit/docker-registry-ui:2.0</span><br></pre></td></tr></table></figure><p><strong>注意：这些环境变量一个也不能错</strong></p><p>3.访问http://10.10.8.185:60022可以登录UI界面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍利用第三方镜像部署docker私有仓库可视化界面服务的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="docker" scheme="https://zsh4614.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu ssh</title>
    <link href="https://zsh4614.cn/Ubuntu-ssh/"/>
    <id>https://zsh4614.cn/Ubuntu-ssh/</id>
    <published>2021-11-04T02:56:44.000Z</published>
    <updated>2021-12-01T17:30:30.013Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍Ubuntu的ssh相关服务。</p><span id="more"></span><h3 id="设置ssh免密登录">设置ssh免密登录</h3><p>ssh-copy-id &lt;username&gt;@&lt;target_host_ip&gt;</p><p>解决按照上述操作之后还不能免密登录的方法：将<code>/etc/ssh/sshd_config</code>中的<code>StrictModes yes</code>改成no。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍Ubuntu的ssh相关服务。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="ssh" scheme="https://zsh4614.cn/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 Server安装OpenPAI v1.8.0</title>
    <link href="https://zsh4614.cn/Ubuntu18-04-Server%E5%AE%89%E8%A3%85OpenPAI-v1-8-0/"/>
    <id>https://zsh4614.cn/Ubuntu18-04-Server%E5%AE%89%E8%A3%85OpenPAI-v1-8-0/</id>
    <published>2021-11-04T02:25:57.000Z</published>
    <updated>2021-12-01T17:30:30.013Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何在Ubuntu18.04上安装OpenPAI v1.8.0。</p><span id="more"></span><h3 id="环境要求">环境要求</h3><p>OpenPAI的部署要求您至少有2台独立的机器：一台dev-box机器、一台master机器和一台worker机器。master，worker必须为物理机器，dev-box可以是硬盘空间不少于40GB的虚拟机，毕竟他只有安装和维护系统的时候才用到，用物理机器太浪费了。</p><h4 id="硬件要求">硬件要求</h4><p><strong>master：</strong></p><ul><li>至少40GB内存。</li><li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li><li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li></ul><p><strong>worker：</strong></p><ul><li>至少16GB内存。</li><li>必须有<strong>固定的局域网 IP 地址（LAN IP address）</strong>，且可以和其他所有机器通信。</li><li>可以访问Internet。尤其是可以访问Docker Hub。部署过程会从Docker Hub拉取Docker镜像。</li><li>必须有Nvidia的gpu。</li></ul><h4 id="软件要求">软件要求</h4><p><strong>master：</strong></p><ul><li>Ubuntu 18.04 (16.04、20.04应该可用)</li><li>SSH服务已开启。</li><li>和所有worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</li><li>Docker已被正确安装。</li><li>NTP已被成功开启。 您可以用命令<code>apt install ntp</code>来检查。</li><li>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</li></ul><p><strong>worker：</strong></p><ul><li><p>Ubuntu 16.04 (18.04、20.04应该可用，但没有经过完整测试)</p></li><li><p>SSH服务已开启。</p></li><li><p>所有master和worker机器有同样的SSH用户名和密码，且该SSH用户有sudo权限。</p></li><li><p>Docker已被正确安装。</p></li><li><p>它是OpenPAI的专用服务器。OpenPAI管理它的所有资源（如CPU、内存、GPU等）。如果有其他工作负载，则可能由于资源不足而导致未知问题。</p></li><li><p>nvidia驱动已被正确安装</p></li><li><p>nvidia-container-runtime已被正确安装，并且被设置为Docker的默认runtime。</p></li></ul><h3 id="依赖安装">依赖安装</h3><p>1.master和所有worker安装Ubuntu18.04系统。</p><p>参考这里</p><p>2.master和所有worker进行磁盘挂载。</p><p>参考这里</p><p>3.所有worker安装nvidia显卡驱动，并设置持久模式。</p><p>参考这里</p><p>4.master和所有worker安装docker。</p><p>参考这里</p><p>5.所有worker安装nvidia-container-runtime。</p><p>参考这里</p><p>6.master开启ntp服务。</p><p>7.dev-box设置免密登录master和所有worker。</p><p>参考这里</p><p>8.master部署docker私有仓库和UI服务。</p><p>参考这里</p><p>9.master和所有worker都安装unzip</p><h3 id="K8s安装OpenPAI">K8s安装OpenPAI</h3><p>该步骤的所有操作都在dev-box机器上。</p><h4 id="准备项目">准备项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;pai.git</span><br><span class="line">cd pai</span><br><span class="line">git checkout v1.8.0</span><br></pre></td></tr></table></figure><h4 id="准备离线相关文件">准备离线相关文件</h4><p>由于网络限制，部分镜像和服务需要离线下载安装。</p><p>1.下载离线文件并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:zsh4614/pai-offline.git</span><br><span class="line">cd pai-offline</span><br><span class="line">unzip pai-offline-deploy-distribute.zip</span><br></pre></td></tr></table></figure><p>2.将<code>offline-deploy-files-distribute.yml</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd pai-offline-deploy-distribute</span><br><span class="line">cp offline-deploy-files-distribute.yml &lt;pai-code-dir&gt;/contrib/kubespray</span><br></pre></td></tr></table></figure><p>3.将<code>roles/offline-deploy-files-distribute</code>复制到<code>&lt;pai-code-dir&gt;/contrib/kubespray/roles</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r roles/offline-deploy-files-distribute &lt;pai-code-dir&gt;/contrib/kubespray/roles</span><br></pre></td></tr></table></figure><p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/b0fcc1ad1d78a373a12c109491914b877fc2d56d/roles/download/defaults/main.yml#L2">这一行</a>可知，安装的时候下载的文件会存放在<code>/tmp/releases/</code>文件夹，故可提前下载好相关文件以避免网络问题。</p><p>由<a href="https://github.com/kubernetes-sigs/kubespray/blob/daed3e5b6a085ac99e076b51d314fcf76e4127b4/roles/kubernetes/node/tasks/install.yml#L11">这一行</a>可知，如果使用了<code>skip_downloads: true</code>参数，kubeadm默认不会在master节点安装，所以手动安装kubeadm。</p><h4 id="修改安装脚本">修改安装脚本</h4><p>1.在<code>/contrib/kubespray/quick-start-kubespray.sh</code>中添加如下一行，在安装过程中安装上述离线文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">echo &quot;Performing docker-cache config distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml docker-cache-config-distribute.yml -e &quot;@$&#123;CLUSTER_CONFIG&#125;&quot; || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Performing offline deploy file distribution...&quot;</span><br><span class="line">ansible-playbook -i $&#123;HOME&#125;/pai-deploy/cluster-cfg/hosts.yml offline-deploy-files-distribute.yml || exit $?</span><br><span class="line"></span><br><span class="line">echo &quot;Starting kubernetes...&quot;</span><br><span class="line">/bin/bash script/kubernetes-boot.sh || exit $?</span><br></pre></td></tr></table></figure><p>2.将<code>/contrib/kubespray/docker-cache-config-distribute.yml</code>中的<code>docker_cache_host</code>的端口改成master节点的docker私有仓库端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker_cache_host: &quot;&#123;&#123; hostvars[groups[&#x27;kube-master&#x27;][0]][&#x27;ip&#x27;] &#125;&#125;:5000&quot;</span><br></pre></td></tr></table></figure><h4 id="编写参数文件">编写参数文件</h4><p>1.修改<code>/contrib/kubespray/config/config.yaml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user: &lt;your-ssh-username&gt;</span><br><span class="line">password: &lt;your-ssh-password&gt;</span><br><span class="line">docker_image_tag: v1.8.0</span><br><span class="line"></span><br><span class="line">enable_docker_cache: false</span><br><span class="line">docker_cache_storage_backend: &quot;filesystem&quot;</span><br><span class="line">docker_cache_fs_mount_path: &quot;/sda/pai/registry&quot;</span><br><span class="line">enable_marketplace: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">docker_data_root: /sda/pai/data</span><br><span class="line"></span><br><span class="line">openpai_kubespray_extra_var:</span><br><span class="line">  download_container: false</span><br><span class="line">  skip_downloads: true</span><br></pre></td></tr></table></figure><p>2.修改<code>/contrib/kubespray/config/layout.yaml</code>文件</p><p>仿照官方用例即可</p><h4 id="安装K8s">安装K8s</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd contrib/kubespray</span><br><span class="line">bash quick-start-kubespray.sh</span><br></pre></td></tr></table></figure><h4 id="安装OpenPAI">安装OpenPAI</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash quick-start-service.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何在Ubuntu18.04上安装OpenPAI v1.8.0。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="OpenPAI" scheme="https://zsh4614.cn/tags/OpenPAI/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装docker</title>
    <link href="https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85docker/"/>
    <id>https://zsh4614.cn/Ubuntu%E5%AE%89%E8%A3%85docker/</id>
    <published>2021-11-03T09:46:14.000Z</published>
    <updated>2021-12-01T17:30:30.014Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍在ubuntu上安装docker的方法。</p><span id="more"></span><h3 id="docker安装">docker安装</h3><p>1.（可选）更换国内镜像源，推荐清华源或中科大源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i &#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>2.安装需要的依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br></pre></td></tr></table></figure><p>3.添加GPG密钥，需指定源（采用中科大源，采用默认的源下载速度慢，经常失败）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p>4.更新软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>5.安装docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>6.测试docker安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="nvidia-container-runtime安装">nvidia-container-runtime安装</h3><p>docker19.03之后建议使用nvidia-container-runtime取代nvidia-docker2。</p><p>1.添加GPG密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-container-runtime&#x2F;gpgkey | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>2.添加源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br></pre></td></tr></table></figure><p>3.更新软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>4.安装nvidia-container-runtime</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-container-runtime</span><br></pre></td></tr></table></figure><p>5.设置默认运行时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在/etc/docker/daemon.json中写入以下内容:</span><br><span class="line">&#123;</span><br><span class="line">&quot;default-runtime&quot;: &quot;nvidia&quot;,</span><br><span class="line">    &quot;runtimes&quot;: &#123;</span><br><span class="line">        &quot;nvidia&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.重启docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>7.验证安装成功（出现显卡信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm nvidia/cuda:10.0-base nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍在ubuntu上安装docker的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Deploy" scheme="https://zsh4614.cn/categories/Deploy/"/>
    
    
    <category term="基础环境" scheme="https://zsh4614.cn/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/"/>
    
    <category term="docker" scheme="https://zsh4614.cn/tags/docker/"/>
    
  </entry>
  
</feed>
