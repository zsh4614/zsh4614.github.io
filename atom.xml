<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到我的主页!</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-20T17:10:04.877Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zsh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三题：无重复字符的最长子串</title>
    <link href="http://example.com/2021/05/20/LeetCode%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2021/05/20/LeetCode%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2021-05-19T17:35:56.000Z</published>
    <updated>2021-05-20T17:10:04.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目">题目</h3><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><h3 id="示例">示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是子串的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;= s.length &lt;= 5 * 104</li><li>s由英文字母、数字、符号和空格组成</li></ul><h3 id="分析">分析</h3><p>1.设置两个游标，采用滑动窗口，右游标一直右滑，每滑动一位，从左游标开始遍历查找与右游标相等的值，如果找到，左游标移到相等位置的下一位，更新长度</p><h3 id="实现">实现</h3><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        length = result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(start,end):</span><br><span class="line">                <span class="keyword">if</span> s[index] == s[end]:</span><br><span class="line">                    length = end - index- <span class="number">1</span></span><br><span class="line">                    start = index + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            result = <span class="built_in">max</span>(length, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="c">c++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start; j &lt; end; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] == s[end]) &#123;</span><br><span class="line">                start = j + <span class="number">1</span>;</span><br><span class="line">                length = end - start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = <span class="built_in">max</span>(result, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<strong>哈希</strong>对查找相等元素进行优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">find</span>(s[end]) != hashmap.<span class="built_in">end</span>() &amp;&amp; hashmap[s[end]] &gt;= start) &#123;</span><br><span class="line">            start = hashmap[s[end]] + <span class="number">1</span>;</span><br><span class="line">            length = end - start;</span><br><span class="line">        &#125;</span><br><span class="line">        hashmap[s[end]] = end;</span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = <span class="built_in">max</span>(result, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><ul><li><p>map操作，find与count的区别</p></li><li><p>map与unordered_map的区别，到底哪个快？</p></li><li><p>利用数组进行桶优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int start(0), end(0), length(0), result(0);</span><br><span class="line">    <span class="keyword">int</span> sSize = <span class="built_in"><span class="keyword">int</span></span>(s.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; sSize) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpChar = s[end];</span><br><span class="line">        <span class="keyword">if</span> (vec[<span class="built_in"><span class="keyword">int</span></span>(tmpChar)] &gt;= start)</span><br><span class="line">        &#123;</span><br><span class="line">            start = vec[<span class="built_in"><span class="keyword">int</span></span>(tmpChar)] + <span class="number">1</span>;</span><br><span class="line">            length = end - start;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[<span class="built_in"><span class="keyword">int</span></span>(tmpChar)] = end;</span><br><span class="line">        </span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result = <span class="built_in">max</span>(result, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="哈希" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="桶优化" scheme="http://example.com/tags/%E6%A1%B6%E4%BC%98%E5%8C%96/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及实现：数组和链表</title>
    <link href="http://example.com/2021/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2021-05-18T15:45:04.000Z</published>
    <updated>2021-05-18T16:09:39.219Z</updated>
    
    <content type="html"><![CDATA[<p>引言：线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表；随后给出双向链表C++的实现。</p><span id="more"></span><h3 id="数组">数组</h3><p>数组有上界和下界，数组的元素在上下界内是连续的。</p><p>存储10,20,30,40,50的数组的示意图如下：</p><p><img src="https://i.loli.net/2021/05/18/Klmj2bxLcHB3FNA.jpg" alt="231243264043298.jpg"></p><p>数组的特点是：<strong>数据是连续的；随机访问速度快。</strong></p><p>数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了<strong>Vector</strong>；</p><h3 id="单向链表">单向链表</h3><p>单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。</p><p>单链表的示意图如下：</p><p><img src="https://i.loli.net/2021/05/18/bPtqAMNe76wlFjO.jpg" alt="单链表.jpg"></p><p>表头为空，表头的后继节点是&quot;节点10&quot;(数据为10的节点)，“节点10&quot;的后继节点是&quot;节点20”(数据为10的节点)，…</p><h4 id="单链表删除节点">单链表删除节点</h4><p><img src="https://i.loli.net/2021/05/18/IbHdyTAaxPgZqoF.jpg" alt="删除节点.jpg"></p><p>删除&quot;节点30&quot;<br>删除之前：“节点20” 的后继节点为&quot;节点30&quot;，而&quot;节点30&quot; 的后继节点为&quot;节点40&quot;。<br>删除之后：“节点20” 的后继节点为&quot;节点40&quot;。</p><h4 id="单链表添加节点">单链表添加节点</h4><p><img src="https://i.loli.net/2021/05/18/yJx3m5GUtiqV9XK.jpg" alt="添加节点.jpg"></p><p>在&quot;节点10&quot;与&quot;节点20&quot;之间添加&quot;节点15&quot;<br>添加之前：“节点10” 的后继节点为&quot;节点20&quot;。<br>添加之后：“节点10” 的后继节点为&quot;节点15&quot;，而&quot;节点15&quot; 的后继节点为&quot;节点20&quot;。</p><p>单链表的特点是：节点的链接方向是单向的；<strong>相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</strong></p><h3 id="双向链表">双向链表</h3><p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p><p>双链表的示意图如下：</p><p><img src="https://i.loli.net/2021/05/18/CeNdqmtyGZjSiUr.jpg" alt="双链表.jpg"></p><p>表头为空，表头的后继节点为&quot;节点10&quot;(数据为10的节点)；“节点10&quot;的后继节点是&quot;节点20”(数据为10的节点)，“节点20&quot;的前继节点是&quot;节点10”；“节点20&quot;的后继节点是&quot;节点30”，“节点30&quot;的前继节点是&quot;节点20”；…；末尾节点的后继节点是表头。</p><h4 id="双链表删除节点">双链表删除节点</h4><p><img src="https://i.loli.net/2021/05/19/paljhibM65RerWo.jpg" alt="双链表删除.jpg"></p><p>删除&quot;节点30&quot;<br>删除之前：“节点20&quot;的后继节点为&quot;节点30”，“节点30” 的前继节点为&quot;节点20&quot;。“节点30&quot;的后继节点为&quot;节点40”，“节点40” 的前继节点为&quot;节点30&quot;。<br>删除之后：“节点20&quot;的后继节点为&quot;节点40”，“节点40” 的前继节点为&quot;节点20&quot;。</p><h4 id="双链表添加节点">双链表添加节点</h4><p><img src="https://i.loli.net/2021/05/19/fvbJOLEWg9UBshM.jpg" alt="双链表添加节点.jpg"></p><p>在&quot;节点10&quot;与&quot;节点20&quot;之间添加&quot;节点15&quot;<br>添加之前：“节点10&quot;的后继节点为&quot;节点20”，“节点20” 的前继节点为&quot;节点10&quot;。<br>添加之后：“节点10&quot;的后继节点为&quot;节点15”，“节点15” 的前继节点为&quot;节点10&quot;。“节点15&quot;的后继节点为&quot;节点20”，“节点20” 的前继节点为&quot;节点15&quot;。</p><h3 id="C-实现双链表">C++实现双链表</h3><p>双向链表文件(DoubleLink.h)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOUBLE_LINK_HXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLE_LINK_HXX</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value;</span><br><span class="line">        DNode *prev;</span><br><span class="line">        DNode *next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DNode</span>() &#123; &#125;</span><br><span class="line">        <span class="built_in">DNode</span>(T t, DNode *prev, DNode *next) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = t;</span><br><span class="line">            <span class="keyword">this</span>-&gt;prev  = prev;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next  = next;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLink</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DoubleLink</span>();</span><br><span class="line">        ~<span class="built_in">DoubleLink</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">get_first</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">get_last</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, T t)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">insert_first</span><span class="params">(T t)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">append_last</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">delete_first</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">delete_last</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        DNode&lt;T&gt; *phead;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function">DNode&lt;T&gt; *<span class="title">get_node</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">DoubleLink&lt;T&gt;::<span class="built_in">DoubleLink</span>() : <span class="built_in">count</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建“表头”。注意：表头没有存储数据！</span></span><br><span class="line">    phead = <span class="keyword">new</span> DNode&lt;T&gt;();</span><br><span class="line">    phead-&gt;prev = phead-&gt;next = phead;</span><br><span class="line">    <span class="comment">// 设置链表计数为0</span></span><br><span class="line">    <span class="comment">//count = 0;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">DoubleLink&lt;T&gt;::~<span class="built_in">DoubleLink</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除所有的节点</span></span><br><span class="line">    DNode&lt;T&gt;* ptmp;</span><br><span class="line">    DNode&lt;T&gt;* pnode = phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (pnode != phead)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode=pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除&quot;表头&quot;</span></span><br><span class="line">    <span class="keyword">delete</span> phead;</span><br><span class="line">    phead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回节点数目</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">is_empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第index位置的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">DNode&lt;T&gt;* DoubleLink&lt;T&gt;::<span class="built_in">get_node</span>(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断参数有效性</span></span><br><span class="line">    <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index&gt;=count)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;get node failed! the index in out of bound!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正向查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= count/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        DNode&lt;T&gt;* pindex = phead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; index) &#123;</span><br><span class="line">            pindex = pindex-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pindex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向查找</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rindex = count - index <span class="number">-1</span>;</span><br><span class="line">    DNode&lt;T&gt;* prindex = phead-&gt;prev;</span><br><span class="line">    <span class="keyword">while</span> (j++ &lt; rindex) &#123;</span><br><span class="line">        prindex = prindex-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prindex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第index位置的节点的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T DoubleLink&lt;T&gt;::<span class="built_in">get</span>(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_node</span>(index)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第1个节点的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T DoubleLink&lt;T&gt;::<span class="built_in">get_first</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_node</span>(<span class="number">0</span>)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一个节点的值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T DoubleLink&lt;T&gt;::<span class="built_in">get_last</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_node</span>(count<span class="number">-1</span>)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点插入到第index位置之前</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">insert</span>(<span class="keyword">int</span> index, T t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_first</span>(t);</span><br><span class="line"></span><br><span class="line">    DNode&lt;T&gt;* pindex = <span class="built_in">get_node</span>(index);</span><br><span class="line">    DNode&lt;T&gt;* pnode  = <span class="keyword">new</span> DNode&lt;T&gt;(t, pindex-&gt;prev, pindex);</span><br><span class="line">    pindex-&gt;prev-&gt;next = pnode;</span><br><span class="line">    pindex-&gt;prev = pnode;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点插入第一个节点处。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">insert_first</span>(T t)</span><br><span class="line">&#123;</span><br><span class="line">    DNode&lt;T&gt;* pnode  = <span class="keyword">new</span> DNode&lt;T&gt;(t, phead, phead-&gt;next);</span><br><span class="line">    phead-&gt;next-&gt;prev = pnode;</span><br><span class="line">    phead-&gt;next = pnode;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点追加到链表的末尾</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">append_last</span>(T t)</span><br><span class="line">&#123;</span><br><span class="line">    DNode&lt;T&gt;* pnode = <span class="keyword">new</span> DNode&lt;T&gt;(t, phead-&gt;prev, phead);</span><br><span class="line">    phead-&gt;prev-&gt;next = pnode;</span><br><span class="line">    phead-&gt;prev = pnode;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除index位置的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">del</span>(<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    DNode&lt;T&gt;* pindex = <span class="built_in">get_node</span>(index);</span><br><span class="line">    pindex-&gt;next-&gt;prev = pindex-&gt;prev;</span><br><span class="line">    pindex-&gt;prev-&gt;next = pindex-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> pindex;</span><br><span class="line">    count--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">delete_first</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">del</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> DoubleLink&lt;T&gt;::<span class="built_in">delete_last</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">del</span>(count<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>双向链表测试文件(DlinkTest.cpp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DoubleLink.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表操作int数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iarr[<span class="number">4</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n----int_test----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建双向链表</span></span><br><span class="line">    DoubleLink&lt;<span class="keyword">int</span>&gt;* pdlink = <span class="keyword">new</span> DoubleLink&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">20</span>);        <span class="comment">// 将 20 插入到第一个位置</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">append_last</span>(<span class="number">10</span>);    <span class="comment">// 将 10 追加到链表末尾</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert_first</span>(<span class="number">30</span>);    <span class="comment">// 将 30 插入到第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_empty()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">is_empty</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 双向链表的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印双向链表中的全部数据</span></span><br><span class="line">    <span class="keyword">int</span> sz = pdlink-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pdlink(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">get</span>(i) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string sarr[<span class="number">4</span>] = &#123;<span class="string">&quot;ten&quot;</span>, <span class="string">&quot;twenty&quot;</span>, <span class="string">&quot;thirty&quot;</span>, <span class="string">&quot;forty&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n----string_test----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建双向链表</span></span><br><span class="line">    DoubleLink&lt;string&gt;* pdlink = <span class="keyword">new</span> DoubleLink&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, sarr[<span class="number">1</span>]);        <span class="comment">// 将 sarr中第2个元素 插入到第一个位置</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">append_last</span>(sarr[<span class="number">0</span>]);    <span class="comment">// 将 sarr中第1个元素  追加到链表末尾</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert_first</span>(sarr[<span class="number">2</span>]);    <span class="comment">// 将 sarr中第3个元素  插入到第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_empty()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">is_empty</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 双向链表的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印双向链表中的全部数据</span></span><br><span class="line">    <span class="keyword">int</span> sz = pdlink-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pdlink(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">get</span>(i) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> stu arr_stu[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="string">&quot;sky&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">20</span>, <span class="string">&quot;jody&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">30</span>, <span class="string">&quot;vic&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">40</span>, <span class="string">&quot;dan&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_STU_SIZE ( (sizeof(arr_stu)) / (sizeof(arr_stu[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n----object_test----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建双向链表</span></span><br><span class="line">    DoubleLink&lt;stu&gt;* pdlink = <span class="keyword">new</span> DoubleLink&lt;stu&gt;();</span><br><span class="line"></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, arr_stu[<span class="number">1</span>]);        <span class="comment">// 将 arr_stu中第2个元素 插入到第一个位置</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">append_last</span>(arr_stu[<span class="number">0</span>]);    <span class="comment">// 将 arr_stu中第1个元素  追加到链表末尾</span></span><br><span class="line">    pdlink-&gt;<span class="built_in">insert_first</span>(arr_stu[<span class="number">2</span>]);    <span class="comment">// 将 arr_stu中第3个元素  插入到第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;is_empty()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">is_empty</span>() &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 双向链表的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()=&quot;</span> &lt;&lt; pdlink-&gt;<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印双向链表中的全部数据</span></span><br><span class="line">    <span class="keyword">int</span> sz = pdlink-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = pdlink-&gt;<span class="built_in">get</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pdlink(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)=[&quot;</span> &lt;&lt; p.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.name &lt;&lt;<span class="string">&quot;]&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int_test</span>();        <span class="comment">// 演示向双向链表操作“int数据”。</span></span><br><span class="line">    <span class="built_in">string_test</span>();    <span class="comment">// 演示向双向链表操作“字符串数据”。</span></span><br><span class="line">    <span class="built_in">object_test</span>();    <span class="comment">// 演示向双向链表操作“对象”。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例说明</strong></p><p>在上面的示例中，我将双向链表的&quot;声明&quot;和&quot;实现&quot;都放在头文件中。而编程规范告诫我们：将类的声明和实现分离，在头文件(.h文件或.hpp)中尽量只包含声明，而在实现文件(.cpp文件)中负责实现！<br>那么为什么要这么做呢？这是因为，在双向链表的实现中，采用了模板；而C++编译器不支持对模板的分离式编译！简单点说，如果在DoubleLink.h中声明，而在DoubleLink.cpp中进行实现的话；当我们在其他类中创建DoubleLink的对象时，会编译出错。</p><p><strong>运行结果</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">----int_test----</span><br><span class="line">is_empty()=0</span><br><span class="line">size()=3</span><br><span class="line">pdlink(0)=30</span><br><span class="line">pdlink(1)=20</span><br><span class="line">pdlink(2)=10</span><br><span class="line"></span><br><span class="line">----string_test----</span><br><span class="line">is_empty()=0</span><br><span class="line">size()=3</span><br><span class="line">pdlink(0)=thirty</span><br><span class="line">pdlink(1)=twenty</span><br><span class="line">pdlink(2)=ten</span><br><span class="line"></span><br><span class="line">----object_test----</span><br><span class="line">is_empty()=0</span><br><span class="line">size()=3</span><br><span class="line">pdlink(0)=[30, vic]</span><br><span class="line">pdlink(1)=[20, jody]</span><br><span class="line">pdlink(2)=[10, sky]</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>对链表的理论知识进行简单介绍，给出C++实现，并对实现代码进行了测试。</p><blockquote><p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3561803.html">https://www.cnblogs.com/skywang12345/p/3561803.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表；随后给出双向链表C++的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第二题：两数相加</title>
    <link href="http://example.com/2021/05/18/LeetCode%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://example.com/2021/05/18/LeetCode%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2021-05-18T15:19:13.000Z</published>
    <updated>2021-05-18T16:13:05.028Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第二题，Python和C++实现；并对链表做了简单说明。</p><span id="more"></span><h3 id="题目">题目</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h3 id="示例">示例</h3><p><strong>示例1：</strong></p><p><img src="https://i.loli.net/2021/05/18/7lnuBY3hgVbz5PN.jpg" alt="addtwonumber1.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="分析">分析</h3><p>1.注意链表是一种数据结构，不同于python中的list</p><p>2.注意最后的进位不要忘记</p><p>3.本题的精髓在于这个while循环，可以不用补齐使得两个链表长度相等</p><h3 id="实现">实现</h3><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    head = result = ListNode()</span><br><span class="line">    carry = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">        val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            val += l1.val</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            val += l2.val</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            val+=<span class="number">1</span><span class="comment">#注意在python中没有自增和自减运算符！</span></span><br><span class="line">        carry = (val &gt;= <span class="number">10</span>)</span><br><span class="line">        val = val % <span class="number">10</span>;</span><br><span class="line">        result.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        result = result.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> carry:</span><br><span class="line">        result.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="c">c++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *result = head;</span><br><span class="line">    <span class="keyword">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> || carry) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sum += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sum += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = sum % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// result-&gt;next-&gt;val = res;    // 错误，事先不存在，注意开辟空间，而不是赋值</span></span><br><span class="line">        result-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(res);</span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">        carry = (sum &gt;= <span class="number">10</span>) ? <span class="literal">true</span> : <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><p>数据结构：<a href="http://zsh4614.cn/2021/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/">链表</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第二题，Python和C++实现；并对链表做了简单说明。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一题：两数之和</title>
    <link href="http://example.com/2021/05/17/leetcode%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://example.com/2021/05/17/leetcode%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-05-17T15:54:17.000Z</published>
    <updated>2021-05-17T16:38:31.707Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要分析LeetCode第一题，Python和C++实现；并对哈希做了简单说明。</p><span id="more"></span><h3 id="题目">题目</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><h3 id="示例">示例</h3><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><h3 id="分析">分析</h3><p>1.注意题目输出下标，同时注意条件约束：返回结果不能是同一个元素的下标，但是可以使两个相等的元素的下标。</p><p>2.最直观的想法是两层循环嵌套，时间复杂度O(n<sup>2</sup>)</p><p>3.耗时主要在查找上，由于哈希查找的时间复杂度为O(1)，所以采用哈希</p><h3 id="实现">实现</h3><h4 id="Python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> target - num <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">return</span> [i, hashmap.get(target - num)]</span><br><span class="line">        hashmap[num] = i</span><br><span class="line">        <span class="comment"># 注意，hashmap[num] = i一定要写在if之后，否则不能返回两个元素相等的情况</span></span><br></pre></td></tr></table></figure><ul><li>小技巧：访问字典最好使用dict.get(key)而不是使用dict[key]，因为当key不存在时前者会返回None，而后者会抛出异常。</li></ul><h4 id="C">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;<span class="comment">// 初始化存放结果的容器为&#123;-1， -1&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">count</span>(target - nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result[<span class="number">0</span>] = i;</span><br><span class="line">            result[<span class="number">1</span>] = hashmap[target - nums[i]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashmap[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><h4 id="什么是哈希表？">什么是哈希表？</h4><p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>记录的存储位置=f(关键字)</p><p>这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。</p><p>哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）<br>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p><h4 id="Hash的应用">Hash的应用</h4><p>1、Hash主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值. 也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。</p><p>2、查找：哈希表，又称为散列，是一种更加快捷的查找技术。我们之前的查找，都是这样一种思路：集合中拿出来一个元素，看看是否与我们要找的相等，如果不等，缩小范围，继续查找。而哈希表是完全另外一种思路：当我知道key值以后，我就可以直接计算出这个元素在集合中的位置，根本不需要一次又一次的查找！</p><p>举一个例子，假如我的数组A中，第i个元素里面装的key就是i，那么数字3肯定是在第3个位置，数字10肯定是在第10个位置。哈希表就是利用利用这种基本的思想，建立一个从key到位置的函数，然后进行直接计算查找。</p><p>3、Hash表在海量数据处理中有着广泛应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要分析LeetCode第一题，Python和C++实现；并对哈希做了简单说明。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="哈希" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch源码解读之DP&amp;DDP：数据并行和分布式训练详解</title>
    <link href="http://example.com/2021/05/15/PyTorch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BDP-DDP%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/05/15/PyTorch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BDP-DDP%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-05-15T14:18:57.000Z</published>
    <updated>2021-05-16T16:39:27.988Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文介绍 PyTorch 里的数据并行训练，涉及 nn.DataParallel (DP) 和 nn.parallel.DistributedDataParallel (DDP) 两个模块（基于 1.7 版本），涵盖分布式训练的原理以及源码解读。</p><span id="more"></span><h3 id="数据并行">数据并行</h3><p>当一张 GPU 可以存储一个模型时，可以采用数据并行得到更准确的梯度或者加速训练，即每个 GPU 复制一份模型，将一批样本分为多份输入各个模型并行计算。因为<strong>求导以及加和都是线性的</strong>，数据并行在数学上也有效。</p><p>假设我们一个 batch 有 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 个样本，一共有 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 个 GPU 每个 GPU 分到 <img src="https://www.zhihu.com/equation?tex=m_j" alt="[公式]"> 个样本。假设样本刚好等分，则有 <img src="https://www.zhihu.com/equation?tex=m_j+%3D+%5Cfrac%7Bn%7D%7Bk%7D" alt="[公式]"> 。我们考虑总的损失函数 <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 对参数 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 的导数：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%5C+Loss%7D%7B%5Cpartial+w%7D+%3D+%5Cfrac%7B%5Cpartial%5B%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dl%28x_i%2Cy_i%29%5D%7D%7B%5Cpartial+w%7D+%3D+%5Cfrac%7B1%7D%7Bn%7D+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D+%5Cfrac%7B%5Cpartial+l%28x_i%2Cy_i%29%7D%7B%5Cpartial+w%7D+%3D+%5Csum_%7Bj%3D1%7D%5E%7Bk%7D+%5Cfrac%7Bm_j%7D%7Bn%7D+%5Cfrac%7B%5Cpartial%5B%5Cfrac%7B1%7D%7Bm_j%7D%5Csum_%7Bi%3D+m_%7Bj-1%7D%7D%5E%7Bm_%7Bj-1%7D%2Bm_%7Bj%7D%7Dl%28x_i%2Cy_i%29%5D%7D%7B%5Cpartial+w%7D+%3D+%5Csum_%7Bj%3D1%7D%5E%7Bk%7D+%5Cfrac%7Bm_j%7D%7Bn%7D%5Cfrac%7B%5Cpartial%5C+loss_%7Bj%7D%7D%7B%5Cpartial+w%7D+%3D+%5Cfrac%7B1%7D%7Bk%7D+%5Csum_%7Bj%3D1%7D%5E%7Bk%7D+%5Cfrac%7B%5Cpartial%5C+loss_%7Bj%7D%7D%7B%5Cpartial+w%7D" alt="[公式]"></p><p>那么接下来我们看一下 PyTorch 究竟是怎么实现数据并行的。</p><h3 id="DP">DP</h3><h4 id="使用">使用</h4><p>DP 的好处是，使用起来非常方便，只需要将原来单卡的 model 用 DP 改成多卡:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = nn.DataParallel(model)</span><br></pre></td></tr></table></figure><h4 id="原理">原理</h4><p>DP 基于单机多卡，所有设备都负责计算和训练网络，除此之外， device[0] (并非 GPU 真实标号而是输入参数 device_ids 首位) 还要负责整合梯度，更新参数。图 1 即为 GPU 0 作为 device[0] 的例子。从图中我们可以看出，有三个主要过程：</p><ul><li>过程一（图中红色部分）：各卡分别计算损失和梯度</li><li>过程二（图中蓝色部分）：所有梯度整合到 device[0]</li><li>过程三（图中绿色部分）：device[0] 进行参数更新，其他卡复制 device[0] 的参数</li></ul><p><img src="https://i.loli.net/2021/05/15/E4lF2jLGf1N8SPV.jpg" alt="ps.jpg"></p><p>DP 只能实现单机训练，使用的是多线程而非多个进程，不能算是严格意义上的分布式训练（多个节点），但是其原理和分布式训练算法里的 Parameter Server 架构很相近，我们借用 PS 的伪代码来说明一下。</p><p><img src="https://i.loli.net/2021/05/15/9GVSsC2prZ3PiOq.jpg" alt="4089rq9421004o77o6nr15nq9s5sq2p0.jpg"></p><p>我们可以看到 PS 的并行梯度下降流程分为：</p><ul><li><p>Task Scheduler：负责加载数据并分发数据至每个 worker 节点，并执行多轮迭代</p></li><li><p>Worker：①初始化：载入数据并将全部模型参数从 server 节点拉下来；②梯度计算：利用该节点的数据计算梯度并将梯度更新到 server 节点</p></li><li><p>Server：①汇总梯度；②更新参数</p></li></ul><p>OK， 现在我们已经知道了 DP 使用的算法，接下来我们看一下 PyTorch 是如何实现的。</p><h4 id="实现">实现</h4><p>这一节主要讨论 DP 的实现，首先先贴上源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataParallel</span>(<span class="params">Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, module, device_ids=<span class="literal">None</span>, output_device=<span class="literal">None</span>, dim=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DataParallel, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否有可用的 GPU</span></span><br><span class="line">        device_type = _get_available_device_type()</span><br><span class="line">        <span class="keyword">if</span> device_type <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.module = module</span><br><span class="line">            self.device_ids = []</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 默认使用所有可见的 GPU</span></span><br><span class="line">        <span class="keyword">if</span> device_ids <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device_ids = _get_all_device_indices()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 默认 server 是 device_ids 列表上第一个</span></span><br><span class="line">        <span class="keyword">if</span> output_device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            output_device = device_ids[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.module = module</span><br><span class="line">        self.device_ids = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: _get_device_index(x, <span class="literal">True</span>), device_ids))</span><br><span class="line">        self.output_device = _get_device_index(output_device, <span class="literal">True</span>)</span><br><span class="line">        self.src_device_obj = torch.device(device_type, self.device_ids[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查负载是否平衡， 不平衡（指内存或者处理器 max/min &gt; 0.75 会有警告）</span></span><br><span class="line">        _check_balance(self.device_ids)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单卡</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.device_ids) == <span class="number">1</span>:</span><br><span class="line">            self.module.to(self.src_device_obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, *inputs, **kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 没 GPU 可用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.device_ids:</span><br><span class="line">            <span class="keyword">return</span> self.module(*inputs, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 运行前 GPU device_ids[0] （即我们的 server）上必须有 parallelized module 的parameters 和 buffers</span></span><br><span class="line">        <span class="comment"># 因为 DP 保证 GPU device_ids[0] 和 base parallelized module 共享存储</span></span><br><span class="line">        <span class="comment"># 所以在device[0] 上的 in-place 更新也会被保留下来，其他的则不会</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> chain(self.module.parameters(), self.module.buffers()):</span><br><span class="line">            <span class="keyword">if</span> t.device != self.src_device_obj:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;module must have its parameters and buffers &quot;</span></span><br><span class="line">                                   <span class="string">&quot;on device &#123;&#125; (device_ids[0]) but found one of &quot;</span></span><br><span class="line">                                   <span class="string">&quot;them on device: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.src_device_obj, t.device))</span><br><span class="line"></span><br><span class="line">         <span class="comment"># nice 现在 device[0] 上已经有了 module 和 input， 接下来我们就要开始 PS 算法了</span></span><br><span class="line">        <span class="comment"># 可以开始看正文了</span></span><br><span class="line"></span><br><span class="line">        inputs, kwargs = self.scatter(inputs, kwargs, self.device_ids)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果仅有单卡可用，直接单卡计算，不用并行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.device_ids) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.module(*inputs[<span class="number">0</span>], **kwargs[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        replicas = self.replicate(self.module, self.device_ids[:<span class="built_in">len</span>(inputs)])</span><br><span class="line">        outputs = self.parallel_apply(replicas, inputs, kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.gather(outputs, self.output_device)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replicate</span>(<span class="params">self, module, device_ids</span>):</span></span><br><span class="line">        <span class="keyword">return</span> replicate(module, device_ids, <span class="keyword">not</span> torch.is_grad_enabled())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scatter</span>(<span class="params">self, inputs, kwargs, device_ids</span>):</span></span><br><span class="line">        <span class="keyword">return</span> scatter_kwargs(inputs, kwargs, device_ids, dim=self.dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parallel_apply</span>(<span class="params">self, replicas, inputs, kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> parallel_apply(replicas, inputs, kwargs, self.device_ids[:<span class="built_in">len</span>(replicas)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">self, outputs, output_device</span>):</span></span><br><span class="line">        <span class="keyword">return</span> gather(outputs, output_device, dim=self.dim)</span><br></pre></td></tr></table></figure><p>从 forward 函数可以看出，关键函数有 scatter, replicate, parallel_apply 和 gather，我们一个一个看一下。</p><p>首先是 scatter 函数，即 scatter_kwargs 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatter_kwargs</span>(<span class="params">inputs, kwargs, target_gpus, dim=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;Scatter with support for kwargs dictionary&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主要函数</span></span><br><span class="line">    inputs = scatter(inputs, target_gpus, dim) <span class="keyword">if</span> inputs <span class="keyword">else</span> []</span><br><span class="line">    kwargs = scatter(kwargs, target_gpus, dim) <span class="keyword">if</span> kwargs <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用空项补全使 inputs 和 kwargs 长度相当</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inputs) &lt; <span class="built_in">len</span>(kwargs):</span><br><span class="line">        inputs.extend([() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(kwargs) - <span class="built_in">len</span>(inputs))])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(kwargs) &lt; <span class="built_in">len</span>(inputs):</span><br><span class="line">        kwargs.extend([&#123;&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inputs) - <span class="built_in">len</span>(kwargs))])</span><br><span class="line">    <span class="comment"># 返回 tuple</span></span><br><span class="line">    inputs = <span class="built_in">tuple</span>(inputs)</span><br><span class="line">    kwargs = <span class="built_in">tuple</span>(kwargs)</span><br><span class="line">    <span class="keyword">return</span> inputs, kwargs</span><br></pre></td></tr></table></figure><p>scatter_kwargs 函数中最重要的就是 scatter 函数，负责将 tensor 分成大概相等的块并将他们分给不同的 GPU。对其他的数据类型，则是复制分散给不同的 GPU 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scatter</span>(<span class="params">inputs, target_gpus, dim=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Slices tensors into approximately equal chunks and</span></span><br><span class="line"><span class="string">    distributes them across given GPUs. Duplicates</span></span><br><span class="line"><span class="string">    references to objects that are not tensors.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scatter_map</span>(<span class="params">obj</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, torch.Tensor):</span><br><span class="line">            <span class="keyword">return</span> Scatter.apply(target_gpus, <span class="literal">None</span>, dim, obj)</span><br><span class="line">        <span class="keyword">if</span> is_namedtuple(obj):</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">type</span>(obj)(*args) <span class="keyword">for</span> args <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj))]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">tuple</span>) <span class="keyword">and</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj)))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">list</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj))]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">dict</span>) <span class="keyword">and</span> <span class="built_in">len</span>(obj) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">type</span>(obj)(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*<span class="built_in">map</span>(scatter_map, obj.items()))]</span><br><span class="line">        <span class="keyword">return</span> [obj <span class="keyword">for</span> targets <span class="keyword">in</span> target_gpus]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># After scatter_map is called, a scatter_map cell will exist. This cell</span></span><br><span class="line">    <span class="comment"># has a reference to the actual function scatter_map, which has references</span></span><br><span class="line">    <span class="comment"># to a closure that has a reference to the scatter_map cell (because the</span></span><br><span class="line">    <span class="comment"># fn is recursive). To avoid this reference cycle, we set the function to</span></span><br><span class="line">    <span class="comment"># None, clearing the cell</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = scatter_map(inputs)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        scatter_map = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>其中，针对 tensor 的函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scatter</span>(<span class="params">Function</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, target_gpus, chunk_sizes, dim, <span class="built_in">input</span></span>):</span></span><br><span class="line">        target_gpus = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> target_gpus]</span><br><span class="line">        ctx.dim = dim</span><br><span class="line">        ctx.input_device = <span class="built_in">input</span>.get_device() <span class="keyword">if</span> <span class="built_in">input</span>.device.<span class="built_in">type</span> != <span class="string">&quot;cpu&quot;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        streams = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">and</span> ctx.input_device == -<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Perform CPU to GPU copies in a background stream</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 新建 cuda stream</span></span><br><span class="line">            streams = [_get_stream(device) <span class="keyword">for</span> device <span class="keyword">in</span> target_gpus]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 真正的操作</span></span><br><span class="line">        outputs = comm.scatter(<span class="built_in">input</span>, target_gpus, chunk_sizes, ctx.dim, streams)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Synchronize with the copy stream</span></span><br><span class="line">        <span class="keyword">if</span> streams <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> i, output <span class="keyword">in</span> <span class="built_in">enumerate</span>(outputs):</span><br><span class="line">                <span class="keyword">with</span> torch.cuda.device(target_gpus[i]):</span><br><span class="line">                    main_stream = torch.cuda.current_stream()</span><br><span class="line">                    main_stream.wait_stream(streams[i])</span><br><span class="line">                    output.record_stream(main_stream)</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, *grad_output</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, Gather.apply(ctx.input_device, ctx.dim, *grad_output)</span><br></pre></td></tr></table></figure><p>comm.scatter 依赖于 C++，就不介绍了。</p><p>回顾 DP 代码块，我们已经运行完 scatter函数，即将一个 batch 近似等分成更小的 batch。接下来我们要看 replicate 函数和 gather 函数 （假设我们有不少于两张卡）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DP forward 里的代码</span></span><br><span class="line">   replicas = self.replicate(self.module, self.device_ids[:<span class="built_in">len</span>(inputs)])</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 实现</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">replicate</span>(<span class="params">network, devices, detach=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> _replicatable_module(network):</span><br><span class="line">           <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Cannot replicate network where python modules are &quot;</span></span><br><span class="line">                              <span class="string">&quot;childrens of ScriptModule&quot;</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> devices:</span><br><span class="line">           <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 需要复制到哪些 GPU， 复制多少份</span></span><br><span class="line">       devices = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> devices]</span><br><span class="line">       num_replicas = <span class="built_in">len</span>(devices)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 复制 parameters</span></span><br><span class="line">       params = <span class="built_in">list</span>(network.parameters())</span><br><span class="line">       param_indices = &#123;param: idx <span class="keyword">for</span> idx, param <span class="keyword">in</span> <span class="built_in">enumerate</span>(params)&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 拉到代码块底部看原函数，然后再回来</span></span><br><span class="line">       param_copies = _broadcast_coalesced_reshape(params, devices, detach)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 复制 buffers</span></span><br><span class="line">       buffers = <span class="built_in">list</span>(network.buffers())</span><br><span class="line">       buffers_rg = []</span><br><span class="line">       buffers_not_rg = []</span><br><span class="line">       <span class="keyword">for</span> buf <span class="keyword">in</span> buffers:</span><br><span class="line">           <span class="keyword">if</span> buf.requires_grad <span class="keyword">and</span> <span class="keyword">not</span> detach:</span><br><span class="line">               buffers_rg.append(buf)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               buffers_not_rg.append(buf)</span><br><span class="line"></span><br><span class="line">               <span class="comment"># 记录需要和不需要求导的 buffer 的 index</span></span><br><span class="line">       buffer_indices_rg = &#123;buf: idx <span class="keyword">for</span> idx, buf <span class="keyword">in</span> <span class="built_in">enumerate</span>(buffers_rg)&#125;</span><br><span class="line">       buffer_indices_not_rg = &#123;buf: idx <span class="keyword">for</span> idx, buf <span class="keyword">in</span> <span class="built_in">enumerate</span>(buffers_not_rg)&#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment"># 分别拷贝，这个咱们已经会了</span></span><br><span class="line">       buffer_copies_rg = _broadcast_coalesced_reshape(buffers_rg, devices, detach=detach)</span><br><span class="line">       buffer_copies_not_rg = _broadcast_coalesced_reshape(buffers_not_rg, devices, detach=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 现在开始拷贝网络</span></span><br><span class="line">       <span class="comment"># 准备过程：将 network.modules() 变成list</span></span><br><span class="line">       <span class="comment"># 然后再为之后复制的模型准备好空的 list 和 indices</span></span><br><span class="line"></span><br><span class="line">       modules = <span class="built_in">list</span>(network.modules())</span><br><span class="line">       module_copies = [[] <span class="keyword">for</span> device <span class="keyword">in</span> devices]</span><br><span class="line">       module_indices = &#123;&#125;</span><br><span class="line">       scriptmodule_skip_attr = &#123;<span class="string">&quot;_parameters&quot;</span>, <span class="string">&quot;_buffers&quot;</span>, <span class="string">&quot;_modules&quot;</span>, <span class="string">&quot;forward&quot;</span>, <span class="string">&quot;_c&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> i, module <span class="keyword">in</span> <span class="built_in">enumerate</span>(modules):</span><br><span class="line">           module_indices[module] = i</span><br><span class="line">           <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">               replica = module._replicate_for_data_parallel()</span><br><span class="line">               <span class="comment"># This is a temporary fix for DDP. DDP needs to access the</span></span><br><span class="line">               <span class="comment"># replicated model parameters. It used to do so through</span></span><br><span class="line">               <span class="comment"># `mode.parameters()`. The fix added in #33907 for DP stops the</span></span><br><span class="line">               <span class="comment"># `parameters()` API from exposing the replicated parameters.</span></span><br><span class="line">               <span class="comment"># Hence, we add a `_former_parameters` dict here to support DDP.</span></span><br><span class="line">               replica._former_parameters = OrderedDict()</span><br><span class="line"></span><br><span class="line">               module_copies[j].append(replica)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 接下来分别复制 module，param，buffer</span></span><br><span class="line">       <span class="keyword">for</span> i, module <span class="keyword">in</span> <span class="built_in">enumerate</span>(modules):</span><br><span class="line">           <span class="keyword">for</span> key, child <span class="keyword">in</span> module._modules.items():</span><br><span class="line">               <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       replica._modules[key] = <span class="literal">None</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   module_idx = module_indices[child]</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       <span class="built_in">setattr</span>(replica, key, module_copies[j][module_idx])</span><br><span class="line">           <span class="keyword">for</span> key, param <span class="keyword">in</span> module._parameters.items():</span><br><span class="line">               <span class="keyword">if</span> param <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       replica._parameters[key] = <span class="literal">None</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   param_idx = param_indices[param]</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       param = param_copies[j][param_idx]</span><br><span class="line">                       <span class="comment"># parameters in replicas are no longer leaves,</span></span><br><span class="line">                       <span class="comment"># so setattr them as non-parameter attributes</span></span><br><span class="line">                       <span class="built_in">setattr</span>(replica, key, param)</span><br><span class="line">                       <span class="comment"># expose the parameter for DDP</span></span><br><span class="line">                       replica._former_parameters[key] = param</span><br><span class="line">           <span class="keyword">for</span> key, buf <span class="keyword">in</span> module._buffers.items():</span><br><span class="line">               <span class="keyword">if</span> buf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       replica._buffers[key] = <span class="literal">None</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   <span class="keyword">if</span> buf.requires_grad <span class="keyword">and</span> <span class="keyword">not</span> detach:</span><br><span class="line">                       buffer_copies = buffer_copies_rg</span><br><span class="line">                       buffer_idx = buffer_indices_rg[buf]</span><br><span class="line">                   <span class="keyword">else</span>:</span><br><span class="line">                       buffer_copies = buffer_copies_not_rg</span><br><span class="line">                       buffer_idx = buffer_indices_not_rg[buf]</span><br><span class="line">                   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas):</span><br><span class="line">                       replica = module_copies[j][i]</span><br><span class="line">                       <span class="built_in">setattr</span>(replica, key, buffer_copies[j][buffer_idx])</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> [module_copies[j][<span class="number">0</span>] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_replicas)]</span><br><span class="line"></span><br><span class="line">   <span class="comment"># ！！！从replicate来看这里</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">_broadcast_coalesced_reshape</span>(<span class="params">tensors, devices, detach=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">from</span> ._functions <span class="keyword">import</span> Broadcast</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 先看 else 的 comment，因为不 detach 也会用到同样的函数</span></span><br><span class="line">     <span class="keyword">if</span> detach:</span><br><span class="line">         <span class="keyword">return</span> comm.broadcast_coalesced(tensors, devices)</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment"># Use the autograd function to broadcast if not detach</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(tensors) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 下拉看源码</span></span><br><span class="line">             tensor_copies = Broadcast.apply(devices, *tensors)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> [tensor_copies[i:i + <span class="built_in">len</span>(tensors)]</span><br><span class="line">                     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tensor_copies), <span class="built_in">len</span>(tensors))]</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment">#  Broadcast.apply</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Broadcast</span>(<span class="params">Function</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, target_gpus, *inputs</span>):</span></span><br><span class="line">       <span class="keyword">assert</span> <span class="built_in">all</span>(i.device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> inputs), (</span><br><span class="line">           <span class="string">&#x27;Broadcast function not implemented for CPU tensors&#x27;</span></span><br><span class="line">       )</span><br><span class="line">       target_gpus = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> target_gpus]</span><br><span class="line">       ctx.target_gpus = target_gpus</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(inputs) == <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">tuple</span>()</span><br><span class="line">       ctx.num_inputs = <span class="built_in">len</span>(inputs)</span><br><span class="line">       <span class="comment"># input 放在 device[0]</span></span><br><span class="line">       ctx.input_device = inputs[<span class="number">0</span>].get_device()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 和 detach 的情况一样</span></span><br><span class="line">       outputs = comm.broadcast_coalesced(inputs, ctx.target_gpus)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># comm.broadcast_coalesced 的代码</span></span><br><span class="line">       <span class="comment"># tensors 必须在同一个设备，CPU 或者 GPU； devices 即是要拷贝到的设备；buffer_size 则是最大的buffer</span></span><br><span class="line">       <span class="comment"># 这里用到 buffer 将小张量合并到缓冲区以减少同步次数</span></span><br><span class="line">       <span class="comment"># def broadcast_coalesced(tensors, devices, buffer_size=10485760):</span></span><br><span class="line">       <span class="comment">#    devices = [_get_device_index(d) for d in devices]</span></span><br><span class="line">           <span class="comment">#       return torch._C._broadcast_coalesced(tensors, devices, buffer_size)</span></span><br><span class="line"></span><br><span class="line">       non_differentiables = []</span><br><span class="line">       <span class="keyword">for</span> idx, input_requires_grad <span class="keyword">in</span> <span class="built_in">enumerate</span>(ctx.needs_input_grad[<span class="number">1</span>:]):</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> input_requires_grad:</span><br><span class="line">               <span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line">                   non_differentiables.append(output[idx])</span><br><span class="line">       ctx.mark_non_differentiable(*non_differentiables)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">tuple</span>([t <span class="keyword">for</span> tensors <span class="keyword">in</span> outputs <span class="keyword">for</span> t <span class="keyword">in</span> tensors])</span><br><span class="line"></span><br><span class="line"><span class="meta">   @staticmethod</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, *grad_outputs</span>):</span></span><br><span class="line">       <span class="keyword">return</span> (<span class="literal">None</span>,) + ReduceAddCoalesced.apply(ctx.input_device, ctx.num_inputs, *grad_outputs)</span><br></pre></td></tr></table></figure><p>下面继续 parallel_apply 部分。⚠️ DP 和 DDP 共用 parallel_apply 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DP 代码</span></span><br><span class="line">outputs = self.parallel_apply(replicas, inputs, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># threading 实现，用前面准备好的 replica 和输入数据，然后</span></span><br><span class="line"><span class="comment"># for 循环启动多线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallel_apply</span>(<span class="params">modules, inputs, kwargs_tup=<span class="literal">None</span>, devices=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个 GPU 都有模型和输入</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(modules) == <span class="built_in">len</span>(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保每个 GPU 都有相应的数据，如没有就空白补全</span></span><br><span class="line">    <span class="keyword">if</span> kwargs_tup <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="comment"># 咱们在 scatter 已经补全了</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(modules) == <span class="built_in">len</span>(kwargs_tup)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        kwargs_tup = (&#123;&#125;,) * <span class="built_in">len</span>(modules)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> devices <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(modules) == <span class="built_in">len</span>(devices)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        devices = [<span class="literal">None</span>] * <span class="built_in">len</span>(modules)</span><br><span class="line"></span><br><span class="line">    devices = [_get_device_index(x, <span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> devices]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多线程实现</span></span><br><span class="line"></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    grad_enabled, autocast_enabled = torch.is_grad_enabled(), torch.is_autocast_enabled()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义 worker</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_worker</span>(<span class="params">i, module, <span class="built_in">input</span>, kwargs, device=<span class="literal">None</span></span>):</span></span><br><span class="line">        torch.set_grad_enabled(grad_enabled)</span><br><span class="line">        <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            device = get_a_var(<span class="built_in">input</span>).get_device()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> torch.cuda.device(device), autocast(enabled=autocast_enabled):</span><br><span class="line">                <span class="comment"># this also avoids accidental slicing of `input` if it is a Tensor</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(<span class="built_in">input</span>, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)):</span><br><span class="line">                    <span class="built_in">input</span> = (<span class="built_in">input</span>,)</span><br><span class="line">                output = module(*<span class="built_in">input</span>, **kwargs)</span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="comment"># 并行计算得到输出</span></span><br><span class="line">                results[i] = output</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                results[i] = ExceptionWrapper(</span><br><span class="line">                    where=<span class="string">&quot;in replica &#123;&#125; on device &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, device))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(modules) &gt; <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 如有一个进程控制多个 GPU ，起多个线程</span></span><br><span class="line">      <span class="comment"># 需要强调一下，虽然 DDP 推荐单卡单进程，即每次调用 DDP device_ids 都只输入一张卡的 id（通常是 args.local_rank），但是如果输入多个 device_id，此时 DDP 就是单进程多线程控制多卡，和 DP 一样，关于 DDP 的解读可以看下文</span></span><br><span class="line"></span><br><span class="line">        threads = [threading.Thread(target=_worker,</span><br><span class="line">                                    args=(i, module, <span class="built_in">input</span>, kwargs, device))</span><br><span class="line">                   <span class="keyword">for</span> i, (module, <span class="built_in">input</span>, kwargs, device) <span class="keyword">in</span></span><br><span class="line">                   <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(modules, inputs, kwargs_tup, devices))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">            thread.start()</span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">            thread.join()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 一个 GPU 一个进程 （ DDP 推荐操作）</span></span><br><span class="line">        _worker(<span class="number">0</span>, modules[<span class="number">0</span>], inputs[<span class="number">0</span>], kwargs_tup[<span class="number">0</span>], devices[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inputs)):</span><br><span class="line">        output = results[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># error handle</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(output, ExceptionWrapper):</span><br><span class="line">            output.reraise()</span><br><span class="line">        outputs.append(output)</span><br><span class="line">    <span class="comment"># 输出 n 个计算结果</span></span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><p>现在我们已经得到并行计算的结果了，接下来我们要将结果收集到 device[0]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DP 代码</span></span><br><span class="line"><span class="keyword">return</span> self.gather(outputs, self.output_device)</span><br><span class="line"><span class="comment"># 收集到 devices[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">outputs, target_device, dim=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Gathers tensors from different GPUs on a specified device</span></span><br><span class="line"><span class="string">      (-1 means the CPU).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gather_map</span>(<span class="params">outputs</span>):</span></span><br><span class="line">        out = outputs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(out, torch.Tensor):</span><br><span class="line">            <span class="keyword">return</span> Gather.apply(target_device, dim, *outputs)</span><br><span class="line">        <span class="keyword">if</span> out <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(out, <span class="built_in">dict</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>((<span class="built_in">len</span>(out) == <span class="built_in">len</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> outputs)):</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&#x27;All dicts must have the same number of keys&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>(out)(((k, gather_map([d[k] <span class="keyword">for</span> d <span class="keyword">in</span> outputs]))</span><br><span class="line">                              <span class="keyword">for</span> k <span class="keyword">in</span> out))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(out)(<span class="built_in">map</span>(gather_map, <span class="built_in">zip</span>(*outputs)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursive function calls like this create reference cycles.</span></span><br><span class="line">    <span class="comment"># Setting the function to None clears the refcycle.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = gather_map(outputs)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        gather_map = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gather 源码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gather</span>(<span class="params">Function</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">ctx, target_device, dim, *inputs</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">all</span>(i.device.<span class="built_in">type</span> != <span class="string">&#x27;cpu&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> inputs), (</span><br><span class="line">            <span class="string">&#x27;Gather function not implemented for CPU tensors&#x27;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        target_device = _get_device_index(target_device, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        ctx.target_device = target_device</span><br><span class="line"></span><br><span class="line">        ctx.dim = dim</span><br><span class="line">        ctx.input_gpus = <span class="built_in">tuple</span>(i.get_device() <span class="keyword">for</span> i <span class="keyword">in</span> inputs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(t.dim() == <span class="number">0</span> <span class="keyword">for</span> t <span class="keyword">in</span> inputs) <span class="keyword">and</span> dim == <span class="number">0</span>:</span><br><span class="line">            inputs = <span class="built_in">tuple</span>(t.view(<span class="number">1</span>) <span class="keyword">for</span> t <span class="keyword">in</span> inputs)</span><br><span class="line">            warnings.warn(<span class="string">&#x27;Was asked to gather along dimension 0, but all &#x27;</span></span><br><span class="line">                          <span class="string">&#x27;input tensors were scalars; will instead unsqueeze &#x27;</span></span><br><span class="line">                          <span class="string">&#x27;and return a vector.&#x27;</span>)</span><br><span class="line">            ctx.unsqueezed_scalar = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ctx.unsqueezed_scalar = <span class="literal">False</span></span><br><span class="line">        ctx.input_sizes = <span class="built_in">tuple</span>(i.size(ctx.dim) <span class="keyword">for</span> i <span class="keyword">in</span> inputs)</span><br><span class="line">        <span class="keyword">return</span> comm.gather(inputs, ctx.dim, ctx.target_device)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">ctx, grad_output</span>):</span></span><br><span class="line">        scattered_grads = Scatter.apply(ctx.input_gpus, ctx.input_sizes, ctx.dim, grad_output)</span><br><span class="line">        <span class="keyword">if</span> ctx.unsqueezed_scalar:</span><br><span class="line">            scattered_grads = <span class="built_in">tuple</span>(g[<span class="number">0</span>] <span class="keyword">for</span> g <span class="keyword">in</span> scattered_grads)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">None</span>, <span class="literal">None</span>) + scattered_grads</span><br><span class="line"></span><br><span class="line"><span class="comment"># comm.gather 涉及到 C++，具体实现咱也不讲了 ；)  </span></span><br><span class="line"><span class="comment"># Gathers tensors from multiple GPU devices.   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">tensors, dim=<span class="number">0</span>, destination=<span class="literal">None</span>, *, out=<span class="literal">None</span></span>):</span></span><br><span class="line">    tensors = [_handle_complex(t) <span class="keyword">for</span> t <span class="keyword">in</span> tensors]</span><br><span class="line">    <span class="keyword">if</span> out <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> destination == -<span class="number">1</span>:</span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">&#x27;Using -1 to represent CPU tensor is deprecated. Please use a &#x27;</span></span><br><span class="line">                <span class="string">&#x27;device object or string instead, e.g., &quot;cpu&quot;.&#x27;</span>)</span><br><span class="line">        destination = _get_device_index(destination, allow_cpu=<span class="literal">True</span>, optional=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> torch._C._gather(tensors, dim, destination)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> destination <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">&quot;&#x27;destination&#x27; must not be specified when &#x27;out&#x27; is specified, but &quot;</span></span><br><span class="line">                <span class="string">&quot;got destination=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(destination))</span><br><span class="line">        <span class="keyword">return</span> torch._C._gather_out(tensors, out, dim)</span><br></pre></td></tr></table></figure><p>前向传播的时候我们会先用 Scatter 函数将数据从 device[0] 分配并复制到不同的卡，之后用 Replicate 函数将模型从 device[0] 复制到不同的卡，之后各个卡都有了同样的模型和不同的数据，分别调用 forward 计算损失和梯度。</p><p>反向传播的时候，我们会将梯度收集到 device[0] 然后在 device[0] 更新参数。</p><h4 id="分析">分析</h4><ul><li><p>负载不均衡</p><p>device[0] 负载大一些</p></li><li><p>通信开销</p><p>假设有 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 个 GPU， 完成一次通信需要时间 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7Bp%7D%7Bb%7D" alt="[公式]"> ，那么使用 PS 算法，总共需要花费时间 <img src="https://www.zhihu.com/equation?tex=T+%3D+2%28k-1%29%5Cfrac%7Bp%7D%7Bb%7D+" alt="[公式]"></p></li><li><p>单进程</p><p>The difference between <code>DistributedDataParallel</code> and <code>DataParallel</code> is: <code>DistributedDataParallel</code> uses multiprocessing where a process is created for each GPU, while <code>DataParallel</code> uses multithreading. By using multiprocessing, each GPU has its dedicated process, this avoids the performance overhead caused by GIL of Python interpreter.</p><p>全局解释器锁，简单来说就是，一个 Python 进程只能利用一个 CPU kernel，即单核多线程并发时，只能执行一个线程。考虑多核，多核多线程可能出现线程颠簸 (thrashing) 造成资源浪费，所以 Python 想要利用多核最好是多进程。</p></li></ul><h3 id="DDP">DDP</h3><h4 id="使用-2">使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;--save_dir&quot;</span>, default=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--local_rank&quot;</span>, default=-<span class="number">1</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;--world_size&quot;</span>, default=<span class="number">1</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化后端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># world_size 指的是总的并行进程数目</span></span><br><span class="line"><span class="comment"># 比如16张卡单卡单进程 就是 16</span></span><br><span class="line"><span class="comment"># 等到连接的进程数等于world_size，程序才会继续运行</span></span><br><span class="line">torch.distributed.init_process_group(backend=<span class="string">&#x27;nccl&#x27;</span>,</span><br><span class="line">                                         world_size=ws,</span><br><span class="line">                                         init_method=<span class="string">&#x27;env://&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.cuda.set_device(args.local_rank)</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">f&#x27;cuda:<span class="subst">&#123;args.local_rank&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = nn.Linear(<span class="number">2</span>,<span class="number">3</span>).to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># train dataset</span></span><br><span class="line"><span class="comment"># train_sampler</span></span><br><span class="line"><span class="comment"># train_loader</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 DDP，这里我们通过规定 device_id 用了单卡单进程</span></span><br><span class="line"><span class="comment"># 实际上根据我们前面对 parallel_apply 的解读，DDP 也支持一个进程控制多个线程利用多卡</span></span><br><span class="line">model = DDP(model,</span><br><span class="line">            device_ids=[args.local_rank],</span><br><span class="line">            output_device=args.local_rank).to(device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存模型 </span></span><br><span class="line"><span class="keyword">if</span> torch.distributed.get_rank() == <span class="number">0</span>:</span><br><span class="line">  torch.save(model.module.state_dict(),</span><br><span class="line">             <span class="string">&#x27;results/%s/model.pth&#x27;</span> % args.save_dir)</span><br></pre></td></tr></table></figure><h4 id="原理-2">原理</h4><p>和DP的区别：</p><p>1.多进程：和 DP 不同， DDP 采用多进程，最推荐的做法是每张卡一个进程从而避免上一节所说单进程带来的影响。前文也提到了 DP 和 DDP 共用一个 parallel_apply 函数，所以 DDP 同样支持单进程多线程多卡操作，自然也支持多进程多线程，不过需要注意一下 world_size。</p><p>2.通信效率：DP 的通信成本随着 GPU 数量线性增长，而 DDP 支持 Ring AllReduce，其通信成本是恒定的，与 GPU 数量无关。</p><p>3.同步参数：DP 通过收集梯度到 device[0]，在device[0] 更新参数，然后其他设备复制 device[0] 的参数实现各个模型同步；DDP 通过保证初始状态相同并且改变量也相同（指同步梯度） ，保证模型同步。</p><p>Ring AllReduce模型如下所示：</p><p><img src="https://i.loli.net/2021/05/16/kOYXy9deM3oUG4c.png" alt="ring-gpus.png"></p><p>Ring AllReduce是一种利用带宽优化环解决通信问题的方法，解决了DP通信成本和GPU的数量线性相关的问题，分为两个步骤：Scatter Reduce和All Gather</p><p>Scatter Reduce过程：首先，我们将参数分为k份，相邻的GPU传递不同的参数，在传递k-1次之后，可以得到每一份参数的累积（在不同的GPU上）。</p><p><img src="https://i.loli.net/2021/05/16/ctNmUGaEBXT2uA5.gif" alt="v2-4590aeb5fd981b1e6f926cc68605884a_b.gif"></p><p>All Gather：得到每一份参数的累积之后，再做一次传递，同步到所有的GPU上。</p><p><img src="https://i.loli.net/2021/05/16/clDb6TRnw1BPHf2.gif" alt="v2-c9df34575d7d95ec87d85575d25d6f37_b.gif"></p><p>根据这两个过程，我们可以计算到All Reduce的通信成本为： <img src="https://www.zhihu.com/equation?tex=2%28k-1%29%5Cfrac%7B%5Cfrac%7Bp%7D%7Bk%7D%7D%7Bb%7D" alt="[公式]"> ，和 GPU 数量无关了。</p><p>DDP 也是数据并行，所以每张卡都有模型和输入。我们以多进程多线程为例，每起一个进程，该进程的 device[0] 都会从本地复制模型，如果该进程仍有多线程，就像 DP，模型会从 device[0] 复制到其他设备。</p><p>DDP 通过 Reducer 来管理梯度同步。为了提高通讯效率， Reducer 会将梯度归到不同的桶里（按照模型参数的 reverse order， 因为反向传播需要符合这样的顺序），一次归约一个桶。其中桶的大小为参数 bucket_cap_mb 默认为 25，可根据需要调整。下图即为一个例子。</p><p>可以看到每个进程里，模型参数都按照倒序放在桶里，每次归约一个桶。</p><p><img src="https://i.loli.net/2021/05/17/umiJGts7Y2qfjzI.png" alt="72401724-d296d880-371a-11ea-90ab-737f86543df9.png"></p><p>终于可以看 DDP 的实现了！！首先我们贴上伪代码！</p><p><img src="https://i.loli.net/2021/05/17/D7NZUTiWJ23qfBb.png" alt="Screenshot from 2021-05-17 00-23-12.png"></p><p>从 DDP 的伪代码我们可以看出，DDP 最重要的包括三部分：</p><ul><li><p>constructor：负责在构建的时候将 rank 0 的 state_dict() 广播 ➜ 保证所有网络初始状态相同；初始化 buckets 并尽可能按逆序将 parameters 分配进 buckets ➜ 按桶通信提高效率；为每个 parameter 加上 grad_accumulator 以及在 autograd_graph 注册 autograd_hook ➜ 在 backward 时负责梯度同步。</p></li><li><p>forward：正常的 forward 操作；如果 self.find_unused_parameters 设置为 True，DDP 会在 forward 结束时 traverse autograd graph 找到所有没用过的parameters 并标记为 ready ➜ 虽说这一步开销很大，但是有时计算动态图会改变，所以很必要。</p></li><li><p>autograd_hook：这个 hook 是挂在 autograd graph 在 backward 时负责梯度同步的。当一个梯度计算好后，相应的 hook 会告诉 DDP 可以用来归约。当一个桶里的梯度都可以了，Reducer 就会启动异步 allreduce 去计算所有进程的平均值。当所有桶都可以了，Reducer 会等所有 allreduce 完成，然后将得到的梯度写到 param.grad。</p></li></ul><p>好的，但现在为止我们应该对 DDP 有了大致了解了，接下来就一起看一下代码是怎么实现的！</p><ul><li>通信：因为 DDP 依赖 c10d 的 ProcessGroup 进行通信，所以开始前我们先要有个 ProcessGroup 实例。这步可以通过 torch.distributed.init_process_group 实现。</li><li>构建：我们先贴上 DDP 初始化的源码，最重要的是 _ddp_init_helper 这个函数，负责多线程时复制模型、将 parameters 分组、创建 reducer 以及为 SyncBN 做准备等。这部分代码看 comment 就能懂，我们会重点说一下 dist.Reducer，作为管理器，自然很重要了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedDataParallel</span>(<span class="params">Module</span>):</span>       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, module, device_ids=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 output_device=<span class="literal">None</span>, dim=<span class="number">0</span>, broadcast_buffers=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 process_group=<span class="literal">None</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 bucket_cap_mb=<span class="number">25</span>,       </span></span></span><br><span class="line"><span class="function"><span class="params">                 find_unused_parameters=<span class="literal">False</span>,       </span></span></span><br><span class="line"><span class="function"><span class="params">                 check_reduction=<span class="literal">False</span>,      </span></span></span><br><span class="line"><span class="function"><span class="params">                 gradient_as_bucket_view=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(DistributedDataParallel, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">any</span>((p.requires_grad <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters())), (</span><br><span class="line">            <span class="string">&quot;DistributedDataParallel is not needed when a module &quot;</span></span><br><span class="line">            <span class="string">&quot;doesn&#x27;t have any parameter that requires a gradient.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.is_multi_device_module = <span class="built_in">len</span>(&#123;p.device <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()&#125;) &gt; <span class="number">1</span></span><br><span class="line">        distinct_device_types = &#123;p.device.<span class="built_in">type</span> <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()&#125;</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(distinct_device_types) == <span class="number">1</span>, (</span><br><span class="line">            <span class="string">&quot;DistributedDataParallel&#x27;s input module must be on &quot;</span></span><br><span class="line">            <span class="string">&quot;the same type of devices, but input module parameters locate in &#123;&#125;.&quot;</span></span><br><span class="line">        ).<span class="built_in">format</span>(distinct_device_types)</span><br><span class="line">        self.device_type = <span class="built_in">list</span>(distinct_device_types)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.device_type == <span class="string">&quot;cpu&quot;</span> <span class="keyword">or</span> self.is_multi_device_module:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">not</span> device_ids <span class="keyword">and</span> <span class="keyword">not</span> output_device, (</span><br><span class="line">                <span class="string">&quot;DistributedDataParallel device_ids and output_device arguments &quot;</span></span><br><span class="line">                <span class="string">&quot;only work with single-device GPU modules, but got &quot;</span></span><br><span class="line">                <span class="string">&quot;device_ids &#123;&#125;, output_device &#123;&#125;, and module parameters &#123;&#125;.&quot;</span></span><br><span class="line">            ).<span class="built_in">format</span>(device_ids, output_device, &#123;p.device <span class="keyword">for</span> p <span class="keyword">in</span> module.parameters()&#125;)</span><br><span class="line"></span><br><span class="line">            self.device_ids = <span class="literal">None</span></span><br><span class="line">            self.output_device = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Use all devices by default for single-device GPU modules</span></span><br><span class="line">            <span class="keyword">if</span> device_ids <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                device_ids = _get_all_device_indices()</span><br><span class="line"></span><br><span class="line">            self.device_ids = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: _get_device_index(x, <span class="literal">True</span>), device_ids))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> output_device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                output_device = device_ids[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            self.output_device = _get_device_index(output_device, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> process_group <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.process_group = _get_default_group()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.process_group = process_group</span><br><span class="line"></span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.module = module</span><br><span class="line">        self.device = <span class="built_in">list</span>(self.module.parameters())[<span class="number">0</span>].device</span><br><span class="line">        self.broadcast_buffers = broadcast_buffers</span><br><span class="line">        self.find_unused_parameters = find_unused_parameters</span><br><span class="line">        self.require_backward_grad_sync = <span class="literal">True</span></span><br><span class="line">        self.require_forward_param_sync = <span class="literal">True</span></span><br><span class="line">        self.ddp_join_enabled = <span class="literal">False</span></span><br><span class="line">        self.gradient_as_bucket_view = gradient_as_bucket_view</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check_reduction:</span><br><span class="line">            <span class="comment"># This argument is no longer used since the reducer</span></span><br><span class="line">            <span class="comment"># will ensure reduction completes even if some parameters</span></span><br><span class="line">            <span class="comment"># do not receive gradients.</span></span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">&quot;The `check_reduction` argument in `DistributedDataParallel` &quot;</span></span><br><span class="line">                <span class="string">&quot;module is deprecated. Please avoid using it.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># used for intra-node param sync and inter-node sync as well</span></span><br><span class="line">        self.broadcast_bucket_size = <span class="built_in">int</span>(<span class="number">250</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># reduction bucket size</span></span><br><span class="line">        self.bucket_bytes_cap = <span class="built_in">int</span>(bucket_cap_mb * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保证初始状态一样</span></span><br><span class="line">        <span class="comment"># Sync params and buffers</span></span><br><span class="line">        self._sync_params_and_buffers(authoritative_rank=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下拉看源码</span></span><br><span class="line">        self._ddp_init_helper()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sync_params_and_buffers</span>(<span class="params">self, authoritative_rank=<span class="number">0</span></span>):</span></span><br><span class="line">        module_states = <span class="built_in">list</span>(self.module.state_dict().values())</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(module_states) &gt; <span class="number">0</span>:</span><br><span class="line">            self._distributed_broadcast_coalesced(</span><br><span class="line">                module_states,</span><br><span class="line">                self.broadcast_bucket_size,</span><br><span class="line">                authoritative_rank)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_ddp_init_helper</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialization helper function that does the following:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        (1) replicating the module from device[0] to the other devices （前文提到 DDP 也支持一个进程多线程利用多卡，类似 DP ，这时候就会用到第一步）</span></span><br><span class="line"><span class="string">        (2) bucketing the parameters for reductions （把 parameter 分组，梯度通讯时，先得到梯度的会通讯）</span></span><br><span class="line"><span class="string">        (3) resetting the bucketing states</span></span><br><span class="line"><span class="string">        (4) registering the grad hooks （创建管理器）</span></span><br><span class="line"><span class="string">        (5) passing a handle of DDP to SyncBatchNorm Layer （为 SyncBN 准备）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">parameters</span>(<span class="params">m, recurse=<span class="literal">True</span></span>):</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">model_parameters</span>(<span class="params">m</span>):</span></span><br><span class="line">                ps = m._former_parameters.values() \</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">hasattr</span>(m, <span class="string">&quot;_former_parameters&quot;</span>) \</span><br><span class="line">                    <span class="keyword">else</span> m.parameters(recurse=<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">                    <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> m.modules() <span class="keyword">if</span> recurse <span class="keyword">else</span> [m]:</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> model_parameters(m):</span><br><span class="line">                    <span class="keyword">yield</span> p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.device_ids <span class="keyword">and</span> <span class="built_in">len</span>(self.device_ids) &gt; <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">&quot;Single-Process Multi-GPU is not the recommended mode for &quot;</span></span><br><span class="line">                <span class="string">&quot;DDP. In this mode, each DDP instance operates on multiple &quot;</span></span><br><span class="line">                <span class="string">&quot;devices and creates multiple module replicas within one &quot;</span></span><br><span class="line">                <span class="string">&quot;process. The overhead of scatter/gather and GIL contention &quot;</span></span><br><span class="line">                <span class="string">&quot;in every forward pass can slow down training. &quot;</span></span><br><span class="line">                <span class="string">&quot;Please consider using one DDP instance per device or per &quot;</span></span><br><span class="line">                <span class="string">&quot;module replica by explicitly setting device_ids or &quot;</span></span><br><span class="line">                <span class="string">&quot;CUDA_VISIBLE_DEVICES. &quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># only create replicas for single-device CUDA modules</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># <span class="doctag">TODO:</span> we don&#x27;t need to replicate params in here. they&#x27;re always going to</span></span><br><span class="line">            <span class="comment"># be broadcasted using larger blocks in broadcast_coalesced, so it might be</span></span><br><span class="line">            <span class="comment"># better to not pollute the caches with these small blocks</span></span><br><span class="line">            self._module_copies = replicate(self.module, self.device_ids, detach=<span class="literal">True</span>)</span><br><span class="line">            self._module_copies[<span class="number">0</span>] = self.module</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> module_copy <span class="keyword">in</span> self._module_copies[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">for</span> param, copy_param <span class="keyword">in</span> <span class="built_in">zip</span>(self.module.parameters(), parameters(module_copy)):</span><br><span class="line">                    <span class="comment"># Reducer requires param copies have the same strides across replicas.</span></span><br><span class="line">                    <span class="comment"># Fixes up copy_param strides in case replicate didn&#x27;t match param strides.</span></span><br><span class="line">                    <span class="keyword">if</span> param.layout <span class="keyword">is</span> torch.strided <span class="keyword">and</span> param.stride() != copy_param.stride():</span><br><span class="line">                        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                            copy_param.set_(copy_param.clone()</span><br><span class="line">                                                      .as_strided(param.size(), param.stride())</span><br><span class="line">                                                      .copy_(copy_param))</span><br><span class="line">                    copy_param.requires_grad = param.requires_grad</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._module_copies = [self.module]</span><br><span class="line"></span><br><span class="line">        self.modules_params = [<span class="built_in">list</span>(parameters(m)) <span class="keyword">for</span> m <span class="keyword">in</span> self._module_copies]</span><br><span class="line">        self.modules_buffers = [<span class="built_in">list</span>(m.buffers()) <span class="keyword">for</span> m <span class="keyword">in</span> self._module_copies]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Build tuple of (module, parameter) for all parameters that require grads.</span></span><br><span class="line">        modules_and_parameters = [</span><br><span class="line">            [</span><br><span class="line">                (module, parameter)</span><br><span class="line">                <span class="keyword">for</span> module <span class="keyword">in</span> replica.modules()</span><br><span class="line">                <span class="keyword">for</span> parameter <span class="keyword">in</span> <span class="built_in">filter</span>(</span><br><span class="line">                    <span class="keyword">lambda</span> parameter: parameter.requires_grad,</span><br><span class="line">                    parameters(module, recurse=<span class="literal">False</span>))</span><br><span class="line">            ] <span class="keyword">for</span> replica <span class="keyword">in</span> self._module_copies]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Build list of parameters.</span></span><br><span class="line">        parameters = [</span><br><span class="line">            <span class="built_in">list</span>(parameter <span class="keyword">for</span> _, parameter <span class="keyword">in</span> replica)</span><br><span class="line">            <span class="keyword">for</span> replica <span class="keyword">in</span> modules_and_parameters]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Checks if a module will produce a sparse gradient.</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">produces_sparse_gradient</span>(<span class="params">module</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(module, torch.nn.Embedding):</span><br><span class="line">                <span class="keyword">return</span> module.sparse</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(module, torch.nn.EmbeddingBag):</span><br><span class="line">                <span class="keyword">return</span> module.sparse</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Build list of booleans indicating whether or not to expect sparse</span></span><br><span class="line">        <span class="comment"># gradients for the corresponding parameters.</span></span><br><span class="line">        expect_sparse_gradient = [</span><br><span class="line">            <span class="built_in">list</span>(produces_sparse_gradient(module) <span class="keyword">for</span> module, _ <span class="keyword">in</span> replica)</span><br><span class="line">            <span class="keyword">for</span> replica <span class="keyword">in</span> modules_and_parameters]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The bucket size limit is specified in the constructor.</span></span><br><span class="line">        <span class="comment"># Additionally, we allow for a single small bucket for parameters</span></span><br><span class="line">        <span class="comment"># that are defined first, such that their gradients don&#x27;t spill into</span></span><br><span class="line">        <span class="comment"># a much larger bucket, adding unnecessary latency after gradient</span></span><br><span class="line">        <span class="comment"># computation finishes. Experiments showed 1MB is a reasonable value.</span></span><br><span class="line">        bucket_indices = dist._compute_bucket_assignment_by_size(</span><br><span class="line">            parameters[<span class="number">0</span>],</span><br><span class="line">            [dist._DEFAULT_FIRST_BUCKET_BYTES, self.bucket_bytes_cap],</span><br><span class="line">            expect_sparse_gradient[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Note: reverse list of buckets because we want to approximate the</span></span><br><span class="line">        <span class="comment"># order in which their gradients are produced, and assume they</span></span><br><span class="line">        <span class="comment"># are used in the forward pass in the order they are defined.</span></span><br><span class="line">        <span class="comment"># 管理器</span></span><br><span class="line">        self.reducer = dist.Reducer(</span><br><span class="line">            parameters,</span><br><span class="line">            <span class="built_in">list</span>(<span class="built_in">reversed</span>(bucket_indices)),</span><br><span class="line">            self.process_group,</span><br><span class="line">            expect_sparse_gradient,</span><br><span class="line">            self.bucket_bytes_cap,</span><br><span class="line">            self.find_unused_parameters,</span><br><span class="line">            self.gradient_as_bucket_view)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># passing a handle to torch.nn.SyncBatchNorm layer</span></span><br><span class="line">        self._passing_sync_batchnorm_handle(self._module_copies)</span><br></pre></td></tr></table></figure><p>每个 DDP 进程都会创建本地 Reducer 在 backward 时管理梯度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.reducer = dist.Reducer(</span><br><span class="line">     parameters,</span><br><span class="line">     <span class="built_in">list</span>(<span class="built_in">reversed</span>(bucket_indices)),</span><br><span class="line">     self.process_group,</span><br><span class="line">     expect_sparse_gradient,</span><br><span class="line">     self.bucket_bytes_cap,</span><br><span class="line">     self.find_unused_parameters,</span><br><span class="line">     self.gradient_as_bucket_view)</span><br></pre></td></tr></table></figure><p>我们看 Reducer.cpp 可以发现，构建 Reducer 时，除了各种初始化，最重要的一步就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> replica_count = replicas_.<span class="built_in">size</span>();</span><br><span class="line">  grad_accumulators_.<span class="built_in">resize</span>(replica_count);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> replica_index = <span class="number">0</span>; replica_index &lt; replica_count;</span><br><span class="line">       replica_index++) &#123;         </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> variable_count = replicas_[replica_index].<span class="built_in">size</span>();</span><br><span class="line">    grad_accumulators_[replica_index].<span class="built_in">resize</span>(variable_count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> variable_index = <span class="number">0</span>; variable_index &lt; variable_count;</span><br><span class="line">         variable_index++) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="keyword">auto</span>&amp; variable = replicas_[replica_index][variable_index];  </span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> index = <span class="built_in">VariableIndex</span>(replica_index, variable_index);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The gradient accumulator function is lazily initialized once.</span></span><br><span class="line">      <span class="comment">// Therefore we can use its presence in the autograd graph as</span></span><br><span class="line">      <span class="comment">// evidence that the parameter has participated in an iteration.</span></span><br><span class="line">      <span class="keyword">auto</span> grad_accumulator =</span><br><span class="line">          torch::autograd::impl::<span class="built_in">grad_accumulator</span>(variable);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">        <span class="keyword">using</span> torch::distributed::autograd::ThreadLocalDistAutogradContext;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// grad_accumulator 执行完后，autograd_hook 就会运行</span></span><br><span class="line">        hooks.<span class="built_in">emplace_back</span>(</span><br><span class="line">            grad_accumulator-&gt;<span class="built_in">add_post_hook</span>(</span><br><span class="line">                torch::make_unique&lt;torch::autograd::utils::LambdaPostHook&gt;(</span><br><span class="line">                    [=](<span class="keyword">const</span> torch::autograd::variable_list&amp; outputs,</span><br><span class="line">                        <span class="keyword">const</span> torch::autograd::variable_list&amp; <span class="comment">/* unused */</span>)&#123;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></span><br><span class="line">                         <span class="keyword">this</span>-&gt;rpc_context.<span class="built_in">set</span>(</span><br><span class="line">                             ThreadLocalDistAutogradContext::<span class="built_in">getContextPtr</span>());   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                         <span class="keyword">this</span>-&gt;<span class="built_in">autograd_hook</span>(index);</span><br><span class="line">                         <span class="keyword">return</span> outputs;</span><br><span class="line">                       &#125;)),</span><br><span class="line">               grad_accumulator);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Map raw function pointer to replica index and parameter index.</span></span><br><span class="line">          <span class="comment">// This is used later on when the autograd graph is traversed</span></span><br><span class="line">          <span class="comment">// to check for parameters for which no gradient is computed.</span></span><br><span class="line">          func_[grad_accumulator.<span class="built_in">get</span>()] = index;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// The gradient accumulator is stored as weak_ptr in the autograd</span></span><br><span class="line">          <span class="comment">// metadata of the variable, so we have to keep it alive here for</span></span><br><span class="line">          <span class="comment">// the raw pointer to be valid.</span></span><br><span class="line">          grad_accumulators_[replica_index][variable_index] =</span><br><span class="line">              std::<span class="built_in">move</span>(grad_accumulator);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unordered_map&lt;torch::autograd::Node*, VariableIndex&gt; func_;</span></span><br><span class="line">    <span class="comment">// func_ 存了grad_accumulator &amp; index 的对应，方便我们之后在 autograd graph 寻找 unused parameters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  std::vector&lt;std::vector&lt;std::shared_ptr&lt;torch::autograd::Node&gt;&gt;&gt;</span></span><br><span class="line">    <span class="comment">//  grad_accumulators_;</span></span><br><span class="line">    <span class="comment">//  grad_accumulators_ 对应的 index 存了相应的 grad_accumulator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//   std::vector&lt;std::pair&lt;uintptr_t, std::shared_ptr&lt;torch::autograd::Node&gt;&gt;&gt;</span></span><br><span class="line">    <span class="comment">//   hooks_;</span></span><br></pre></td></tr></table></figure><p>其中，发挥重要功能的 autograd_hook 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reducer::autograd_hook</span><span class="params">(VariableIndex index)</span> </span>&#123;</span><br><span class="line">     <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;mutex_)</span></span>;</span><br><span class="line">     <span class="keyword">if</span> (find_unused_parameters_) &#123;</span><br><span class="line">       <span class="comment">// 在 no_sync 时，只要参数被用过一次，就会被标记为用过</span></span><br><span class="line">       <span class="comment">// Since it gets here, this param has been used for this iteration. We want</span></span><br><span class="line">       <span class="comment">// to mark it in local_used_maps_. During no_sync session, the same var can</span></span><br><span class="line">       <span class="comment">// be set multiple times, which is OK as does not affect correctness. As</span></span><br><span class="line">       <span class="comment">// long as it is used once during no_sync session, it is marked as used.</span></span><br><span class="line">       local_used_maps_[index.replica_index][index.variable_index] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore if we don&#x27;t expect to be called.</span></span><br><span class="line">    <span class="comment">// This may be the case if the user wants to accumulate gradients</span></span><br><span class="line">    <span class="comment">// for number of iterations before reducing them.</span></span><br><span class="line">    <span class="keyword">if</span> (!expect_autograd_hooks_) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild bucket only if 1) it is the first time to rebuild bucket 2)</span></span><br><span class="line">    <span class="comment">// find_unused_parameters_ is false, currently it does not support when there</span></span><br><span class="line">    <span class="comment">// are unused parameters 3) this backward pass needs to run allreduce. Here,</span></span><br><span class="line">    <span class="comment">// we just dump tensors and their parameter indices into rebuilt_params_ and</span></span><br><span class="line">    <span class="comment">// rebuilt_param_indices_ based on gradient arriving order, and then at the</span></span><br><span class="line">    <span class="comment">// end of finalize_backward(), buckets will be rebuilt based on</span></span><br><span class="line">    <span class="comment">// rebuilt_params_ and rebuilt_param_indices_, and then will be broadcasted</span></span><br><span class="line">    <span class="comment">// and initialized. Also we only need to dump tensors and parameter indices of</span></span><br><span class="line">    <span class="comment">// one replica.</span></span><br><span class="line">    <span class="built_in">push_rebuilt_params</span>(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If `find_unused_parameters_` is true there may be model parameters that</span></span><br><span class="line">    <span class="comment">// went unused when computing the model output, they won&#x27;t be part of the</span></span><br><span class="line">    <span class="comment">// autograd graph, and won&#x27;t receive gradients. These parameters are</span></span><br><span class="line">    <span class="comment">// discovered in the `prepare_for_backward` function and their indexes stored</span></span><br><span class="line">    <span class="comment">// in the `unused_parameters_` vector.</span></span><br><span class="line">    <span class="keyword">if</span> (!has_marked_unused_parameters_ &amp;&amp; find_unused_parameters_) &#123;</span><br><span class="line">      has_marked_unused_parameters_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; unused_index : unused_parameters_) &#123;</span><br><span class="line">        <span class="built_in">mark_variable_ready</span>(unused_index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally mark variable for which this function was originally called.</span></span><br><span class="line">    <span class="built_in">mark_variable_ready</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前向传播</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs, *kwargs</span>):</span>           <span class="keyword">if</span> self.ddp_join_enabled:               ones = torch.ones(                   <span class="number">1</span>, device=self.device               )               work = dist.all_reduce(ones, group=self.process_group, async_op=<span class="literal">True</span>)               self.reducer._set_forward_pass_work_handle(                   work, self.ddp_join_divide_by_initial_world_size               )</span><br><span class="line"><span class="comment"># Calling _rebuild_buckets before forward compuation,</span></span><br><span class="line">      <span class="comment"># It may allocate new buckets before deallocating old buckets</span></span><br><span class="line">      <span class="comment"># inside _rebuild_buckets. To save peak memory usage,</span></span><br><span class="line">      <span class="comment"># call _rebuild_buckets before the peak memory usage increases</span></span><br><span class="line">      <span class="comment"># during forward computation.</span></span><br><span class="line">      <span class="comment"># This should be called only once during whole training period.</span></span><br><span class="line">      <span class="keyword">if</span> self.reducer._rebuild_buckets():</span><br><span class="line">          logging.info(<span class="string">&quot;Reducer buckets have been rebuilt in this iteration.&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> self.require_forward_param_sync:</span><br><span class="line">          self._sync_params()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> self.ddp_join_enabled:</span><br><span class="line">          <span class="comment"># Notify joined ranks whether they should sync in backwards pass or not.</span></span><br><span class="line">          self._check_global_requires_backward_grad_sync(is_joined_rank=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># ！！！</span></span><br><span class="line">      <span class="keyword">if</span> self.device_ids:</span><br><span class="line">          inputs, kwargs = self.scatter(inputs, kwargs, self.device_ids)</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(self.device_ids) == <span class="number">1</span>:</span><br><span class="line">              output = self.module(*inputs[<span class="number">0</span>], **kwargs[<span class="number">0</span>])</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 单进程多线程多卡的情况</span></span><br><span class="line">              outputs = self.parallel_apply(self._module_copies[:<span class="built_in">len</span>(inputs)], inputs, kwargs)</span><br><span class="line">              output = self.gather(outputs, self.output_device)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          output = self.module(*inputs, **kwargs)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> torch.is_grad_enabled() <span class="keyword">and</span> self.require_backward_grad_sync:</span><br><span class="line">          self.require_forward_param_sync = <span class="literal">True</span></span><br><span class="line">          <span class="comment"># We&#x27;ll return the output object verbatim since it is a freeform</span></span><br><span class="line">          <span class="comment"># object. We need to find any tensors in this object, though,</span></span><br><span class="line">          <span class="comment"># because we need to figure out which parameters were used during</span></span><br><span class="line">          <span class="comment"># this forward pass, to ensure we short circuit reduction for any</span></span><br><span class="line">          <span class="comment"># unused parameters. Only if `find_unused_parameters` is set.</span></span><br><span class="line">          <span class="keyword">if</span> self.find_unused_parameters:</span><br><span class="line">          <span class="comment"># 当DDP参数 find_unused_parameter 为 true 时，其会在 forward 结束时，启动一个回溯，标记出所有没被用到的 parameter，提前把这些设定为 ready，这样 backward 就可以在一个 subgraph 进行，但这样会牺牲一部分时间。</span></span><br><span class="line">              self.reducer.prepare_for_backward(<span class="built_in">list</span>(_find_tensors(output)))</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              self.reducer.prepare_for_backward([])</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          self.require_forward_param_sync = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><ul><li>反向传播</li></ul><p>那么，DDP 究竟是怎么启动 allreduce 的呢？我们看一下 reducer.cpp 里对桶的定义以及用法，主要是在mark_*_ready。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span>       std::vector replicas;</span><br><span class="line"><span class="comment">// Global indices of participating variables in the bucket</span></span><br><span class="line">  std::vector&lt;<span class="keyword">size_t</span>&gt; variable_indices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of replicas to be marked done before this bucket is ready.</span></span><br><span class="line">  <span class="comment">// 计数</span></span><br><span class="line">  <span class="keyword">size_t</span> pending;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep work handle around when this set of buckets is being reduced.</span></span><br><span class="line">  std::shared_ptr&lt;c10d::ProcessGroup::Work&gt; work;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep future work handle around if DDP comm hook is registered.</span></span><br><span class="line">  c10::intrusive_ptr&lt;torch::jit::Future&gt; future_work;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this bucket should expect a single sparse gradient.</span></span><br><span class="line">  <span class="comment">// Implies: replicas[i].variables.size() == 1.</span></span><br><span class="line">  <span class="keyword">bool</span> expect_sparse_gradient = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看 mark_variable_ready，截取片段（指去除报错信息）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reducer::mark_variable_ready</span><span class="params">(VariableIndex index)</span> </span>&#123;     <span class="keyword">const</span> <span class="keyword">auto</span> replica_index = index.replica_index;     <span class="keyword">const</span> <span class="keyword">auto</span> variable_index = index.variable_index;     <span class="built_in">TORCH_CHECK</span>(replica_index &lt; replicas_.<span class="built_in">size</span>(), <span class="string">&quot;Out of range replica index.&quot;</span>);     <span class="built_in">TORCH_CHECK</span>(         variable_index &lt; variable_locators_.<span class="built_in">size</span>(),         <span class="string">&quot;Out of range variable index.&quot;</span>);     backward_stats_[replica_index][variable_index] =         <span class="built_in">current_time_in_nanos</span>() - backward_stats_base_;</span><br><span class="line"><span class="comment">// 每当变量被标记成 ready 了，都要调用一下 finalize</span></span><br><span class="line">require_finalize_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; bucket_index = variable_locators_[variable_index];</span><br><span class="line"><span class="keyword">auto</span>&amp; bucket = buckets_[bucket_index.bucket_index];</span><br><span class="line"><span class="keyword">auto</span>&amp; replica = bucket.replicas[replica_index];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// If it was scheduled, wait on allreduce in forward pass that tells us</span></span><br><span class="line"><span class="comment">// division factor based on no. of currently participating processes.</span></span><br><span class="line"><span class="keyword">if</span> (divFactor_ == kUnsetDivFactor) &#123;</span><br><span class="line">  divFactor_ = process_group_-&gt;<span class="built_in">getSize</span>();</span><br><span class="line">  <span class="keyword">auto</span>&amp; workHandle = forwardPassWorkHandle_.workHandle;</span><br><span class="line">  <span class="keyword">if</span> (workHandle &amp;&amp; !forwardPassWorkHandle_.useStaticWorldSize) &#123;</span><br><span class="line">    workHandle-&gt;<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">auto</span> results = workHandle-&gt;<span class="built_in">result</span>();</span><br><span class="line">    <span class="comment">// Guard against the results being empty</span></span><br><span class="line">    <span class="built_in">TORCH_INTERNAL_ASSERT</span>(results.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">    at::Tensor&amp; res = results.<span class="built_in">front</span>();</span><br><span class="line">    divFactor_ = res.<span class="built_in">item</span>().to&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bucket.expect_sparse_gradient) &#123;</span><br><span class="line">  <span class="built_in">mark_variable_ready_sparse</span>(index);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">mark_variable_ready_dense</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查桶里的变量是不是都ready了，如果没有东西 pending，那就是都 ready了</span></span><br><span class="line"><span class="keyword">if</span> (--replica.pending == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (--bucket.pending == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">mark_bucket_ready</span>(bucket_index.bucket_index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run finalizer function and kick off reduction for local_used_maps once the</span></span><br><span class="line"><span class="comment">// final bucket was marked ready.</span></span><br><span class="line"><span class="keyword">if</span> (next_bucket_ == buckets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (find_unused_parameters_) &#123;</span><br><span class="line">    <span class="comment">// H2D from local_used_maps_ to local_used_maps_dev_</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; local_used_maps_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">// We do async H2D to avoid the blocking overhead. The async copy and</span></span><br><span class="line">      <span class="comment">// allreduce respect the current stream, so will be sequenced correctly.</span></span><br><span class="line">      local_used_maps_dev_[i].<span class="built_in">copy_</span>(local_used_maps_[i], <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    local_used_work_ = process_group_-&gt;<span class="built_in">allreduce</span>(local_used_maps_dev_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The autograd engine uses the default stream when running callbacks, so we</span></span><br><span class="line">  <span class="comment">// pass in the current CUDA stream in case it is not the default.</span></span><br><span class="line">  c10::DeviceType deviceType = replica.contents.<span class="built_in">device</span>().<span class="built_in">type</span>();</span><br><span class="line">  <span class="keyword">const</span> c10::impl::VirtualGuardImpl guard =</span><br><span class="line">      c10::impl::VirtualGuardImpl&#123;deviceType&#125;;</span><br><span class="line">  <span class="keyword">const</span> c10::Stream currentStream =</span><br><span class="line">      guard.<span class="built_in">getStream</span>(replica.contents.<span class="built_in">device</span>());</span><br><span class="line">  torch::autograd::Engine::<span class="built_in">get_default_engine</span>().<span class="built_in">queue_callback</span>([=] &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;mutex_);</span><br><span class="line">    <span class="comment">// Run callback with the current stream</span></span><br><span class="line">    c10::OptionalStreamGuard currentStreamGuard&#123;currentStream&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">finalize_backward</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reducer::mark_bucket_ready</span><span class="params">(<span class="keyword">size_t</span> bucket_index)</span> </span>&#123;     <span class="built_in">TORCH_INTERNAL_ASSERT</span>(bucket_index &gt;= next_bucket_);</span><br><span class="line"><span class="comment">// Buckets are reduced in sequence. Ignore this bucket if</span></span><br><span class="line"><span class="comment">// it&#x27;s not its turn to be reduced.</span></span><br><span class="line"><span class="keyword">if</span> (bucket_index &gt; next_bucket_) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep going, until we either:</span></span><br><span class="line"><span class="comment">// - 所有桶都在 allreduce 那就等着 or</span></span><br><span class="line"><span class="comment">// - 还有桶没好，那也等着.</span></span><br><span class="line"><span class="keyword">for</span> (; next_bucket_ &lt; buckets_.<span class="built_in">size</span>() &amp;&amp; buckets_[next_bucket_].pending == <span class="number">0</span>;</span><br><span class="line">     next_bucket_++) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; bucket = buckets_[next_bucket_];</span><br><span class="line">  std::vector&lt;at::Tensor&gt; tensors;</span><br><span class="line">  tensors.<span class="built_in">reserve</span>(bucket.replicas.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; replica : bucket.replicas) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CUDA default stream 都按时序排好了</span></span><br><span class="line">    tensors.<span class="built_in">push_back</span>(replica.contents);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (comm_hook_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没注册 comm_hook，直接 allreduce</span></span><br><span class="line">    bucket.work = process_group_-&gt;<span class="built_in">allreduce</span>(tensors);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注册了 comm_hook 那就先跑 hook</span></span><br><span class="line">    <span class="comment">// 需要注意的是，这个comm_hook 只是处理通信的底层hook，如果想在 reduce 前分别进行梯度裁剪，还是需要在 autograph 挂 hook</span></span><br><span class="line">    bucket.future_work = comm_hook_-&gt;<span class="built_in">runHook</span>(<span class="built_in">GradBucket</span>(tensors));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>除了正常的前向传播，DDP 还允许在 subgraph 进行反向传播，只需将 self.find_unused_parameters 设置为 True。或许有朋友会问，如果 find_unused_parameters 设置为 True，那每次都要 traverse 计算图，明明开销很大，为什么有时候我们还要将 self.find_unused_parameters 设置为 True？ 这是因为训练时有可能某次迭代只用到整个模型的一个 subgraph， 并且这个 subgraph 迭代时可能会改变，就是说某些参数可能会在训练时被跳过。但因为所有parameters 在一开始就被分好桶了，而我们的 hook 又规定了只有整个桶 ready 了（pending==0）才会通信，如果我们不将 unused parameter 标记为 ready，整个过程会没法进行。我们在这节结束的部分附上一个小实验验证一下。</p><p>DDP 通过在构建时注册 autograd hook 进行梯度同步。当一个梯度计算好后，相应的 hook 会告诉 DDP 可以用来归约。当一个桶里的梯度都可以了，Reducer 就会启动异步 allreduce 去计算所有进程的平均值。当所有桶都可以了，Reducer 会等所有 allreduce 完成，然后将得到的梯度写到 param.grad。</p><p>optimizer step 独立于 DDP，所有进程的模型能够同步是因为初始状态相同并且改变量也相同。</p><ul><li>实验：find_unused_params</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> torch   </span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist   </span><br><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp   </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn   </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim   </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP</span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> default_timer <span class="keyword">as</span> timer</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="string">&#x27;localhost&#x27;</span>   </span><br><span class="line">os.environ[<span class="string">&#x27;MASTER_PORT&#x27;</span>] = <span class="string">&#x27;12138&#x27;</span>   </span><br><span class="line"><span class="comment"># sync   </span></span><br><span class="line">seed = <span class="number">0</span>   </span><br><span class="line">torch.manual_seed(seed)   </span><br><span class="line">torch.cuda.manual_seed(seed)   </span><br><span class="line">torch.cuda.manual_seed_all(seed)   </span><br><span class="line">os.environ[<span class="string">&#x27;PYTHONHASHSEED&#x27;</span>] = <span class="built_in">str</span>(seed)   </span><br><span class="line">torch.backends.cudnn.deterministic = <span class="literal">True</span>   </span><br><span class="line">torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span>(<span class="params">rank, world_size</span>):</span>       </span><br><span class="line">    <span class="comment"># create default process group       </span></span><br><span class="line">    dist.init_process_group(<span class="string">&quot;gloo&quot;</span>,rank=rank, </span><br><span class="line">world_size=world_size,init_method=<span class="string">&#x27;env://&#x27;</span>)       </span><br><span class="line">    <span class="comment"># create local model</span></span><br><span class="line">    model = nn.Linear(<span class="number">10</span>, <span class="number">10</span>).to(rank)</span><br><span class="line">    <span class="comment"># construct DDP model</span></span><br><span class="line">    ddp_model = DDP(model, device_ids=[rank])</span><br><span class="line">    <span class="comment"># define loss function and optimizer</span></span><br><span class="line">    loss_fn = nn.MSELoss()</span><br><span class="line">    optimizer = optim.SGD(ddp_model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    buf = <span class="number">0</span></span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        start = timer()</span><br><span class="line">        <span class="comment"># forward pass</span></span><br><span class="line">        outputs = ddp_model(torch.randn(<span class="number">20</span>, <span class="number">10</span>).to(rank))</span><br><span class="line">        end = timer()</span><br><span class="line"></span><br><span class="line">        tmp = end-start</span><br><span class="line">        buf+=tmp</span><br><span class="line">        labels = torch.randn(<span class="number">20</span>, <span class="number">10</span>).to(rank)</span><br><span class="line">        <span class="comment"># backward pass</span></span><br><span class="line">        loss_fn(outputs, labels).backward()</span><br><span class="line">        <span class="comment"># update parameters</span></span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="built_in">print</span>(tmp)</span><br><span class="line">    <span class="built_in">print</span>(buf)</span><br><span class="line">    <span class="built_in">print</span>(buf/<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    world_size = <span class="number">1</span></span><br><span class="line">    mp.spawn(example,</span><br><span class="line">        args=(world_size,),</span><br><span class="line">        nprocs=world_size,</span><br><span class="line">        join=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">     main()</span><br></pre></td></tr></table></figure><p>将 find_unused_params 分别设置成 True 或者 False 跑多次取平均，可以得到：</p><ul><li>find_unused_params=True: 0.3367 ms</li><li>find_unused_params=False: 0.2993 ms</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文介绍 PyTorch 里的数据并行训练，涉及 nn.DataParallel (DP) 和 nn.parallel.DistributedDataParallel (DDP) 两个模块（基于 1.7 版本），涵盖分布式训练的原理以及源码解读。&lt;/p&gt;</summary>
    
    
    
    <category term="PyTorch" scheme="http://example.com/categories/PyTorch/"/>
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="DDP" scheme="http://example.com/tags/DDP/"/>
    
    <category term="源码解读" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="分布式训练" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch中反卷积的理解</title>
    <link href="http://example.com/2021/05/12/PyTorch%E4%B8%AD%E5%8F%8D%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/05/12/PyTorch%E4%B8%AD%E5%8F%8D%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-05-12T14:24:41.000Z</published>
    <updated>2021-05-12T14:32:41.750Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍PyTorch中反卷积的参数意义</p><span id="more"></span><h3 id="卷积">卷积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">torch</span>.<span class="title">nn</span>.<span class="title">Conv2d</span>(<span class="params">in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, groups=<span class="number">1</span>, bias=<span class="literal">True</span></span>)</span></span><br></pre></td></tr></table></figure><p>蓝色为输入，蓝色上的阴影为卷积核(kernel)，绿色为输出，蓝色边缘的白色框为padding</p><p><img src="https://i.loli.net/2021/05/12/V1Z63CdmKkYBlMe.png" alt="20201008164239753.png"></p><h3 id="反卷积">反卷积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">torch</span>.<span class="title">nn</span>.<span class="title">ConvTranspose2d</span>(<span class="params">in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, output_padding=<span class="number">0</span>, bias=<span class="literal">True</span></span>)</span></span><br></pre></td></tr></table></figure><p>卷积和反卷积函数中的in_channels与out_channels以及kernel_size的含义相同。</p><p>需要注意的是padding和stride和conv2d不同，padding不是蓝色的留白,是kernel像图像中心移动的单位。如下当padding=0时，卷积核刚好和输入边缘相交一个单位。因此pandding可以理解为卷积核向中心移动的步数。 同时stride也不再是kernel移动的步数，变为输入单元彼此散开的步数。<br>即：<br><strong>padding=0时，卷积核的起始位置和输入层相交一个像素，当padding=1时，卷积核的起始位置和输入层相交2个像素，依此类推；<br>stride=1时，输入层元素之间没有间隔，当stride=2时，输入层元素之间间隔为1，stride=3时，输入层元素之间间隔为2，以此类推。</strong></p><p>示意图如下图所示：</p><p>padding=0,kernel_size=3,stride=1<br>output_padding是对反卷积后的特征图进行边缘填补0.<br>output_padding=0表示不进行填补，output_padding=1表示进行填补一圈0，等于2表示进行填补2圈0.</p><p><img src="https://i.loli.net/2021/05/12/uXN6tYkZJU4El7C.png" alt="20201008165335118.png"></p><p>padding=2,kernel_size=4,stride=1</p><p><img src="https://i.loli.net/2021/05/12/RX34ZnjP1lpxHBk.png" alt="20201008165432987.png"></p><p>padding=2,kernel_size=3,stride=1</p><p><img src="https://i.loli.net/2021/05/12/PdsEA1wf2QymZiR.png" alt="20201008165450382.png"></p><p>padding=0,kernel_size=3,stride=2</p><p><img src="https://i.loli.net/2021/05/12/3xfmNu8jWM59rOS.png" alt="20201008165511740.png"></p><p>padding=1,kernel_size=3,stride=2</p><p><img src="https://i.loli.net/2021/05/12/G32P46qh9LxRIan.png" alt="20201008165531435.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍PyTorch中反卷积的参数意义&lt;/p&gt;</summary>
    
    
    
    <category term="PyTorch" scheme="http://example.com/categories/PyTorch/"/>
    
    
    <category term="反卷积" scheme="http://example.com/tags/%E5%8F%8D%E5%8D%B7%E7%A7%AF/"/>
    
    <category term="转置卷积" scheme="http://example.com/tags/%E8%BD%AC%E7%BD%AE%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>搭建私有镜像仓库</title>
    <link href="http://example.com/2021/05/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    <id>http://example.com/2021/05/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</id>
    <published>2021-05-12T13:24:31.000Z</published>
    <updated>2021-05-12T14:19:54.770Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文主要介绍如何docker私有仓库，在公司中使用，避免商业项目暴露出去的风险。</p><span id="more"></span><h3 id="背景">背景</h3><p>在docker中，当我们执行docker pull xxx的时候，可能会比较好奇，docker会去哪查找并下载镜像呢？它实际上是从 <a href="http://registry.hub.docker.com">registry.hub.docker.com</a> 这个地址去查找，这就是Docker公司为我们提供的公共仓库，上面的镜像，大家都可以看到，也可以使用。所以，我们也可以带上仓库地址去拉取镜像，如：docker pull <a href="http://registry.hub.docker.com/library/alpine%EF%BC%8C">registry.hub.docker.com/library/alpine，</a> 不过要注意，这种方式下载的镜像的默认名称就会长一些。如果要在公司中使用Docker，我们基本不可能把商业项目上传到公共仓库中，那如果要多个机器共享，又能怎么办呢？</p><p>正因为这种需要，所以私有仓库也就有用武之地了。</p><p>所谓私有仓库，也就是在本地（局域网）搭建的一个类似公共仓库的东西，搭建好之后，我们可以将镜像提交到私有仓库中。这样我们既能使用 Docker 来运行我们的项目镜像，也避免了商业项目暴露出去的风险。</p><p>下面我们用官方提供的registry镜像来搭建私有镜像仓库，当然还有其它很多方法。</p><h3 id="环境">环境</h3><p>准备两台安装好docker的服务器：<br>服务端机器 （主机名为registry）：docker私有仓库服务器，运行registry容器；<br>测试端机器 （主机名为node）：普通的docker服务器，在这台服务器上下载一个测试镜像busybox，然后上传到registry服务器进行测试；</p><p>假设服务器ip（内网ip）是10.18.133.2</p><h3 id="部署（服务端操作）">部署（服务端操作）</h3><h4 id="下载镜像registry">下载镜像registry</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@registry ~]# docker pull registry</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">81033e7c1d6a: Pull complete </span><br><span class="line">b235084c2315: Pull complete </span><br><span class="line">c692f3a6894b: Pull complete </span><br><span class="line">ba2177f3a70e: Pull complete </span><br><span class="line">a8d793620947: Pull complete </span><br><span class="line">Digest: sha256:672d519d7fd7bbc7a448d17956ebeefe225d5eb27509d8dc5ce67ecb4a0bce54</span><br><span class="line">Status: Downloaded newer image for registry:latest</span><br></pre></td></tr></table></figure><h4 id="查看镜像是否pull下来了">查看镜像是否pull下来了</h4><p><img src="https://i.loli.net/2021/05/12/OteNH8Mgj1GlU7D.png" alt="180310200921851.png"></p><h4 id="运行registry容器">运行registry容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@registry ~]# docker run -itd -v /data/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest </span><br><span class="line">06a972de6218b1f1c3bf9b53eb9068dc66d147d14e18a89ab51db13e339d3dc9</span><br></pre></td></tr></table></figure><p>参数说明<br>-itd：在容器中打开一个伪终端进行交互操作，并在后台运行；<br>-v：把宿主机的/data/registry目录绑定 到 容器/var/lib/registry目录(这个目录是registry容器中存放镜像文件的目录)，来实现数据的持久化；<br>-p：映射端口；访问宿主机的5000端口就访问到registry容器的服务了；<br>–restart=always：这是重启的策略，假如这个容器异常退出会自动重启容器；<br>–name registry：创建容器命名为registry，你可以随便命名；<br>registry:latest：这个是刚才pull下来的镜像；</p><h4 id="测试镜像仓库中所有的镜像">测试镜像仓库中所有的镜像</h4><p>[root@registry ~]# curl <a href="http://10.18.133.2:5000/v2/_catalog">http://10.18.133.2:5000/v2/_catalog</a><br>{“repositories”:[]}</p><p>现在是空的，因为才刚运行，里面没有任何镜像内容。</p><h3 id="测试镜像仓库（测试端操作）">测试镜像仓库（测试端操作）</h3><h4 id="修改镜像源并重启docker服务">修改镜像源并重启docker服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [ &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]，</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;10.18.133.2:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node ~]# systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="从官方仓库下载busybox镜像">从官方仓库下载busybox镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# docker pull busybox</span><br><span class="line">[root@node ~]# docker images</span><br><span class="line">REPOSITORY          TAG                IMAGE ID            CREATED            SIZE</span><br><span class="line">busybox            latest              f6e427c148a7        36 hours ago        1.15MB</span><br></pre></td></tr></table></figure><h4 id="为镜像打标签">为镜像打标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# docker tag busybox:latest 10.18.133.2:5000/busybox:v1</span><br></pre></td></tr></table></figure><p>busybox:lastest 这是源镜像，也是刚才pull下来的镜像文件；<br>10.18.133.2:500/busybox:v1：这是目标镜像，也是registry私有镜像服务器的IP地址和端口；</p><p>查看一下打好的tag：</p><p><img src="https://i.loli.net/2021/05/12/Iba8UejM3LrqntV.png" alt="180310200921852.png"></p><h4 id="上传到私有镜像仓库">上传到私有镜像仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# docker push 10.18.133.2:5000/busybox:v1 </span><br><span class="line">The push refers to repository [10.18.133.2:5000/busybox]</span><br><span class="line">c5183829c43c: Pushed </span><br><span class="line">v1: digest: sha256:c7b0a24019b0e6eda714ec0fa137ad42bc44a754d9cea17d14fba3a80ccc1ee4 size: 527</span><br></pre></td></tr></table></figure><h4 id="测试下载镜像">测试下载镜像</h4><p>上传测试没问题了，我们接下来测试一下从registry服务器上下载刚才上传的busybox镜像，先删除node主机上的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# docker rmi f6e427c148a7</span><br></pre></td></tr></table></figure><p>(注意如果此处报错image is being used by stopped container，说明该镜像被某个容器使用，先删掉这个容器，docker ps -a查看使用这个镜像的容器，然后docker rm -f 容器id)</p><p>然后，从registry服务器上下载busybox镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# docker pull 10.18.133.2:5000&#x2F;busybox:v1</span><br><span class="line">v1: Pulling from busybox</span><br><span class="line">d070b8ef96fc: Pull complete </span><br><span class="line">Digest: sha256:c7b0a24019b0e6eda714ec0fa137ad42bc44a754d9cea17d14fba3a80ccc1ee4</span><br><span class="line">Status: Downloaded newer image for 10.18.133.2:5000&#x2F;busybox:v1</span><br><span class="line">[root@node ~]# docker images</span><br><span class="line">REPOSITORY                  TAG                IMAGE ID            CREATED            SIZE</span><br><span class="line">172.18.18.90:5000&#x2F;busybox  v1                  f6e427c148a7        36 hours ago        1.15MB</span><br></pre></td></tr></table></figure><p>列出所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# curl  http://10.18.133.2:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;busybox&quot;]&#125;</span><br></pre></td></tr></table></figure><p>列出busybox镜像有哪些tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]# curl  http://10.18.133.2:5000/v2/busybox/tags/list</span><br><span class="line">&#123;&quot;name&quot;:&quot;busybox&quot;,&quot;tags&quot;:[&quot;v1&quot;]&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文主要介绍如何docker私有仓库，在公司中使用，避免商业项目暴露出去的风险。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="私有镜像仓库" scheme="http://example.com/tags/%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>详解roi-pooling和roi-align</title>
    <link href="http://example.com/2021/05/12/%E8%AF%A6%E8%A7%A3roi-pooling%E5%92%8Croi-align/"/>
    <id>http://example.com/2021/05/12/%E8%AF%A6%E8%A7%A3roi-pooling%E5%92%8Croi-align/</id>
    <published>2021-05-12T13:12:53.000Z</published>
    <updated>2021-05-12T13:14:49.613Z</updated>
    
    <content type="html"><![CDATA[<p>引言：roi pooling和roi align是二阶段方法中常用的操作，本文总结二者的具体操作和不同。</p><span id="more"></span><h3 id="概述">概述</h3><p>这两个都是用在rpn之后的。具体来说，从feature map上经过RPN得到一系列的proposals，大概2k个，这些bbox大小不等，如何将这些bbox的特征进行统一表示就变成了一个问题。即需要找一个办法从大小不等的框中提取特征使输出结果是等长的。最开始目标检测模型Faster RCNN中用了一个简单粗暴的办法，叫ROI Pooling。该方式在语义分割这种精细程度高的任务中，不够精准，由此发展来了ROI Align。今天就总结下两者的思想。</p><h3 id="ROI-Pooling">ROI Pooling</h3><p><img src="https://i.loli.net/2021/04/29/NDle8s1MuZ3PLoy.jpg" alt="v2-d59199c554ac7ccfbd2038317aef74f2_720w.jpg"></p><p>假如现在有一个8x8的feature map，现在希望得到2x2的输出，有一个bbox坐标为[0,3,7,8]。这个bbox的w=7，h=5，如果要等分成四块是做不到的，因此在ROI Pooling中会进行取整。就有了上图看到的h被分割为2,3，w被分割成3,4。这样之后在每一块(称为bin)中做max pooling，可以得到下图的结果。</p><p><img src="https://i.loli.net/2021/04/29/4GFZSEMVO7Uq1ot.jpg" alt="v2-7b39628bb13db683b6de701f5b4169f8_720w.jpg"></p><p>这样就可以将任意大小bbox转成2x2表示的feature。ROI Pooling需要取整，这样的取整操作进行了两次，一次是得到bbox在feature map上的坐标时。例如：原图上的bbox大小为665x665，经backbone后，spatial scale=1/32。因此bbox也相应应该缩小为665/32=20.78，但是这并不是一个真实的pixel所在的位置，因此这一步会取为20。0.78的差距反馈到原图就是0.78x32=25个像素的差距。如果是大目标这25的差距可能看不出来，但对于小目标而言差距就比较巨大了。</p><p><img src="https://i.loli.net/2021/04/29/HoVqSw6Y1EvWysp.jpg" alt="v2-6f3dc5f450e6c936869595eaf66a0f4d_720w.jpg"></p><h3 id="ROI-Align">ROI Align</h3><p>因此有人提出不需要进行取整操作，如果计算得到小数，也就是没有落到真实的pixel上，那么就用最近的pixel对这一点虚拟pixel进行双线性插值，得到这个“pixel”的值。具体做法如下图所示：</p><p><img src="https://i.loli.net/2021/04/29/gQnhUMLuG3ZVr28.jpg" alt="v2-03d820b27ffca39854f0febf0ef9e37b_r.jpg"></p><ol><li>将bbox区域按输出要求的size进行等分，很可能等分后各顶点落不到真实的像素点上</li><li>没关系，在每个bin中再取固定的4个点(作者实验后发现取4效果较好)，也就是图二右侧的蓝色点</li><li>针对每一个蓝点，距离它最近的4个真实像素点的值加权(双线性插值)，求得这个蓝点的值</li><li>一个bin内会算出4个新值，在这些新值中取max，作为这个bin的输出值</li><li>最后就能得到2x2的输出</li></ol><blockquote><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/73138740">https://zhuanlan.zhihu.com/p/73138740</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：roi pooling和roi align是二阶段方法中常用的操作，本文总结二者的具体操作和不同。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="roi-pooling" scheme="http://example.com/tags/roi-pooling/"/>
    
    <category term="roi-align" scheme="http://example.com/tags/roi-align/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及实现：红黑树</title>
    <link href="http://example.com/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-04-27T15:39:20.000Z</published>
    <updated>2021-05-12T13:21:33.722Z</updated>
    
    <content type="html"><![CDATA[<p>引言：R-B Tree，又称为“红黑树”，本文的主要内容包括：红黑树的特性，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作。</p><span id="more"></span><h3 id="红黑树介绍">红黑树介绍</h3><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><p><strong>红黑树的特性</strong>:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><p><strong>注意</strong>：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p><p>红黑树示意图如下：</p><p><img src="https://i.loli.net/2021/04/27/bDfAtceGNF58kiV.jpg" alt="红黑树.jpg"></p><h3 id="红黑树的应用">红黑树的应用</h3><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。</p><p>例如，<strong>C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的</strong>。</p><h3 id="红黑树的时间复杂度和相关证明">红黑树的时间复杂度和相关证明</h3><p><strong>红黑树的时间复杂度为: O(lgn)</strong></p><p>下面通过“数学归纳法”对红黑树的时间复杂度进行证明。</p><p><strong>定理：一棵含有n个节点的红黑树的高度至多为2log(n+1)</strong>.</p><p>证明：<br>“一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的<strong>逆否命题</strong>是 “高度为h的红黑树，它的包含的内节点个数至少为 2<sup>h/2</sup>-1个”。</p><p>我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。</p><p>从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x’s black height)，记为<strong>bh(x)</strong>。关于bh(x)有两点需要说明：</p><p>第1点：根据红黑树的&quot;<strong>特性(5)</strong> ，即<em>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</em>&quot;可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。<strong>这也就意味着，bh(x)的值是唯一的</strong>！<br>第2点：根据红黑色的&quot;特性(4)，即<em>如果一个节点是红色的，则它的子节点必须是黑色的</em>&quot;可知，从节点x出发达到叶节点&quot;所经历的黑节点数目&quot;&gt;= “所经历的红节点的数目”。假设x是根节点，则可以得出结论&quot;<strong>bh(x) &gt;= h/2</strong>&quot;。进而，我们只需证明 &quot;高度为h的红黑树，它的包含的黑节点个数至少为 2<sup>bh(x)</sup>-1个&quot;即可。</p><p>到这里，我们将需要证明的定理已经由**&quot;一棵含有n个节点的红黑树的高度至多为2log(n+1)“<strong>转变成只需要证明</strong>&quot;高度为h的红黑树，它的包含的内节点个数至少为 2<sup>bh(x)</sup>-1个”。**</p><p>下面通过&quot;数学归纳法&quot;开始论证高度为h的红黑树，它的包含的内节点个数至少为 2<sup>bh(x)</sup>-1个&quot;。</p><p>(01) 当树的高度h=0时，<br>内节点个数是0，bh(x) 为0，2<sup>bh(x)</sup>-1 也为 0。显然，原命题成立。</p><p>(02) 当h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2<sup>bh(x)</sup>-1-1。这个是根据(01)推断出来的！</p><p>下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2<sup>bh(x)</sup>-1”。</p><p>当树的高度为 h 时，<br>对于节点x(x为根节点)，其黑高度为bh(x)。<br>对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br>根据(02)的已知条件，我们已知 “x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2<sup>bh(x)</sup>-1-1 个”；</p><p>所以，节点x所包含的节点至少为 ( 2<sup>bh(x)</sup>-1-1 ) + ( 2<sup>bh(x)</sup>-1-1 ) + 1 = 2<sup>bh(x)</sup>-1。即节点x所包含的节点至少为 2<sup>bh(x)</sup>-1。<br>因此，原命题成立。</p><p>由(01)、(02)得出，“高度为h的红黑树，它的包含的内节点个数至少为 2<sup>bh(x)</sup>-1个”。<br>因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。</p><h3 id="红黑树的基本操作-一-左旋和右旋">红黑树的基本操作(一) 左旋和右旋</h3><p>红黑树的基本操作是<strong>添加</strong>、<strong>删除</strong>。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。<br>旋转包括两种：<strong>左旋</strong> 和 <strong>右旋</strong>。下面分别对它们进行介绍。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：R-B Tree，又称为“红黑树”，本文的主要内容包括：红黑树的特性，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>理解C++中的左值和右值</title>
    <link href="http://example.com/2021/04/26/%E7%90%86%E8%A7%A3C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <id>http://example.com/2021/04/26/%E7%90%86%E8%A7%A3C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</id>
    <published>2021-04-25T17:29:29.000Z</published>
    <updated>2021-04-26T15:51:15.048Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构及实现：伸展树</title>
    <link href="http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BC%B8%E5%B1%95%E6%A0%91/"/>
    <id>http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BC%B8%E5%B1%95%E6%A0%91/</id>
    <published>2021-04-25T16:41:51.000Z</published>
    <updated>2021-04-25T17:14:29.835Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本文介绍伸展树。它和&quot;二叉查找树&quot;和&quot;AVL树&quot;一样，都是特殊的二叉树，本文会先对伸展树的理论知识进行简单介绍，然后给出C++的实现。</p><span id="more"></span><h3 id="伸展树介绍">伸展树介绍</h3><p>伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。</p><p>（1）伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。<br>（2）除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。</p><p>假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</p><p>相比于&quot;二叉查找树&quot;和&quot;AVL树&quot;，学习伸展树时需要重点关注<strong>伸展树的旋转算法</strong>。</p><h3 id="伸展树的C-实现">伸展树的C++实现</h3><h4 id="基本定义">基本定义</h4><h5 id="节点">节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">    SplayTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">    SplayTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SplayTreeNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SplayTreeNode</span>(T value, SplayTreeNode *l, SplayTreeNode *r):</span><br><span class="line">    <span class="built_in">key</span>(value), <span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SplayTreeNode是伸展树节点对应的类。它包括的几个组成元素:<br>（1）key – 是关键字，是用来对伸展树的节点进行排序的。<br>（2） left – 是左孩子。<br>（3） right – 是右孩子。</p><h5 id="伸展树">伸展树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SplayTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SplayTree</span>();</span><br><span class="line">        ~<span class="built_in">SplayTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到伸展树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的伸展树的最小结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的伸展树的最大结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">splay</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到伸展树(tree)中</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除伸展树(tree)中的结点(键值为key)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SplayTree是伸展树对应的类。它包括根节点mRoot和伸展树的函数接口。</p><h4 id="旋转">旋转</h4><p>旋转是伸展树中需要重点关注的，它的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *   (a)：伸展树中存在&quot;键值为key的节点&quot;。</span></span><br><span class="line"><span class="comment"> *          将&quot;键值为key的节点&quot;旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (b)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &lt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      b-1 &quot;键值为key的节点&quot;的前驱节点存在的话，将&quot;键值为key的节点&quot;的前驱节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      b-2 &quot;键值为key的节点&quot;的前驱节点不存在的话，则意味着，key比树中任何键值都小，那么此时，将最小节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (c)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &gt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      c-1 &quot;键值为key的节点&quot;的后继节点存在的话，将&quot;键值为key的节点&quot;的后继节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      c-2 &quot;键值为key的节点&quot;的后继节点不存在的话，则意味着，key比树中任何键值都大，那么此时，将最大节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">splay</span>(SplayTreeNode&lt;T&gt;* tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; N, *l, *r, *c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    N.left = N.right = <span class="literal">NULL</span>;</span><br><span class="line">    l = r = &amp;N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;left;                           <span class="comment">/* rotate right */</span></span><br><span class="line">                tree-&gt;left = c-&gt;right;</span><br><span class="line">                c-&gt;right = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r-&gt;left = tree;                               <span class="comment">/* link right */</span></span><br><span class="line">            r = tree;</span><br><span class="line">            tree = tree-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key) </span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;right;                          <span class="comment">/* rotate left */</span></span><br><span class="line">                tree-&gt;right = c-&gt;left;</span><br><span class="line">                c-&gt;left = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l-&gt;right = tree;                              <span class="comment">/* link left */</span></span><br><span class="line">            l = tree;</span><br><span class="line">            tree = tree-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l-&gt;right = tree-&gt;left;                                <span class="comment">/* assemble */</span></span><br><span class="line">    r-&gt;left = tree-&gt;right;</span><br><span class="line">    tree-&gt;left = N.right;</span><br><span class="line">    tree-&gt;right = N.left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">splay</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的作用：将&quot;键值为key的节点&quot;旋转为根节点，并返回根节点。它的处理情况共包括：<br><strong>(a)：伸展树中存在&quot;键值为key的节点&quot;。</strong><br>将&quot;键值为key的节点&quot;旋转为根节点。<br><strong>(b)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &lt; tree-&gt;key。</strong><br>b-1) &quot;键值为key的节点&quot;的前驱节点存在的话，将&quot;键值为key的节点&quot;的前驱节点旋转为根节点。<br>b-2) &quot;键值为key的节点&quot;的前驱节点存在的话，则意味着，key比树中任何键值都小，那么此时，将最小节点旋转为根节点。<br><strong>©：伸展树中不存在&quot;键值为key的节点&quot;，并且key &gt; tree-&gt;key。</strong><br>c-1) &quot;键值为key的节点&quot;的后继节点存在的话，将&quot;键值为key的节点&quot;的后继节点旋转为根节点。<br>c-2) &quot;键值为key的节点&quot;的后继节点不存在的话，则意味着，key比树中任何键值都大，那么此时，将最大节点旋转为根节点。</p><p>下面列举个例子分别对a进行说明。</p><p>在下面的伸展树中查找10，共包括&quot;右旋&quot; --&gt; “右链接” --&gt; &quot;组合&quot;这3步。</p><p><img src="https://i.loli.net/2021/04/26/2hazYbWXuyRdmT8.jpg" alt="伸展树.jpg"></p><p><strong>(01) 右旋</strong></p><p>对应代码中的&quot;rotate right&quot;部分</p><p><img src="https://i.loli.net/2021/04/26/ea31Pl8EznhptM5.jpg" alt="伸展树右旋.jpg"></p><p><strong>(02) 右链接</strong></p><p>对应代码中的&quot;link right&quot;部分</p><p><img src="https://i.loli.net/2021/04/26/KI3WvJmXhHCTw8L.jpg" alt="伸展树右链接.jpg"></p><p><strong>(03) 组合</strong></p><p>对应代码中的&quot;assemble&quot;部分</p><p><img src="https://i.loli.net/2021/04/26/dv5ajrPlI87bCM6.jpg" alt="伸展树组合.jpg"></p><p>提示：如果在上面的伸展树中查找&quot;70&quot;，则正好与&quot;示例1&quot;对称，而对应的操作则分别是&quot;rotate left&quot;, “link left&quot;和&quot;assemble”。<br>其它的情况，例如&quot;查找15是b-1的情况，查找5是b-2的情况&quot;等等，这些都比较简单，大家可以自己分析。</p><h4 id="插入">插入</h4><p>插入代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到伸展树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">insert</span>(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z) &#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key)</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不允许插入相同节点(&quot;</span> &lt;&lt; z-&gt;key &lt;&lt; <span class="string">&quot;)!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> z;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> SplayTreeNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    mRoot = <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">    <span class="comment">// 将节点(key)旋转为根节点</span></span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert(key)是提供给外部的接口，它的作用是新建节点(节点的键值为key)，并将节点插入到伸展树中；然后，将该节点旋转为根节点。<br>insert(tree, z)是内部接口，它的作用是将节点z插入到tree中。insert(tree, z)在将z插入到tree中时，仅仅只将tree当作是一棵二叉查找树，而且不允许插入相同节点。</p><h4 id="删除">删除</h4><p>删除代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(节点的键值为key)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 待删除结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">remove</span>(SplayTreeNode&lt;T&gt;* &amp;tree, T key) &#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键值为key的节点，找不到的话直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">search</span>(tree, key) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将key对应的节点旋转为根节点。</span></span><br><span class="line">    tree = <span class="built_in">splay</span>(tree, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将&quot;tree的前驱节点&quot;旋转为根节点</span></span><br><span class="line">        x = <span class="built_in">splay</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 移除tree节点</span></span><br><span class="line">        x-&gt;right = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = tree-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">remove</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove(key)是外部接口，remove(tree, key)是内部接口。<br>remove(tree, key)的作用是：删除伸展树中键值为key的节点。<br>它会先在伸展树中查找键值为key的节点。若没有找到的话，则直接返回。若找到的话，则将该节点旋转为根节点，然后再删除该节点。</p><p><strong>注意</strong>：关于伸展树的&quot;前序遍历&quot;、“中序遍历”、“后序遍历”、“最大值”、“最小值”、“查找”、“打印”、&quot;销毁&quot;等接口与&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;基本一样，这些操作在&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;中已经介绍过了，这里就不再单独介绍了。当然，后文给出的伸展树的完整源码中，有给出这些API的实现代码。</p><h3 id="伸展树的C-实现（完整源码）">伸展树的C++实现（完整源码）</h3><p>伸展树的实现文件(SplayTree.h)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SPLAY_TREE_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SPLAY_TREE_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        SplayTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">        SplayTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">SplayTreeNode</span>():<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SplayTreeNode</span>(T value, SplayTreeNode *l, SplayTreeNode *r):</span><br><span class="line">            <span class="built_in">key</span>(value), <span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SplayTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SplayTree</span>();</span><br><span class="line">        ~<span class="built_in">SplayTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到伸展树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;伸展树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(SplayTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的伸展树的最小结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的伸展树的最大结点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(SplayTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">splay</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到伸展树(tree)中</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除伸展树(tree)中的结点(键值为key)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">SplayTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(SplayTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印伸展树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(SplayTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTree&lt;T&gt;::<span class="built_in">SplayTree</span>():<span class="built_in">mRoot</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTree&lt;T&gt;::~<span class="built_in">SplayTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">preOrder</span>(SplayTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">preOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">inOrder</span>(SplayTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">inOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">postOrder</span>(SplayTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">postOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">search</span>(SplayTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">search</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找&quot;伸展树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(SplayTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小结点：返回tree为根结点的伸展树的最小结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">minimum</span>(SplayTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T SplayTree&lt;T&gt;::<span class="built_in">minimum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大结点：返回tree为根结点的伸展树的最大结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">maximum</span>(SplayTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T SplayTree&lt;T&gt;::<span class="built_in">maximum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 旋转key对应的节点为根节点，并返回值为根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *   (a)：伸展树中存在&quot;键值为key的节点&quot;。</span></span><br><span class="line"><span class="comment"> *          将&quot;键值为key的节点&quot;旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (b)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &lt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      b-1 &quot;键值为key的节点&quot;的前驱节点存在的话，将&quot;键值为key的节点&quot;的前驱节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      b-2 &quot;键值为key的节点&quot;的前驱节点存在的话，则意味着，key比树中任何键值都小，那么此时，将最小节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *   (c)：伸展树中不存在&quot;键值为key的节点&quot;，并且key &gt; tree-&gt;key。</span></span><br><span class="line"><span class="comment"> *      c-1 &quot;键值为key的节点&quot;的后继节点存在的话，将&quot;键值为key的节点&quot;的后继节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> *      c-2 &quot;键值为key的节点&quot;的后继节点不存在的话，则意味着，key比树中任何键值都大，那么此时，将最大节点旋转为根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">splay</span>(SplayTreeNode&lt;T&gt;* tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; N, *l, *r, *c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    N.left = N.right = <span class="literal">NULL</span>;</span><br><span class="line">    l = r = &amp;N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;left;                           <span class="comment">/* rotate right */</span></span><br><span class="line">                tree-&gt;left = c-&gt;right;</span><br><span class="line">                c-&gt;right = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r-&gt;left = tree;                               <span class="comment">/* link right */</span></span><br><span class="line">            r = tree;</span><br><span class="line">            tree = tree-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                c = tree-&gt;right;                          <span class="comment">/* rotate left */</span></span><br><span class="line">                tree-&gt;right = c-&gt;left;</span><br><span class="line">                c-&gt;left = tree;</span><br><span class="line">                tree = c;</span><br><span class="line">                <span class="keyword">if</span> (tree-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l-&gt;right = tree;                              <span class="comment">/* link left */</span></span><br><span class="line">            l = tree;</span><br><span class="line">            tree = tree-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l-&gt;right = tree-&gt;left;                                <span class="comment">/* assemble */</span></span><br><span class="line">    r-&gt;left = tree-&gt;right;</span><br><span class="line">    tree-&gt;left = N.right;</span><br><span class="line">    tree-&gt;right = N.left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">splay</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点插入到伸展树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">insert</span>(SplayTreeNode&lt;T&gt;* &amp;tree, SplayTreeNode&lt;T&gt;* z)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key)</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不允许插入相同节点(&quot;</span> &lt;&lt; z-&gt;key &lt;&lt; <span class="string">&quot;)!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> z;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> SplayTreeNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    mRoot = <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">    <span class="comment">// 将节点(key)旋转为根节点</span></span><br><span class="line">    mRoot = <span class="built_in">splay</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(节点的键值为key)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 伸展树的根结点</span></span><br><span class="line"><span class="comment"> *     key 待删除结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::<span class="built_in">remove</span>(SplayTreeNode&lt;T&gt;* &amp;tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    SplayTreeNode&lt;T&gt; *x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键值为key的节点，找不到的话直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">search</span>(tree, key) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将key对应的节点旋转为根节点。</span></span><br><span class="line">    tree = <span class="built_in">splay</span>(tree, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将&quot;tree的前驱节点&quot;旋转为根节点</span></span><br><span class="line">        x = <span class="built_in">splay</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 移除tree节点</span></span><br><span class="line">        x-&gt;right = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = tree-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    mRoot = <span class="built_in">remove</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁伸展树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">destroy</span>(SplayTreeNode&lt;T&gt;* &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">destroy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;伸展树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值</span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">print</span>(SplayTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>关于&quot;队列的声明和实现都在头文件中&quot;的原因，是因为队列的实现利用了C++模板，而&quot;C++编译器不能支持对模板的分离式编译&quot;！</p><h3 id="伸展树的C-测试程序">伸展树的C++测试程序</h3><p>伸展树的测试程序(SplayTreeTest.cpp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 伸展树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2014/02/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SplayTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]= &#123;<span class="number">10</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,ilen;</span><br><span class="line">    SplayTree&lt;<span class="keyword">int</span>&gt;* tree=<span class="keyword">new</span> SplayTree&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 依次添加: &quot;</span>;</span><br><span class="line">    ilen = <span class="built_in">TBL_SIZE</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree-&gt;<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 前序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">preOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 后序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最小值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">minimum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最大值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">maximum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 旋转节点(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;)为根节点&quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">splay</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    tree-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伸展树的测试程序运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">== 依次添加: 10 50 40 30 20 60 </span><br><span class="line">== 前序遍历: 60 30 20 10 50 40 </span><br><span class="line">== 中序遍历: 10 20 30 40 50 60 </span><br><span class="line">== 后序遍历: 10 20 40 50 30 60 </span><br><span class="line">== 最小值: 10</span><br><span class="line">== 最大值: 60</span><br><span class="line">== 树的详细信息: </span><br><span class="line">60 is root</span><br><span class="line">30 is 60&#x27;s   left child</span><br><span class="line">20 is 30&#x27;s   left child</span><br><span class="line">10 is 20&#x27;s   left child</span><br><span class="line">50 is 30&#x27;s  right child</span><br><span class="line">40 is 50&#x27;s   left child</span><br><span class="line"></span><br><span class="line">== 旋转节点(30)为根节点</span><br><span class="line">== 树的详细信息: </span><br><span class="line">30 is root</span><br><span class="line">20 is 30&#x27;s   left child</span><br><span class="line">10 is 20&#x27;s   left child</span><br><span class="line">60 is 30&#x27;s  right child</span><br><span class="line">50 is 60&#x27;s   left child</span><br><span class="line">40 is 50&#x27;s   left child</span><br></pre></td></tr></table></figure><p>测试程序的主要流程是：新建伸展树，然后向伸展树中依次插入10,50,40,30,20,60。插入完毕这些数据之后，伸展树的节点是60；此时，再旋转节点，使得30成为根节点。<br>依次插入10,50,40,30,20,60示意图如下：</p><p><img src="https://i.loli.net/2021/04/26/f4nuZUd3ToD1sBC.jpg" alt="伸展树插入.jpg"></p><p>将30旋转为根节点的示意图如下：</p><p><img src="https://i.loli.net/2021/04/26/D2WF7e1A3qjmzU6.jpg" alt="伸展树旋转.jpg"></p><h3 id="总结">总结</h3><p>伸展树的C++实现代码，并进行了测试。</p><blockquote><p>本文转载自：<a href="http://www.cnblogs.com/skywang12345/p/3604258.html">http://www.cnblogs.com/skywang12345/p/3604258.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本文介绍伸展树。它和&amp;quot;二叉查找树&amp;quot;和&amp;quot;AVL树&amp;quot;一样，都是特殊的二叉树，本文会先对伸展树的理论知识进行简单介绍，然后给出C++的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="伸展树" scheme="http://example.com/tags/%E4%BC%B8%E5%B1%95%E6%A0%91/"/>
    
    <category term="伸展树旋转" scheme="http://example.com/tags/%E4%BC%B8%E5%B1%95%E6%A0%91%E6%97%8B%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch源码解读之torch.autograd：梯度计算详解</title>
    <link href="http://example.com/2021/04/24/PyTorch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Btorch-autograd%EF%BC%9A%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/04/24/PyTorch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Btorch-autograd%EF%BC%9A%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-24T14:09:20.000Z</published>
    <updated>2021-04-24T14:24:58.195Z</updated>
    
    <content type="html"><![CDATA[<p>引言：本篇笔记以介绍 pytorch 中的 autograd 模块功能为主，主要涉及 torch/autograd 下代码，不涉及底层的 C++ 实现。</p><span id="more"></span><ul><li>torch.autograd.function （函数的反向传播）</li><li>torch.autograd.functional （计算图的反向传播）</li><li>torch.autograd.gradcheck （数值梯度检查）</li><li>torch.autograd.anomaly_mode （在自动求导时检测错误产生路径）</li><li>torch.autograd.grad_mode （设置是否需要梯度）</li><li>model.eval() 与 torch.no_grad()</li><li>torch.autograd.profiler （提供 function 级别的统计信息）</li></ul><h3 id="torch-autograd-function（函数的反向传播）">torch.autograd.function（函数的反向传播）</h3><p>我们在构建网络的时候，通常使用 pytorch 所提供的<code>nn.Module</code> （例如<code>nn.Conv2d</code>, <code>nn.ReLU</code>等）作为基本单元。而这些 Module 通常是包裹 autograd function，以其作为真正实现的部分。例如<code>nn.ReLU</code> 实际使用<code>torch.nn.functional.relu</code>（<code>F.relu</code>）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReLU</span>(<span class="params">Module</span>):</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;inplace&#x27;</span>]</span><br><span class="line">    inplace: <span class="built_in">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inplace: <span class="built_in">bool</span> = <span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ReLU, self).__init()__()</span><br><span class="line">        self.inplace = inplace</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span>: Tensor</span>) -&gt; Tensor:</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(<span class="built_in">input</span>, inplace=self.inplace)</span><br></pre></td></tr></table></figure><p>这里的<code>F.relu</code>类型为<code>function</code>，若再剥开一层，其实际包裹的函数类型为<code>builtin_function_or_method</code>，这也是真正完成运算的部分。这些部分通常使用 C++ 实现（如<code>ATen</code>）。至此我们知道，一个模型的运算部分由 autograd functions 组成，这些 autograd functions 内部定义了 forward，backward 用以描述前向和梯度反传的过程，组合后可以实现整个模型的前向和梯度反传。以<code>torch.autograd.function</code>中所定义的<code>Function</code>类为基类，我们可以实现自定义的autograd function，所实现的 function 需包含<code>forward</code>及<code>backward</code>两个方法。以下以<code>Exp</code>和<code>GradCoeff</code>两个自定义 autograd function 为例进行讲解：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：本篇笔记以介绍 pytorch 中的 autograd 模块功能为主，主要涉及 torch/autograd 下代码，不涉及底层的 C++ 实现。&lt;/p&gt;</summary>
    
    
    
    <category term="PyTorch" scheme="http://example.com/categories/PyTorch/"/>
    
    
    <category term="torch.autograd" scheme="http://example.com/tags/torch-autograd/"/>
    
    <category term="梯度" scheme="http://example.com/tags/%E6%A2%AF%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及实现：AVL树</title>
    <link href="http://example.com/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9AAVL%E6%A0%91/"/>
    <id>http://example.com/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9AAVL%E6%A0%91/</id>
    <published>2021-04-24T06:21:51.000Z</published>
    <updated>2021-04-24T13:19:19.740Z</updated>
    
    <content type="html"><![CDATA[<p>引言：对AVL树的理论知识进行简单介绍，给出C++实现，并对实现代码进行了测试。</p><span id="more"></span><h3 id="AVL树简介">AVL树简介</h3><p>AVL树是根据它的发明者G.M. <strong>A</strong>delson-<strong>V</strong>elsky和E.M. <strong>L</strong>andis命名的。它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于&quot;二叉查找树&quot;，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。</p><p><img src="https://i.loli.net/2021/04/24/3H6BGNtnWRrJqhm.jpg" alt="AVL树和非AVL.jpg"></p><p>上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都&lt;=1；而右边的不是AVL树，因为7的两颗子树的高度相差为2(以2为根节点的树的高度是3，而以8为根节点的树的高度是1)。</p><p>AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理。学AVL树，重点的地方也就是它的<strong>旋转算法</strong>；在下文的介绍中，来对它进行详细介绍。</p><h3 id="AVL树的C-实现">AVL树的C++实现</h3><h4 id="节点">节点</h4><h5 id="AVL树节点">AVL树节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="keyword">int</span> height;         <span class="comment">// 高度</span></span><br><span class="line">    AVLTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">    AVLTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVLTreeNode</span>(T value, AVLTreeNode *l, AVLTreeNode *r):</span><br><span class="line">    <span class="built_in">key</span>(value), <span class="built_in">height</span>(<span class="number">0</span>),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AVLTreeNode是AVL树的节点类，它包括的几个组成对象:<br>（1） key – 是关键字，是用来对AVL树的节点进行排序的。<br>（2） left – 是左孩子。<br>（3） right – 是右孩子。<br>（4） height – 是高度。</p><h5 id="AVL树">AVL树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AVLTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLTree</span>();</span><br><span class="line">    ~<span class="built_in">AVLTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">    <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">    <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(key为节点键值)插入到AVL树中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 获取树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL：左左对应的情况(左单旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR：右右对应的情况(右单旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR：左右对应的情况(左双旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL：右左对应的情况(右双旋转)。</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(z)插入到AVL树(tree)中</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除AVL树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">    <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印AVL树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AVLTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AVLTree是AVL树对应的类。它包含AVL树的根节点mRoot和AVL树的基本操作接口。需要说明的是：AVLTree中重载了许多函数。重载的目的是区分内部接口和外部接口，例如insert()函数而言，insert(tree, key)是内部接口，而insert(key)是外部接口。</p><h5 id="树的高度">树的高度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取树的高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>(AVLTreeNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于高度，有的地方将&quot;空二叉树的高度是-1&quot;，而本文采用<a href="http://zh.wikipedia.org/zh-cn/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">维基百科</a>上的定义：树的高度为最大层次。即空的二叉树的高度是0，非空树的高度等于它的最大层次(根的层次为1，根的子节点为第2层，依次类推)。</p><h5 id="比较大小">比较大小</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 比较两个值的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">max</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="旋转">旋转</h4><p>如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。这种失去平衡的可以概括为4种姿态：LL(左左)，LR(左右)，RR(右右)和RL(右左)。下面给出它们的示意图：</p><p><img src="https://i.loli.net/2021/04/24/lHQVfiFGx97Ipo6.jpg" alt="AVL树旋转.jpg"></p><p>上图中的4棵树都是&quot;失去平衡的AVL树&quot;，从左往右的情况依次是：LL、LR、RL、RR。除了上面的情况之外，还有其它的失去平衡的AVL树，如下图：</p><p><img src="https://i.loli.net/2021/04/24/19mD7jypfn85HYc.jpg" alt="AVL树旋转2.jpg"></p><p>上面的两张图都是为了便于理解，而列举的关于&quot;失去平衡的AVL树&quot;的例子。总的来说，AVL树失去平衡时的情况一定是LL、LR、RL、RR这4种之一，它们都由各自的定义：</p><p>（1）<strong>LL</strong>：LeftLeft，也称为&quot;左左&quot;。插入或删除一个节点后，根节点的左子树的左子树还有非空子节点，导致&quot;根的左子树的高度&quot;比&quot;根的右子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面LL情况中，由于&quot;根节点(8)的左子树(4)的左子树(2)还有非空子节点&quot;，而&quot;根节点(8)的右子树(12)没有子节点&quot;；导致&quot;根节点(8)的左子树(4)高度&quot;比&quot;根节点(8)的右子树(12)&quot;高2。</p><p>（2）<strong>LR</strong>：LeftRight，也称为&quot;左右&quot;。插入或删除一个节点后，根节点的左子树的右子树还有非空子节点，导致&quot;根的左子树的高度&quot;比&quot;根的右子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面LR情况中，由于&quot;根节点(8)的左子树(4)的左子树(6)还有非空子节点&quot;，而&quot;根节点(8)的右子树(12)没有子节点&quot;；导致&quot;根节点(8)的左子树(4)高度&quot;比&quot;根节点(8)的右子树(12)&quot;高2。</p><p>（3）<strong>RL</strong>：RightLeft，称为&quot;右左&quot;。插入或删除一个节点后，根节点的右子树的左子树还有非空子节点，导致&quot;根的右子树的高度&quot;比&quot;根的左子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面RL情况中，由于&quot;根节点(8)的右子树(12)的左子树(10)还有非空子节点&quot;，而&quot;根节点(8)的左子树(4)没有子节点&quot;；导致&quot;根节点(8)的右子树(12)高度&quot;比&quot;根节点(8)的左子树(4)&quot;高2。</p><p>（4）<strong>RR</strong>：RightRight，称为&quot;右右&quot;。插入或删除一个节点后，根节点的右子树的右子树还有非空子节点，导致&quot;根的右子树的高度&quot;比&quot;根的左子树的高度&quot;大2，导致AVL树失去了平衡。例如，在上面RR情况中，由于&quot;根节点(8)的右子树(12)的右子树(14)还有非空子节点&quot;，而&quot;根节点(8)的左子树(4)没有子节点&quot;；导致&quot;根节点(8)的右子树(12)高度&quot;比&quot;根节点(8)的左子树(4)&quot;高2。</p><p>前面说过，如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。AVL失去平衡之后，可以通过旋转使其恢复平衡，下面分别介绍&quot;LL(左左)，LR(左右)，RR(右右)和RL(右左)&quot;这4种情况对应的旋转方法。</p><h5 id="LL的旋转">LL的旋转</h5><p>LL失去平衡的情况，可以通过一次旋转让AVL树恢复平衡。如下图：</p><p><img src="https://i.loli.net/2021/04/24/WOTV612YwnvicGX.jpg" alt="LL旋转.jpg"></p><p>图中左边是旋转之前的树，右边是旋转之后的树。从中可以发现，旋转之后的树又变成了AVL树，而且该旋转只需要一次即可完成。对于LL旋转，你可以这样理解为：LL旋转是围绕&quot;失去平衡的AVL根节点&quot;进行的，也就是节点k2；而且由于是LL情况，即左左情况，就用手抓着&quot;左孩子，即k1&quot;使劲摇。将k1变成根节点，k2变成k1的右子树，“k1的右子树&quot;变成&quot;k2的左子树”。</p><p>LL的旋转代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LL：左左对应的情况(左单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftLeftRotation</span>(AVLTreeNode&lt;T&gt;* k2) &#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k1;</span><br><span class="line"></span><br><span class="line">    k1 = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), k2-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RR的旋转">RR的旋转</h5><p>理解了LL之后，RR就相当容易理解了。RR是与LL对称的情况！RR恢复平衡的旋转方法如下：</p><p><img src="https://i.loli.net/2021/04/24/sjUJzw1ieL7OYSo.jpg" alt="RR旋转.jpg"></p><p>图中左边是旋转之前的树，右边是旋转之后的树。RR旋转也只需要一次即可完成。</p><p>RR的旋转代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RR：右右对应的情况(右单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightRightRotation</span>(AVLTreeNode&lt;T&gt;* k1) &#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k2;</span><br><span class="line"></span><br><span class="line">    k2 = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1;</span><br><span class="line"></span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;right), k1-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LR的旋转">LR的旋转</h5><p>LR失去平衡的情况，需要经过两次旋转才能让AVL树恢复平衡。如下图：</p><p><img src="https://i.loli.net/2021/04/24/V6OaYJpzRbCTdvn.jpg" alt="LR旋转.jpg"></p><p>第一次旋转是围绕&quot;k1&quot;进行的&quot;RR旋转&quot;，第二次是围绕&quot;k3&quot;进行的&quot;LL旋转&quot;。</p><p>LR的旋转代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LR：左右对应的情况(左双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftRightRotation</span>(AVLTreeNode&lt;T&gt;* k3) &#123;</span><br><span class="line">    k3-&gt;left = <span class="built_in">rightRightRotation</span>(k3-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">leftLeftRotation</span>(k3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RL的旋转">RL的旋转</h5><p>RL是与LR的对称情况！RL恢复平衡的旋转方法如下：</p><p><img src="https://i.loli.net/2021/04/24/6ExdKpOLtgzm7bY.jpg" alt="RL旋转.jpg"></p><p>第一次旋转是围绕&quot;k3&quot;进行的&quot;LL旋转&quot;，第二次是围绕&quot;k1&quot;进行的&quot;RR旋转&quot;。</p><p>RL的旋转代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RL：右左对应的情况(右双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightLeftRotation</span>(AVLTreeNode&lt;T&gt;* k1) &#123;</span><br><span class="line">    k1-&gt;right = <span class="built_in">leftLeftRotation</span>(k1-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rightRightRotation</span>(k1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入">插入</h4><p>插入节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">insert</span>(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新建节点</span></span><br><span class="line">        tree = <span class="keyword">new</span> AVLTreeNode&lt;T&gt;(key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR: create avltree node failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的左子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">insert</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的右子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">insert</span>(tree-&gt;right, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key)</span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//key == tree-&gt;key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;添加失败：不允许添加相同的节点！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(tree-&gt;left), <span class="built_in">height</span>(tree-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">insert</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">insert</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><p>删除节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     z 待删除的结点</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">remove</span>(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z) &#123;</span><br><span class="line">    <span class="comment">// 根为空 或者 没有要删除的节点，直接返回NULL。</span></span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span> || z==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z-&gt;key &lt; tree-&gt;key)        <span class="comment">// 待删除的节点在&quot;tree的左子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *r =  tree-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(r-&gt;left) &gt; <span class="built_in">height</span>(r-&gt;right))</span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; tree-&gt;key)<span class="comment">// 待删除的节点在&quot;tree的右子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *l =  tree-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(l-&gt;right) &gt; <span class="built_in">height</span>(l-&gt;left))</span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// tree是对应要删除的节点。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// tree的左右孩子都非空</span></span><br><span class="line">        <span class="keyword">if</span> ((tree-&gt;left!=<span class="literal">NULL</span>) &amp;&amp; (tree-&gt;right!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) &gt; <span class="built_in">height</span>(tree-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树比右子树高；</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的左子树中的最大节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最大节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最大节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的左子树中最大节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的左子树中最大节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* max = <span class="built_in">maximum</span>(tree-&gt;left);</span><br><span class="line">                tree-&gt;key = max-&gt;key;</span><br><span class="line">                tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的右子树中的最小节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最小节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最小节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的右子树中最小节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的右子树中最小节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* min = <span class="built_in">maximum</span>(tree-&gt;right);</span><br><span class="line">                tree-&gt;key = min-&gt;key;</span><br><span class="line">                tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt;* tmp = tree;</span><br><span class="line">            tree = (tree-&gt;left!=<span class="literal">NULL</span>) ? tree-&gt;left : tree-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">remove</span>(T key) &#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* z; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        mRoot = <span class="built_in">remove</span>(mRoot, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：关于AVL树的&quot;前序遍历&quot;、“中序遍历”、“后序遍历”、“最大值”、“最小值”、“查找”、“打印”、&quot;销毁&quot;等接口与&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;基本一样，这些操作在&quot;<a href="http://zsh4614.cn/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/">二叉查找树</a>&quot;中已经介绍过了，这里就不再单独介绍了。当然，后文给出的AVL树的完整源码中，有给出这些API的实现代码。</p><h3 id="AVL树的C-实现（完整源码）">AVL树的C++实现（完整源码）</h3><p>AVL树的C++实现文件(AVRTree.h)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _AVL_TREE_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AVL_TREE_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T key;                <span class="comment">// 关键字(键值)</span></span><br><span class="line">        <span class="keyword">int</span> height;         <span class="comment">// 高度</span></span><br><span class="line">        AVLTreeNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">        AVLTreeNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVLTreeNode</span>(T value, AVLTreeNode *l, AVLTreeNode *r):</span><br><span class="line">            <span class="built_in">key</span>(value), <span class="built_in">height</span>(<span class="number">0</span>),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        AVLTreeNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AVLTree</span>();</span><br><span class="line">        ~<span class="built_in">AVLTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 获取树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;AVL树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到AVL树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 获取树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> </span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;AVL树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">search</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(AVLTreeNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(AVLTreeNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LL：左左对应的情况(左单旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k2)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RR：右右对应的情况(右单旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LR：左右对应的情况(左双旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">leftRightRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k3)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RL：右左对应的情况(右双旋转)。</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">rightLeftRotation</span><span class="params">(AVLTreeNode&lt;T&gt;* k1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到AVL树(tree)中</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">insert</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除AVL树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">AVLTreeNode&lt;T&gt;* <span class="title">remove</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(AVLTreeNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印AVL树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AVLTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTree&lt;T&gt;::<span class="built_in">AVLTree</span>():<span class="built_in">mRoot</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTree&lt;T&gt;::~<span class="built_in">AVLTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取树的高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>(AVLTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> tree-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">height</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 比较两个值的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::<span class="built_in">max</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">preOrder</span>(AVLTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">preOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">inOrder</span>(AVLTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">inOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;AVL树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">postOrder</span>(AVLTreeNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">postOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">search</span>(AVLTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">search</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找&quot;AVL树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(AVLTreeNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小结点：返回tree为根结点的AVL树的最小结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">minimum</span>(AVLTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T AVLTree&lt;T&gt;::<span class="built_in">minimum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大结点：返回tree为根结点的AVL树的最大结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">maximum</span>(AVLTreeNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T AVLTree&lt;T&gt;::<span class="built_in">maximum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LL：左左对应的情况(左单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftLeftRotation</span>(AVLTreeNode&lt;T&gt;* k2)</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k1;</span><br><span class="line"></span><br><span class="line">    k1 = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), k2-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RR：右右对应的情况(右单旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightRightRotation</span>(AVLTreeNode&lt;T&gt;* k1)</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* k2;</span><br><span class="line"></span><br><span class="line">    k2 = k1-&gt;right;</span><br><span class="line">    k1-&gt;right = k2-&gt;left;</span><br><span class="line">    k2-&gt;left = k1;</span><br><span class="line"></span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(k2-&gt;right), k1-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LR：左右对应的情况(左双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">leftRightRotation</span>(AVLTreeNode&lt;T&gt;* k3)</span><br><span class="line">&#123;</span><br><span class="line">    k3-&gt;left = <span class="built_in">rightRightRotation</span>(k3-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">leftLeftRotation</span>(k3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RL：右左对应的情况(右双旋转)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：旋转后的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">rightLeftRotation</span>(AVLTreeNode&lt;T&gt;* k1)</span><br><span class="line">&#123;</span><br><span class="line">    k1-&gt;right = <span class="built_in">leftLeftRotation</span>(k1-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rightRightRotation</span>(k1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点插入到AVL树中，并返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入的结点的键值</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">insert</span>(AVLTreeNode&lt;T&gt;* &amp;tree, T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新建节点</span></span><br><span class="line">        tree = <span class="keyword">new</span> AVLTreeNode&lt;T&gt;(key, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ERROR: create avltree node failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的左子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">insert</span>(tree-&gt;left, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;key)</span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;key) <span class="comment">// 应该将key插入到&quot;tree的右子树&quot;的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">insert</span>(tree-&gt;right, key);</span><br><span class="line">        <span class="comment">// 插入节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;key)</span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//key == tree-&gt;key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;添加失败：不允许添加相同的节点！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>(tree-&gt;left), <span class="built_in">height</span>(tree-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">insert</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，返回根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree AVL树的根结点</span></span><br><span class="line"><span class="comment"> *     z 待删除的结点</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *     根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::<span class="built_in">remove</span>(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根为空 或者 没有要删除的节点，直接返回NULL。</span></span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span> || z==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z-&gt;key &lt; tree-&gt;key)        <span class="comment">// 待删除的节点在&quot;tree的左子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;right) - <span class="built_in">height</span>(tree-&gt;left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *r =  tree-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(r-&gt;left) &gt; <span class="built_in">height</span>(r-&gt;right))</span><br><span class="line">                tree = <span class="built_in">rightLeftRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">rightRightRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; tree-&gt;key)<span class="comment">// 待删除的节点在&quot;tree的右子树&quot;中</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, z);</span><br><span class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) - <span class="built_in">height</span>(tree-&gt;right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt; *l =  tree-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(l-&gt;right) &gt; <span class="built_in">height</span>(l-&gt;left))</span><br><span class="line">                tree = <span class="built_in">leftRightRotation</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tree = <span class="built_in">leftLeftRotation</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// tree是对应要删除的节点。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// tree的左右孩子都非空</span></span><br><span class="line">        <span class="keyword">if</span> ((tree-&gt;left!=<span class="literal">NULL</span>) &amp;&amp; (tree-&gt;right!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(tree-&gt;left) &gt; <span class="built_in">height</span>(tree-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树比右子树高；</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的左子树中的最大节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最大节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最大节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的左子树中最大节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的左子树中最大节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* max = <span class="built_in">maximum</span>(tree-&gt;left);</span><br><span class="line">                tree-&gt;key = max-&gt;key;</span><br><span class="line">                tree-&gt;left = <span class="built_in">remove</span>(tree-&gt;left, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</span></span><br><span class="line">                <span class="comment">// 则(01)找出tree的右子树中的最小节点</span></span><br><span class="line">                <span class="comment">//   (02)将该最小节点的值赋值给tree。</span></span><br><span class="line">                <span class="comment">//   (03)删除该最小节点。</span></span><br><span class="line">                <span class="comment">// 这类似于用&quot;tree的右子树中最小节点&quot;做&quot;tree&quot;的替身；</span></span><br><span class="line">                <span class="comment">// 采用这种方式的好处是：删除&quot;tree的右子树中最小节点&quot;之后，AVL树仍然是平衡的。</span></span><br><span class="line">                AVLTreeNode&lt;T&gt;* min = <span class="built_in">maximum</span>(tree-&gt;right);</span><br><span class="line">                tree-&gt;key = min-&gt;key;</span><br><span class="line">                tree-&gt;right = <span class="built_in">remove</span>(tree-&gt;right, min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLTreeNode&lt;T&gt;* tmp = tree;</span><br><span class="line">            tree = (tree-&gt;left!=<span class="literal">NULL</span>) ? tree-&gt;left : tree-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    AVLTreeNode&lt;T&gt;* z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        mRoot = <span class="built_in">remove</span>(mRoot, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁AVL树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">destroy</span>(AVLTreeNode&lt;T&gt;* &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">destroy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值</span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">print</span>(AVLTreeNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="AVL树的C-测试程序">AVL树的C++测试程序</h3><p>AVL树的测试程序(AVLTreeTest.cpp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C 语言: AVL树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AVLTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]= &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,ilen;</span><br><span class="line">    AVLTree&lt;<span class="keyword">int</span>&gt;* tree=<span class="keyword">new</span> AVLTree&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 依次添加: &quot;</span>;</span><br><span class="line">    ilen = <span class="built_in">TBL_SIZE</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree-&gt;<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 前序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">preOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 后序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 高度: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">height</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最小值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">minimum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最大值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">maximum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    i = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 删除根节点: &quot;</span> &lt;&lt; i;</span><br><span class="line">    tree-&gt;<span class="built_in">remove</span>(i);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 高度: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">height</span>() ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span> ;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    tree-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试程序中，首先新建一棵AVL树，然后依次添加&quot;3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9&quot; 到AVL树中；添加完毕之后，再将8从AVL树中删除。AVL树的添加和删除过程如下图：</p><p>（1）添加3，2</p><p>添加3,2都不会破坏AVL树的平衡性。</p><p><img src="https://i.loli.net/2021/04/24/aEdgWLZP8Ap75rG.jpg" alt="AVL树添加.jpg"></p><p>（2）添加1</p><p>添加1之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/7ri9ZjB8Yvn6mtR.jpg" alt="AVL树添加1.jpg"></p><p>（3）添加4</p><p>添加4不会破坏AVL树的平衡性。</p><p><img src="https://i.loli.net/2021/04/24/9nFBqGp26DamJoZ.jpg" alt="AVL树添加4.jpg"></p><p>（4）添加5</p><p>添加5之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/LXYtNRobH67m5f2.jpg" alt="AVL树添加5.jpg"></p><p>（5）添加6</p><p>添加6之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/eCARwU14Ls6aJnW.jpg" alt="AVL树添加6.jpg"></p><p>（6）添加7</p><p>添加7之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/PGHOciX8SsCLQNT.jpg" alt="AVL树添加7.jpg"></p><p>（7）添加16</p><p>添加16不会破坏AVL树的平衡性。</p><p><img src="https://i.loli.net/2021/04/24/wvUnltTVyJGCAiH.jpg" alt="AVL树添加16.jpg"></p><p>（8）添加15</p><p>添加15之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/HWtKz1arZUpCyBV.jpg" alt="AVL树添加15.jpg"></p><p>（9）添加14</p><p>添加14之后，AVL树失去平衡(RL)，此时需要对AVL树进行旋转(RL旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/WUSHAE6aF38oxem.jpg" alt="添加14.jpg"></p><p>（10）添加13</p><p>添加13之后，AVL树失去平衡(RR)，此时需要对AVL树进行旋转(RR旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/gxRGLJrBm3czlVi.jpg" alt="添加13.jpg"></p><p>（11）添加12</p><p>添加12之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/O2VKjyRtSAg7CnW.jpg" alt="添加12.jpg"></p><p>（12）添加11</p><p>添加11之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/M8GOBHCqQdbS1h4.jpg" alt="添加11.jpg"></p><p>（13）添加10</p><p>添加10之后，AVL树失去平衡(LL)，此时需要对AVL树进行旋转(LL旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/Kd5xqlpBXH6mZsY.jpg" alt="添加10.jpg"></p><p>（14）添加8</p><p>添加8不会破坏AVL树的平衡性。</p><p><img src="https://i.loli.net/2021/04/24/Cxj8VIoKGtmBfTQ.jpg" alt="添加8.jpg"></p><p>（15）添加9</p><p>但是添加9之后，AVL树失去平衡(LR)，此时需要对AVL树进行旋转(LR旋转)。旋转过程如下：</p><p><img src="https://i.loli.net/2021/04/24/9IZhmeOAgvF7fQk.jpg" alt="添加9.jpg"></p><p>添加完所有数据之后，得到的AVL树如下：</p><p><img src="https://i.loli.net/2021/04/24/clPHkEVin4NtKuT.jpg" alt="添加完成.jpg"></p><p>接着，删除节点8.删除节点8并不会造成AVL树的不平衡，所以不需要旋转，操作示意图如下：</p><p><img src="https://i.loli.net/2021/04/24/O1FhPXeyRWk2Kn4.jpg" alt="删除8.jpg"></p><p>程序运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">== 依次添加: 3 2 1 4 5 6 7 16 15 14 13 12 11 10 8 9 </span><br><span class="line">== 前序遍历: 7 4 2 1 3 6 5 13 11 9 8 10 12 15 14 16 </span><br><span class="line">== 中序遍历: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 </span><br><span class="line">== 后序遍历: 1 3 2 5 6 4 8 10 9 12 11 14 16 15 13 7 </span><br><span class="line">== 高度: 5</span><br><span class="line">== 最小值: 1</span><br><span class="line">== 最大值: 16</span><br><span class="line">== 树的详细信息: </span><br><span class="line">is root</span><br><span class="line">is  7&#x27;s   left child</span><br><span class="line">is  4&#x27;s   left child</span><br><span class="line">is  2&#x27;s   left child</span><br><span class="line">is  2&#x27;s  right child</span><br><span class="line">is  4&#x27;s  right child</span><br><span class="line">is  6&#x27;s   left child</span><br><span class="line">is  7&#x27;s  right child</span><br><span class="line">is 13&#x27;s   left child</span><br><span class="line">is 11&#x27;s   left child</span><br><span class="line">is  9&#x27;s   left child</span><br><span class="line">is  9&#x27;s  right child</span><br><span class="line">is 11&#x27;s  right child</span><br><span class="line">is 13&#x27;s  right child</span><br><span class="line">is 15&#x27;s   left child</span><br><span class="line">is 15&#x27;s  right child</span><br><span class="line"></span><br><span class="line">== 删除根节点: 8</span><br><span class="line">== 高度: 5</span><br><span class="line">== 中序遍历: 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 </span><br><span class="line">== 树的详细信息: </span><br><span class="line">is root</span><br><span class="line">is  7&#x27;s   left child</span><br><span class="line">is  4&#x27;s   left child</span><br><span class="line">is  2&#x27;s   left child</span><br><span class="line">is  2&#x27;s  right child</span><br><span class="line">is  4&#x27;s  right child</span><br><span class="line">is  6&#x27;s   left child</span><br><span class="line">is  7&#x27;s  right child</span><br><span class="line">is 13&#x27;s   left child</span><br><span class="line">is 11&#x27;s   left child</span><br><span class="line">is  9&#x27;s  right child</span><br><span class="line">is 11&#x27;s  right child</span><br><span class="line">is 13&#x27;s  right child</span><br><span class="line">is 15&#x27;s   left child</span><br><span class="line">is 15&#x27;s  right child</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>对AVL树的理论知识进行简单介绍，给出C++实现，并对实现代码进行了测试。</p><blockquote><p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3577360.html">https://www.cnblogs.com/skywang12345/p/3577360.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：对AVL树的理论知识进行简单介绍，给出C++实现，并对实现代码进行了测试。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="AVL树" scheme="http://example.com/tags/AVL%E6%A0%91/"/>
    
    <category term="AVL树旋转" scheme="http://example.com/tags/AVL%E6%A0%91%E6%97%8B%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>个人主页</title>
    <link href="http://example.com/2021/04/24/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    <id>http://example.com/2021/04/24/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</id>
    <published>2021-04-24T05:23:22.000Z</published>
    <updated>2021-04-24T13:37:55.219Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 密码错误, 请联系翟少华获取密码." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9345f896d37b9f5e2abf07cc2119690b0e471c839e507e20a27ee4e54a5d9fbf">518e54c91656481a908483089544e9165d5d3967b07fc15a6a03d2b43aa7874a07b7ad9973e03ffb04e093a7e4f51cd1a0d7eefaba3ff3ae23ee18e70f504d445e25643067bd41745f781595f666d10a0bb2348c890c7bb510da1604b342d0cb53f621b8622fd1dfc0875d772f114618fc9acc2feac2d3fd4c52ad023ede8bf8aea6169152d090235ecf3d93aafcc9a8090e4fd32a560c637199c40cd3b511afee5ccbf6619ad2e8bd7ba45feb855ed6158b6beffa62dac690ed11a4f966ea0a25a680f827c5fe72ba26adc6464a70c7e2d656ccc5bac89fcaeb0fe97e0d42828050b9fc752029f485aa9acfa02619096854b580f3fa04c2ad4fa55d389ebe2b44423c76b684444988916965cf1925e3bb2f690c6062ce3edab2e185066d543b08f0997983205d4e7d73cdc27b756d625087fea6e7fa14e8108ec119f16de65decf066a5b9db4b3d8bb0dbe7d07d7e1158d558786820c8f0f64424e0cc787306523414e00edbbae22e559b1e5c7079977099c4cc88df877752b8f91559c7469ebcca2a9cd9b4488c84ffe287bee3597608f294f2491307ecf935b735a7668ddcc62ce83162866dc84ac50969c91a073193bcd855f06ef23a65e0e4887dc249c1345752940a222e8d71acad0e25684e9fc3492515c4576d1479a33fc62e057133</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">您好, 请单击此处输入本文密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">引言：收藏一些优秀的个人主页及其介绍。</summary>
    
    
    
    <category term="外部资源" scheme="http://example.com/categories/%E5%A4%96%E9%83%A8%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构及实现：二叉查找树</title>
    <link href="http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://example.com/2021/04/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</id>
    <published>2021-04-21T15:27:59.000Z</published>
    <updated>2021-04-24T13:26:43.838Z</updated>
    
    <content type="html"><![CDATA[<p>引言：二叉查找树的C++实现代码，并进行了测试。</p><span id="more"></span><h3 id="二叉查找树简介">二叉查找树简介</h3><p>二叉查找树(Binary Search Tree)，又被称为二叉搜索树。它是特殊的二叉树：对于二叉树，假设x为二叉树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。那么，这棵树就是二叉查找树。如下图所示：</p><p><img src="https://i.loli.net/2021/04/20/Ddq61aksuTCjpWK.jpg" alt="二叉查找树.jpg"></p><p>在二叉查找树中：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）任意节点的左、右子树也分别为二叉查找树；<br>（4）没有key值相等的节点。</p><h3 id="二叉查找树的C-实现">二叉查找树的C++实现</h3><h4 id="节点和二叉查找树的定义">节点和二叉查找树的定义</h4><h5 id="二叉查找树节点">二叉查找树节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T key;<span class="comment">// 关键字（键值）</span></span><br><span class="line">    BSTNode* left; <span class="comment">// 左孩子</span></span><br><span class="line">    BSTNode* right;<span class="comment">// 右孩子</span></span><br><span class="line">    BSTNode* parent;<span class="comment">// 父节点</span></span><br><span class="line">    <span class="built_in">BSTNode</span>(T value, BSTNode *p, BSTNode *l, BSTNode *r):</span><br><span class="line">    <span class="built_in">key</span>(value),<span class="built_in">parent</span>(p),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BSTNode是二叉查找树的节点，它包含二叉查找树的几个基本信息：</p><p>（1）key – 它是关键字，是用来对二叉查找树的节点进行排序的；<br>（2）left – 它指向当前节点的左孩子；<br>（3）right – 它指向当前节点的右孩子；<br>（4）parent – 它指向当前节点的父结点。</p><h5 id="二叉树操作">二叉树操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BSTNode&lt;T&gt;* mRoot;    <span class="comment">// 根结点</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTree</span>();</span><br><span class="line">    ~<span class="built_in">BSTree</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (递归实现)查找二叉树中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找二叉树中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回最小结点的键值</span></span><br><span class="line">    <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">    <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结点(z)插入到二叉树(tree)中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除二叉树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">    <span class="function">BSTNode&lt;T&gt;* <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BSTree是二叉树。它包含二叉查找树的根节点和二叉查找树的操作。二叉查找树的操作中有许多重载函数，例如insert()函数，其中一个是内部接口，另一个是提供给外部的接口。</p><h4 id="遍历">遍历</h4><p>这里讲解前序遍历、中序遍历、后序遍历3种方式。</p><h5 id="前序遍历">前序遍历</h5><p>若二叉树非空，则执行以下操作：</p><p>（1）访问根结点；<br>（2）先序遍历左子树；<br>（3）先序遍历右子树。</p><p>前序遍历代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历">中序遍历</h5><p>若二叉树非空，则执行以下操作：</p><p>（1）中序遍历左子树；<br>（2）访问根结点；<br>（3）中序遍历右子树。</p><p>中序遍历代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历">后序遍历</h5><p>若二叉树非空，则执行以下操作：</p><p>（1）后序遍历左子树；<br>（2）后序遍历右子树；<br>（3）访问根结点。</p><p>后序遍历代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看下面这颗树的各种遍历方式：</p><p><img src="https://i.loli.net/2021/04/22/yiEtOTcJC1bw8Wu.jpg" alt="二叉树遍历.jpg"></p><p>对于上面的二叉树而言，<br>（1）前序遍历结果： 3 1 2 5 4 6<br>（2）中序遍历结果： 1 2 3 4 5 6<br>（3）后序遍历结果： 2 1 4 6 5 3</p><h4 id="查找">查找</h4><p>递归版本的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key) &#123;</span><br><span class="line">    <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大值和最小值">最大值和最小值</h4><p>查找最大值的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">maximum</span>(BSTNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">maximum</span>() &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最小值的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">minimum</span>(BSTNode&lt;T&gt;* tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">minimum</span>() &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前驱和后继">前驱和后继</h4><p>节点的前驱：是该节点的左子树中的最大节点。<br>节点的后继：是该节点的右子树中的最小节点。</p><p>查找前驱节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">predecessor</span>(BSTNode&lt;T&gt; *x) &#123;</span><br><span class="line">    <span class="comment">// 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maximum</span>(x-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;left)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找后继节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">successor</span>(BSTNode&lt;T&gt; *x) &#123;</span><br><span class="line">    <span class="comment">// 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(x-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;right)) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入">插入</h4><p>插入节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)  &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(T key) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><p>删除节点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">remove</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *x=<span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *y=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == <span class="literal">NULL</span>) || (z-&gt;right == <span class="literal">NULL</span>) )</span><br><span class="line">        y = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = <span class="built_in">successor</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = y-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        tree = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left)</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z) </span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">remove</span>(T key) &#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z, *node; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> ( (node = <span class="built_in">remove</span>(mRoot, z)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印">打印</h4><p>打印二叉查找树的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值 </span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction) &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁">销毁</h4><p>销毁二叉查找树的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>(BSTNode&lt;T&gt;* &amp;tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">    tree=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>() &#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树的C-实现（完整源码）">二叉查找树的C++实现（完整源码）</h3><p>二叉查找树的C++实现文件(BSTree.h)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BINARY_SEARCH_TREE_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BINARY_SEARCH_TREE_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T key;            <span class="comment">// 关键字(键值)</span></span><br><span class="line">        BSTNode *left;    <span class="comment">// 左孩子</span></span><br><span class="line">        BSTNode *right;    <span class="comment">// 右孩子</span></span><br><span class="line">        BSTNode *parent;<span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">BSTNode</span>(T value, BSTNode *p, BSTNode *l, BSTNode *r):</span><br><span class="line">            <span class="built_in">key</span>(value),<span class="built_in">parent</span>(),<span class="built_in">left</span>(l),<span class="built_in">right</span>(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        BSTNode&lt;T&gt; *mRoot;    <span class="comment">// 根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BSTree</span>();</span><br><span class="line">        ~<span class="built_in">BSTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;二叉树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(T key)</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;二叉树&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回最小结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">minimum</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回最大结点的键值。</span></span><br><span class="line">        <span class="function">T <span class="title">maximum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">successor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line">        <span class="comment">// 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">predecessor</span><span class="params">(BSTNode&lt;T&gt; *x)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除结点(key为节点键值)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 前序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 中序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// 后序遍历&quot;二叉树&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BSTNode&lt;T&gt;* tree)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">search</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">// (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">iterativeSearch</span><span class="params">(BSTNode&lt;T&gt;* x, T key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">minimum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line">        <span class="comment">// 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">maximum</span><span class="params">(BSTNode&lt;T&gt;* tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结点(z)插入到二叉树(tree)中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除二叉树(tree)中的结点(z)，并返回被删除的结点</span></span><br><span class="line">        <span class="function">BSTNode&lt;T&gt;* <span class="title">remove</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(BSTNode&lt;T&gt;* &amp;tree)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印二叉树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTree&lt;T&gt;::<span class="built_in">BSTree</span>():<span class="built_in">mRoot</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 析构函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTree&lt;T&gt;::~<span class="built_in">BSTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">preOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">inOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 后序遍历&quot;二叉树&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>(BSTNode&lt;T&gt;* tree) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(tree-&gt;right);</span><br><span class="line">        cout&lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">postOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="literal">NULL</span> || x-&gt;key==key)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">search</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">search</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (非递归实现)查找&quot;二叉树x&quot;中键值为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(BSTNode&lt;T&gt;* x, T key) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((x!=<span class="literal">NULL</span>) &amp;&amp; (x-&gt;key!=key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">iterativeSearch</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">iterativeSearch</span>(mRoot, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小结点：返回tree为根结点的二叉树的最小结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">minimum</span>(BSTNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">minimum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">minimum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大结点：返回tree为根结点的二叉树的最大结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">maximum</span>(BSTNode&lt;T&gt;* tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T BSTree&lt;T&gt;::<span class="built_in">maximum</span>()</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *p = <span class="built_in">maximum</span>(mRoot);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找结点(x)的后继结点。即，查找&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">successor</span>(BSTNode&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minimum</span>(x-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;right))</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找结点(x)的前驱结点。即，查找&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">predecessor</span>(BSTNode&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maximum</span>(x-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。</span></span><br><span class="line">    <span class="comment">// (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。</span></span><br><span class="line">    BSTNode&lt;T&gt;* y = x-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> ((y!=<span class="literal">NULL</span>) &amp;&amp; (x==y-&gt;left))</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 插入的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt;* z)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *y = <span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *x = tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找z的插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="literal">NULL</span>)</span><br><span class="line">        tree = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将结点(key为节点键值)插入到二叉树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     key 插入结点的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">insert</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></span><br><span class="line">    <span class="keyword">if</span> ((z=<span class="keyword">new</span> BSTNode&lt;T&gt;(key,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insert</span>(mRoot, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BSTNode&lt;T&gt;* BSTree&lt;T&gt;::<span class="built_in">remove</span>(BSTNode&lt;T&gt;* &amp;tree, BSTNode&lt;T&gt; *z)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *x=<span class="literal">NULL</span>;</span><br><span class="line">    BSTNode&lt;T&gt; *y=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z-&gt;left == <span class="literal">NULL</span>) || (z-&gt;right == <span class="literal">NULL</span>) )</span><br><span class="line">        y = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = <span class="built_in">successor</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        x = y-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = y-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        tree = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left)</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != z)</span><br><span class="line">        z-&gt;key = y-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除结点(z)，并返回被删除的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     tree 二叉树的根结点</span></span><br><span class="line"><span class="comment"> *     z 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">remove</span>(T key)</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode&lt;T&gt; *z, *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z = <span class="built_in">search</span>(mRoot, key)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">if</span> ( (node = <span class="built_in">remove</span>(mRoot, z)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 销毁二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>(BSTNode&lt;T&gt;* &amp;tree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">destroy</span>(tree-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tree;</span><br><span class="line">    tree=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">destroy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(mRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印&quot;二叉查找树&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key        -- 节点的键值</span></span><br><span class="line"><span class="comment"> * direction  --  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment"> *               -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment"> *                1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>(BSTNode&lt;T&gt;* tree, T key, <span class="keyword">int</span> direction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is root&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tree-&gt;key &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; key &lt;&lt; <span class="string">&quot;&#x27;s &quot;</span>  &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; (direction==<span class="number">1</span>?<span class="string">&quot;right child&quot;</span> : <span class="string">&quot;left child&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;left, tree-&gt;key, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">print</span>(tree-&gt;right,tree-&gt;key,  <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BSTree&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRoot != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">print</span>(mRoot, mRoot-&gt;key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>关于二叉查找树的C++实现有两点需要补充说明的:<br>第1点：采用了STL模板。因此，二叉查找树支持任意数据类型。<br><strong>第2点：将二叉查找树的&quot;声明&quot;和&quot;实现&quot;都位于BSTree.h中。这是因为，在二叉查找树的实现采用了模板；而C++编译器不支持对模板的分离式编译！</strong></p><h3 id="二叉查找树的C-测试程序">二叉查找树的C++测试程序</h3><p>二叉查找树的C++测试程序(BSTreeTest.cpp)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * C++ 语言: 二叉查找树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> * @date 2013/11/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BSTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr[]= &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ilen;</span><br><span class="line">    BSTree&lt;<span class="keyword">int</span>&gt;* tree=<span class="keyword">new</span> BSTree&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 依次添加: &quot;</span>;</span><br><span class="line">    ilen = <span class="built_in">TBL_SIZE</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree-&gt;<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 前序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">preOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 后序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最小值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">minimum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 最大值: &quot;</span> &lt;&lt; tree-&gt;<span class="built_in">maximum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;== 树的详细信息: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    tree-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 删除根节点: &quot;</span> &lt;&lt; arr[<span class="number">3</span>];</span><br><span class="line">    tree-&gt;<span class="built_in">remove</span>(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n== 中序遍历: &quot;</span>;</span><br><span class="line">    tree-&gt;<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁二叉树</span></span><br><span class="line">    tree-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">== 依次添加: <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line">== 前序遍历: <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line">== 中序遍历: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line">== 后序遍历: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line">== 最小值: <span class="number">1</span></span><br><span class="line">== 最大值: <span class="number">6</span></span><br><span class="line">== 树的详细信息: </span><br><span class="line"> <span class="number">1</span> is root</span><br><span class="line"> <span class="number">5</span> is  <span class="number">1&#x27;</span>s  right child</span><br><span class="line"> <span class="number">4</span> is  <span class="number">5&#x27;</span>s   left child</span><br><span class="line"> <span class="number">3</span> is  <span class="number">4&#x27;</span>s   left child</span><br><span class="line"> <span class="number">2</span> is  <span class="number">3&#x27;</span>s   left child</span><br><span class="line"> <span class="number">6</span> is  <span class="number">5&#x27;</span>s  right child</span><br><span class="line">== 删除根节点: <span class="number">3</span></span><br><span class="line">== 中序遍历: <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>下面对测试程序的流程进行分析！</p><p>（1）新建&quot;二叉查找树&quot;root。</p><p>（2）向二叉查找树中依次插入1,5,4,3,2,6 。如下图所示：</p><p><img src="https://i.loli.net/2021/04/23/FEi64SOw2lDA5Ye.jpg" alt="二叉树插入.jpg"></p><p>（3）遍历和查找，插入1,5,4,3,2,6之后，得到的二叉查找树如下：</p><p><img src="https://i.loli.net/2021/04/23/6TpIrWFCBYcxJKw.jpg" alt="二叉树插入结果.jpg"></p><p>​前序遍历结果: <strong>1 5 4 3 2 6</strong><br>​中序遍历结果: <strong>1 2 3 4 5 6</strong><br>​后序遍历结果: <strong>2 3 4 6 5 1</strong><br>​最小值是1，而最大值是6。</p><p>（4）删除节点3。如下图所示：</p><p><img src="https://i.loli.net/2021/04/23/8tqzVLSWJUEb4rX.jpg" alt="二叉树删除节点.jpg"></p><p>（5）重新遍历该二叉查找树。<br>​中序遍历结果: <strong>1 2 4 5 6</strong></p><h3 id="总结">总结</h3><p>二叉查找树的C++实现代码，并进行了测试。</p><blockquote><p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3576373.html">https://www.cnblogs.com/skywang12345/p/3576373.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：二叉查找树的C++实现代码，并进行了测试。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="二叉查找树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
    <category term="前序遍历" scheme="http://example.com/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    <category term="前驱节点和后继节点" scheme="http://example.com/tags/%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9%E5%92%8C%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/"/>
    
    <category term="递归和迭代" scheme="http://example.com/tags/%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及实现：二叉树</title>
    <link href="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-04-19T15:32:34.000Z</published>
    <updated>2021-04-22T16:42:26.862Z</updated>
    
    <content type="html"><![CDATA[<p>引言：整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。</p><span id="more"></span><h3 id="1-树的定义">1.树的定义</h3><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p><p><img src="https://i.loli.net/2021/04/19/jiL6wsCPZEWlOA3.jpg" alt="二叉树.jpg"></p><p>把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><p>(1) 每个节点有零个或多个子节点；<br>(2)没有父节点的节点称为根节点；<br>(3)每一个非根节点有且只有一个父节点；<br>(4) 除了根节点外，每个子节点可以分为多个不相交的子树。</p><h3 id="2-树的基本术语">2.树的基本术语</h3><p>若一个结点有子树，那么该结点称为子树根的&quot;双亲&quot;，子树的根是该结点的&quot;孩子&quot;。有相同双亲的结点互为&quot;兄弟&quot;。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。</p><p><strong>结点的度</strong>：结点拥有的子树的数目。<br><strong>叶子</strong>：度为零的结点。<br><strong>分支结点</strong>：度不为零的结点。<br><strong>树的度</strong>：树中结点的最大的度。<br><strong>层次</strong>：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br><strong>树的高度</strong>：树中结点的最大层次。<br><strong>无序树</strong>：如果树中结点的各子树之间的次序是不重要的，可以交换位置。<br><strong>有序树</strong>：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。<br><strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</p><h3 id="3-二叉树的定义">3.二叉树的定义</h3><p>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</p><p><img src="https://i.loli.net/2021/04/19/hUJdVmo3Ln9H4GD.jpg" alt="二叉树2.jpg"></p><h3 id="4-二叉树的性质">4.二叉树的性质</h3><p>二叉树有以下几个性质：</p><p><strong>性质1</strong>：二叉树第i层上的结点数目最多为 2<sup>{i-1}</sup> (i≥1)。<br><strong>性质2</strong>：深度为k的二叉树至多有2<sup>{k}</sup>-1个结点(k≥1)。<br><strong>性质3</strong>：包含n个结点的二叉树的高度至少为log<sub>2</sub> (n+1)。<br><strong>性质4</strong>：在任意一棵二叉树中，若叶子结点的个数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</p><blockquote><p>注：性质4的证明<br>因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=“0度结点数(n<sub>0</sub>)” + “1度结点数(n<sub>1</sub>)” + “2度结点数(n<sub>2</sub>)”。由此，得到 n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>；<br>另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n<sub>1</sub>+2n<sub>2</sub>。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为n=n<sub>1</sub>+2n<sub>2</sub>+1，两式相等，可得。</p></blockquote><h3 id="5-满二叉树，完全二叉树和二叉查找树">5.满二叉树，完全二叉树和二叉查找树</h3><p><strong>满二叉树</strong>：高度为h，并且由2<sup>{h}</sup> –1个结点的二叉树，被称为满二叉树。</p><p><img src="https://i.loli.net/2021/04/20/uPBhqe7XQxT6wKU.jpg" alt="满二叉树.jpg"></p><p><strong>完全二叉树</strong>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p><p><img src="https://i.loli.net/2021/04/20/cdp2J1GUN87EvjS.jpg" alt="完全二叉树.jpg"></p><p><strong>二叉查找树</strong>：二叉查找树，又被称为<strong>二叉搜索树</strong>。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p><p><img src="https://i.loli.net/2021/04/20/Ddq61aksuTCjpWK.jpg" alt="二叉查找树.jpg"></p><p>在二叉查找树中：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）任意节点的左、右子树也分别为二叉查找树；<br>（4）没有key值相等的节点。</p><h3 id="6-总结">6.总结</h3><p>整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。</p><blockquote><p>本文转载自：<a href="https://www.cnblogs.com/skywang12345/p/3576328.html">https://www.cnblogs.com/skywang12345/p/3576328.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：整体介绍了树的定义，基本术语，二叉树的定义和性质，以及几种特殊的二叉树。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构及实现" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch学习笔记：transforms中的方法</title>
    <link href="http://example.com/2021/04/19/PyTorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Atransforms%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/04/19/PyTorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Atransforms%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-18T16:04:56.000Z</published>
    <updated>2021-04-18T16:07:15.537Z</updated>
    
    <content type="html"><![CDATA[<p>引言 ：torchvision.transforms是pytorch中的图像预处理包，包含了很多种对图像数据进行变换的函数，这些都是在我们进行图像数据读入步骤中必不可少的。</p><span id="more"></span><h3 id="1-综述">1.综述</h3><p>transforms中的方法可以归纳为四大类：</p><ul><li><p>裁剪：</p><p>中心裁剪：<code>transforms.CenterCrop</code><br>随机裁剪：<code>transforms.RandomCrop</code><br>随机长宽比裁剪：<code>transforms.RandomResizedCrop</code><br>上下左右中心裁剪：<code>transforms.FiveCrop</code><br>上下左右中心裁剪后翻转：<code>transforms.TenCrop</code></p></li><li><p>翻转和旋转：</p><p>依概率p水平翻转：<code>transforms.RandomHorizontalFlip</code><br>依概率p垂直翻转：<code>transforms.RandomVerticalFlip</code><br>随机翻转：<code>transforms.RandomRotation</code></p></li><li><p>图像变换：</p><p>resize：<code>transforms.Resize</code><br>标准化：<code>transforms.Normalize</code><br>转tensor并归一化：<code>transforms.ToTensor</code><br>填充：<code>transforms.Pad</code><br>修改亮度、对比度、饱和度：<code>transforms.ColorTitter</code><br>转灰度图：<code>transforms.Grayscale</code><br>线性变换：<code>transforms.LinearTransformation</code><br>仿射变换：<code>transforms.RandomAffine</code><br>依概率p转为灰度图：<code>transforms.RandomGrayscale</code><br>将数据转换为PILImage：<code>transforms.ToPILImage</code><br>依自定义的lambda函数变换：<code>transforms.Lambda</code></p></li><li><p>对transforms操作，使数据增强更灵活：</p><p>选择一个transforms进行操作：<code>transforms.RandomChoice(transforms)</code><br>给一个transforms加上概率，依概率进行操作：<code>transforms.RandomApply(transforms,p=0.5)</code><br>将transforms中的操作随机打乱：<code>transforms.RandomOrder</code></p></li></ul><h3 id="2-裁剪">2.裁剪</h3><p><strong>1.中心裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.CenterCrop(size) </span><br></pre></td></tr></table></figure><p><code>size</code>：为sequence或者int，若为sequence，则为(h，w)，若为int，则进行正方形裁剪</p><p><strong>2.随机裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomCrop(size，padding = <span class="literal">None</span>，pad_if_needed = <span class="literal">False</span>，fill = <span class="number">0</span>，padding_mode =<span class="string">&#x27;constant&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>size</code>：为sequence或者int，若为sequence，则为(h，w)，若为int，则进行正方形裁剪</p><p><code>padding</code>：为sequence或者int，可选的，图像每个边上的填充，默认为None，即不填充。如果提供长度为4的序列，则它用于分别填充左，上，右，下边界。如果提供长度为2的序列，则分别用于填充左/右，上/下边界</p><p><code>pad_if_needed</code>：bool类型，如果小于所需大小，它将填充图像以避免引发异常</p><p><code>fill</code>：恒定填充的像素填充值。默认值为0.如果长度为3的元组，则分别用于填充R，G，B通道。仅当padding_mode为constant时才使用此值</p><p><code>padding_mode</code>：填充类型，可选：constant，edge，reflect，symmetric。constant是填充指定像素值，edge是填充边缘像素值，reflect是反射填充，比如用2个元素填充[1,2,3,4]为[3,2,1,2,3,4,3,2]，symmetric是对称填充，比如用2个像素填充[1,2,3,4]为[2,1,1,2,3,4,4,3]</p><p><strong>3.随机长宽比裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomResizedCrop(size, scale=(<span class="number">0.08</span>, <span class="number">1.0</span>), ratio=(<span class="number">0.75</span>, <span class="number">1.3333333333333333</span>), interpolation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将给定的PIL图像随机大小和宽高比裁剪，最后resize到指定大小</p><p><code>size</code>：输出大小</p><p><code>scale</code>：裁剪的原始尺寸的大小范围</p><p><code>ratio</code>：裁剪的原始宽高比的宽高比范围</p><p><code>interpolation</code>：resize的插值方式，默认为BILINEAR</p><p><strong>4.上下左右中心裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.FiveCrop(size)</span><br></pre></td></tr></table></figure><p>对图片进行上下左右以及中心裁剪，获得5张图片，返回一个4D-tensor</p><p><code>size</code>： sequence或者int，若为sequence,则为(h,w)，若为int，则为正方形</p><p><strong>5.上下左右中心裁剪后翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.TenCrop(size, vertical_flip=<span class="literal">False</span>) </span><br></pre></td></tr></table></figure><p>对图片进行上下左右以及中心裁剪，返回裁剪得到的5张图像加上5张翻转图像共10张图像（默认水平翻转）</p><p><code>size</code>：sequence或者int，若为sequence,则为(h,w)，若为int，则为正方形</p><p><code>vertical_flip</code>：bool类型，使用垂直翻转而不是水平翻转</p><h3 id="3-翻转和旋转">3.翻转和旋转</h3><p><strong>6.依概率p水平翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>以给定的概率随机水平翻转给定的PIL图像</p><p><code>p</code>：图像被翻转的概率，默认为0.5</p><p><strong>7.依概率p垂直翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomVerticalFlip(p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>以给定的概率随机垂直翻转给定的PIL图像</p><p><code>p</code>：图像被翻转的概率，默认为0.5</p><p><strong>8.随机旋转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomRotation(degrees, resample=<span class="literal">False</span>, expand=<span class="literal">False</span>, center=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>按角度旋转图像</p><p><code>degrees</code>：sequence 或float或int，要选择的度数范围。如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+ degrees）</p><p><code>resample</code>：插值方式</p><p><code>expand</code>：可选的扩展标志。如果为true，则展开输出以使其足够大以容纳整个旋转图像。如果为false或省略，则使输出图像与输入图像的大小相同。</p><p><code>center</code>：2元tuple，可选的旋转中心。原点是左上角。默认值是图像的中心。</p><h3 id="4-图像变换">4.图像变换</h3><p><strong>9.resize</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Resize(size, interpolation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将输入PIL图像的大小调整为给定大小。</p><p><code>size</code>：sequence 或int，所需的输出大小。如果size是类似（h，w）的序列，则输出大小将与此匹配。如果size是int，则<strong>图像的较小边缘将与此数字匹配。即，如果高度&gt;宽度，则图像将重新缩放为（尺寸*高度/宽度，尺寸）</strong></p><p><code>interpolation</code>：插值方式，默认为BILINEAR</p><p><strong>10.标准化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Normalize(mean, std)</span><br></pre></td></tr></table></figure><p>用平均值和标准差归一化张量图像。给定mean：(M1,…,Mn)和std：(S1,…,Sn)对于n通道，此变换将标准化输入的每个通道</p><p><code>mean</code>：sequence，每个通道的均值序列</p><p><code>std</code>：sequence，每个通道的标准差序列</p><p><strong>11.转tensor并归一化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.ToTensor</span><br></pre></td></tr></table></figure><p>将PIL Image或者 ndarray 转换为tensor，并且归一化至[0-1]。<strong>若自己的ndarray数据尺度有变化，则需要自行修改。</strong></p><p><strong>12.填充</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Pad(padding, fill=<span class="number">0</span>, padding_mode=<span class="string">&#x27;constant&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>padding</code>：为sequence或者int，可选的，图像每个边上的填充，默认为None，即不填充。如果提供长度为4的序列，则它用于分别填充左，上，右，下边界。如果提供长度为2的序列，则分别用于填充左/右，上/下边界</p><p><code>fill</code>：恒定填充的像素填充值。默认值为0.如果长度为3的元组，则分别用于填充R，G，B通道。仅当padding_mode为constant时才使用此值</p><p><code>padding_mode</code>：填充类型，可选：constant，edge，reflect，symmetric。constant是填充指定像素值，edge是填充边缘像素值，reflect是反射填充，比如用2个元素填充[1,2,3,4]为[3,2,1,2,3,4,3,2]，symmetric是对称填充，比如用2个像素填充[1,2,3,4]为[2,1,1,2,3,4,4,3]</p><p><strong>13.修改亮度、对比度和饱和度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.ColorJitter(brightness=<span class="number">0</span>, contrast=<span class="number">0</span>, saturation=<span class="number">0</span>, hue=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>brightness</code>： float或者元组，从该范围内随机选择brightness_factor</p><p><code>contrast</code>：float或者元组，从该范围内随机选择contrast_factor</p><p><code>saturation</code>：float或者元组，从该范围内随机选择saturation_factor</p><p><code>hue</code>：float或者元组，从该范围内随机选择hue_factor</p><p><strong>14.转灰度图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Grayscale(num_output_channels=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>num_output_channels</code>：当为1时，正常的灰度图，当为3时，r == g == b的图像</p><p><strong>15.线性变换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.LinearTransformation(transformation_matrix) </span><br></pre></td></tr></table></figure><p>用一个转换矩阵和一个离线计算出的均值向量将图片进行转换。给定转换矩阵transformation_matrix后,会将torch.*Tensor平铺并按位减mean_vector之后与转换矩阵做点积（dot product）运算，最后将shape转换成原始尺寸</p><p><strong>16.仿射变换</strong></p><p>图像保持中心不变的随机仿射变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomAffine(degrees, translate=<span class="literal">None</span>, scale=<span class="literal">None</span>, shear=<span class="literal">None</span>, resample=<span class="literal">False</span>, fillcolor=<span class="number">0</span>) </span><br></pre></td></tr></table></figure><p><code>degrees</code>：sequence或float或int，要选择的度数范围。如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+degrees）。设置为0可停用旋转</p><p><code>translate</code>：元组，可选。水平和垂直平移的最大绝对分数元组。例如translate =（a，b），然后在范围-img_width * a &lt;dx &lt;img_width * a中随机采样水平移位，并且在-img_height * b &lt;dy &lt;img_height * b范围内随机采样垂直移位。默认情况下不会平移</p><p><code>scale</code>：元组，可选。缩放因子间隔，例如（a，b），然后从范围a &lt;= scale &lt;= b中随机采样缩放。默认情况下会保持原始比例</p><p><code>shear</code>：sequence 或float或int，可选，错切角度范围， 如果degrees是一个数字而不是像（min，max）这样的序列，则度数范围将是（-degrees，+ degrees）。默认情况下不会应用错切</p><p><code>resample</code>：插值方式，默认为BILINEAR</p><p><code>fillcolor</code>：输出图像中变换外部区域的可选填充颜色</p><p><strong>17.依概率p转为灰度图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomGrayscale(p=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>依概率p将图片转换为灰度图，若通道数为3，则输出r == g == b的图像</p><p><strong>18.将数据转换为PILImage</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.ToPILImage()</span><br></pre></td></tr></table></figure><p>将tensor 或者 ndarray的数据转换为 PIL Image 类型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：对于一个Tensor的转化过程是</span><br><span class="line">1.将张量的每个元素乘上255</span><br><span class="line">2.将张量的数据类型由FloatTensor转化成Uint8</span><br><span class="line">3.将张量转化成numpy的ndarray类型</span><br><span class="line">4.对ndarray对象做permute (1, 2, 0)的操作</span><br><span class="line">5.利用Image下的fromarray函数，将ndarray对象转化成PILImage形式</span><br><span class="line">6.输出PILImage</span><br></pre></td></tr></table></figure><p><strong>19.依自定义的lambda函数变换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Lambda（<span class="keyword">lambda</span>）</span><br></pre></td></tr></table></figure><p>将用户定义的lambda应用为变换。</p><p><code>lambda</code>：用于转换的Lambda函数</p><h3 id="5-对transforms操作，使数据增强更灵活">5.对transforms操作，使数据增强更灵活</h3><p><strong>20.选择一个transforms进行操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomChoice(transforms)</span><br></pre></td></tr></table></figure><p>从给定的一系列transforms中选一个进行操作</p><p><strong>21.给一个transform加上概率，以一定的概率执行该操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomApply(transforms, p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><code>transforms</code>：列表或元组，要操作的transforms列表</p><p><code>p</code>：概率</p><p><strong>22.将transforms中的操作随机打乱</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.RandomOrder(transforms)</span><br></pre></td></tr></table></figure><p><code>transforms</code>：列表或元组，要操作的transforms列表</p><h3 id="6-Compose操作">6.Compose操作</h3><p>将一系列操作组合在一起，按顺序执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.Compose(transforms)</span><br></pre></td></tr></table></figure><p><code>transforms</code>：要组合的transforms列表</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), std = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="7-总结">7.总结</h3><p>上面所述transforms方法中，只有少部分是经常用到的，熟练掌握经常用到的即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言 ：torchvision.transforms是pytorch中的图像预处理包，包含了很多种对图像数据进行变换的函数，这些都是在我们进行图像数据读入步骤中必不可少的。&lt;/p&gt;</summary>
    
    
    
    <category term="PyTorch" scheme="http://example.com/categories/PyTorch/"/>
    
    
    <category term="torchvision.transforms" scheme="http://example.com/tags/torchvision-transforms/"/>
    
    <category term="图像预处理函数" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中的static关键字总结</title>
    <link href="http://example.com/2021/04/18/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/04/18/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-18T15:55:34.000Z</published>
    <updated>2021-04-18T16:03:54.049Z</updated>
    
    <content type="html"><![CDATA[<p>引言：C++的static有两种用法，面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。</p><span id="more"></span><h3 id="1-面向过程设计中的static">1.面向过程设计中的static</h3><h4 id="1-1静态全局变量">1.1静态全局变量</h4><p>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量，我们先举一个静态全局变量的例子，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态全局变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而<strong>在文件之外是不可见</strong>的；</li></ul><p>静态变量都在<strong>全局数据区</strong>分配内存，包括后面将要提到的静态局部变量。</p><p>一般程序的由new产生的动态数据存放在<strong>堆区</strong>，函数内部的自动变量存放在<strong>栈区</strong>。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在<strong>全局数据区</strong>。全局数据区的数据并不会因为函数的退出而释放空间。细心的读者可能会发现，上面的代码中将<code>static int n;</code>改为<code>int n; </code>。程序照样正常运行。的确，定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：</p><ul><li>静态全局变量不能被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ul><p>将上述示例代码改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　n=<span class="number">20</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 n++;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行，会发现上述代码可以分别通过编译，但运行时出现错误。将<code>static int n;</code>改为<code>int n;</code>，再次编译运行程序，就会明白全局变量和静态全局变量的区别。</p><h4 id="1-2静态局部变量">1.2静态局部变量</h4><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 我们先举一个静态局部变量的例子，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="keyword">static</span> n=<span class="number">10</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">　　 n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时，都会给该局部变量分配栈区内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p><p>静态局部变量有以下特点：</p><ul><li>该变量在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li></ul><h4 id="1-3静态函数">1.3静态函数</h4><p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;<span class="comment">//声明静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123;<span class="comment">//定义静态函数</span></span><br><span class="line"> 　　<span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line"> 　　std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义静态函数的好处：</p><ul><li>静态函数不能被其它文件所用；</li><li>其它文件中可以定义相同名字的函数，不会发生冲突。</li></ul><h3 id="2-面向对象的static关键字">2.面向对象的static关键字</h3><h4 id="2-1静态数据成员">2.1静态数据成员</h4><p>在类内的数据成员的声明前加上关键字static，该数据成员就是类内的静态成员函数，先举一个静态数据成员的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 　　<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line"> 　　<span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 　　<span class="keyword">int</span> a,b,c;</span><br><span class="line"> 　　<span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c) &#123;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> 　　Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line">　　 <span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> 　　N.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态数据成员有以下特点：</p><ul><li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也<strong>只有一份拷贝</strong>，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</li><li><strong>静态数据成员存储在全局数据区</strong>。静态数据成员<strong>定义时要分配空间，所以不能在类声明中定义</strong>。在上述程序中，语句<code>int Myclass::Sum=0;</code>是定义静态数据成员；</li><li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li><li>静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：<code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code></li><li>类的静态数据成员有两种访问形式：<code>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞</code></li><li>静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以<strong>节省存储空间</strong>。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；</li><li>同全局变量相比，使用静态数据成员有两个优势：<ul><li>静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；</li><li>可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</li></ul></li></ul><h4 id="2-2静态成员函数">2.2静态成员函数</h4><p>与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。<strong>普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身</strong>，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它<strong>不具有this指针</strong>。从这个意义上讲，它<strong>无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数</strong>。下面举个静态成员函数的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 　　<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c);</span><br><span class="line"> 　　<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;/声明静态成员函数</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> 　　<span class="keyword">int</span> a,b,c;</span><br><span class="line">　　 <span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> 　　<span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> 　　Sum+=a+b+c; <span class="comment">//非静态成员函数可以访问静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> <span class="comment">//静态成员函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="comment">// cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员</span></span><br><span class="line"> 　　cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> 　　M.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　<span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> 　　N.<span class="built_in">GetSum</span>();</span><br><span class="line"> 　　Myclass::<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于静态成员函数，可以总结为以下几点：</p><ul><li>出现在类体外的函数<strong>定义不能指定关键字static</strong>；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li><li>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式调用类的静态成员函数：<code>＜类名＞::＜静态成员函数名＞（＜参数表＞）</code>。</li></ul><h3 id="3-总结">3.总结</h3><p><strong>从作用域看</strong>，全局变量具有全局作用域，全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用<code>extern</code> 关键字再次声明这个全局变量。局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p><p><strong>从分配内存空间来看</strong>，<strong>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</strong></p><p><strong>综上，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期，并没有改变它的作用域，即作用域还是在函数内部。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：C++的static有两种用法，面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="static关键字" scheme="http://example.com/tags/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    <category term="全局变量" scheme="http://example.com/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
    <category term="局部变量" scheme="http://example.com/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="静态全局变量" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
    <category term="静态局部变量" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="静态成员函数" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    
    <category term="静态数据成员" scheme="http://example.com/tags/%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/"/>
    
    <category term="作用域" scheme="http://example.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    <category term="生存期" scheme="http://example.com/tags/%E7%94%9F%E5%AD%98%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++构造函数不能声明为虚函数</title>
    <link href="http://example.com/2021/04/18/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/04/18/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-18T15:43:07.000Z</published>
    <updated>2021-04-18T15:52:23.189Z</updated>
    
    <content type="html"><![CDATA[<p>引言：构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时是必须声明为虚函数。</p><span id="more"></span><h3 id="1-背景">1.背景</h3><p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数，且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为<strong>动态联编</strong>。而函数的重载可以认为是多态，只不过是静态的。如果使用了<code>virtual</code>关键字，程序将根据引用或指针指向的对象类型来选择方法，否则使用引用类型或指针类型来选择方法。我们知道，在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构。所以，基类的析构函数一定要定义成虚函数，那么构造函数为什么不能定义成虚函数呢？</p><h3 id="2-虚函数的底层实现机制">2.虚函数的底层实现机制</h3><p>要想搞清楚这个问题，首先要弄明白虚函数的底层是如何实现的。</p><p>编译器处理虚函数的方法是：首先为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。称为<strong>虚表指针（vptr）</strong>，这种数组称为<strong>虚函数表</strong>，即每个类使用一个虚函数表，每个类对象有一个虚表指针。</p><p>举个例子：基类对象包含一个虚表指针，指向基类所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表，看下面两种情况：</p><ul><li>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数地址，而不是基类的虚函数地址。</li><li>如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中的虚函数表将保存基类中未被重写的虚函数地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</li></ul><p>下面的图片体现了上述底层实现机制：</p><p><img src="https://i.loli.net/2021/04/18/luwBIOtfY3r1EWy.png" alt="虚函数的底层实现.jpg"></p><h3 id="3-原因">3.原因</h3><p>搞明白虚函数的底层实现机制之后，这个问题就迎刃而解了。虚函数的执行依赖于虚表指针查找虚函数表的操作，而对象的虚表指针在构造函数中进行初始化，让它指向正确的虚函数地址，而在构造对象期间，虚表指针还没有被初始化，所以将无法执行查表操作。</p><p>虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时是必须声明为虚函数。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="构造函数" scheme="http://example.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
    <category term="虚函数" scheme="http://example.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="底层实现" scheme="http://example.com/tags/%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="虚函数表" scheme="http://example.com/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
    <category term="虚表指针" scheme="http://example.com/tags/%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++之memset和fill函数</title>
    <link href="http://example.com/2021/04/17/C-%E4%B9%8Bmemset%E5%92%8Cfill%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/04/17/C-%E4%B9%8Bmemset%E5%92%8Cfill%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-16T16:37:45.000Z</published>
    <updated>2021-04-16T16:40:03.635Z</updated>
    
    <content type="html"><![CDATA[<p>引言：memset和fill都能进行赋值操作，但是二者有所区别，使用场景和方法也不同。</p><span id="more"></span><h3 id="1-问题引出">1.问题引出</h3><p>当我们运行下面一段代码试图将数组中的所有数字全部设置为1的时候，会发生预期之外的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main &#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现输出以下的结果：</p><p><code>16843009 16843009 16843009 16843009 16843009</code></p><h3 id="2-原因">2.原因</h3><p>为什么和我们的预期不符？这是因为<code>memset()</code>函数是<strong>以字节为单位进行赋值</strong>的，一个int型数据有4个字节，在上面的例子中我们赋的值是十六进制<code>0x01010101</code>，即二进制数<code>00000001 00000001 00000001 00000001</code>，换算成十进制就是16843009，所以会得出上面的结果。</p><p>所以如果想将int型数组置为想要的十进制数，<strong>只能用<code>memset()</code>置为0或者-1</strong>，因为0的二进制表示全为0， -1的二进制表示全为1，按字节为单位完成赋值的结果保持不变。</p><p>一般情况下，<code>memset()</code>只用来给char型数组赋值，或者对int型数组进行全0或者全1操作。</p><h3 id="3-解决方法">3.解决方法</h3><p><code>fill()</code>函数<strong>按照单元进行赋值</strong>，将一个区间的元素都赋予同一个值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    fill(a, a+5, 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现对数值中每个元素都赋值为1的目的，也可以对容器进行赋值，注意第一个参数和第二个参数是容器的迭代器。</p><h3 id="4-总结">4.总结</h3><p>1.<code>memset()</code>和<code>fill()</code>都可以实现赋值操作；<br>2.<code>memset()</code>是以字节为单位进行，对int型数组赋值只能赋值为0或者-1，<code>fill()</code>以元素为单位进行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;引言：memset和fill都能进行赋值操作，但是二者有所区别，使用场景和方法也不同。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="memset" scheme="http://example.com/tags/memset/"/>
    
    <category term="fill" scheme="http://example.com/tags/fill/"/>
    
  </entry>
  
</feed>
